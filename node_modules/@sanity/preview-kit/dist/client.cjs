'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var client = require('@sanity/client');
var isPlainObject = require('lodash.isplainobject');
var invariant = require('tiny-invariant');
var stega = require('@vercel/stega');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var isPlainObject__default = /*#__PURE__*/_interopDefaultCompat(isPlainObject);
var invariant__default = /*#__PURE__*/_interopDefaultCompat(invariant);
const ESCAPE = {
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "'": "\\'",
  "\\": "\\\\"
};
const UNESCAPE = {
  "\\f": "\f",
  "\\n": "\n",
  "\\r": "\r",
  "\\t": "	",
  "\\'": "'",
  "\\\\": "\\"
};
function normalisedJsonPath(path) {
  return "$".concat(path.map(key => {
    if (typeof key === "string") {
      const escapedKey = key.replace(/[\f\n\r\t'\\]/g, match => {
        return ESCAPE[match];
      });
      return "['".concat(escapedKey, "']");
    }
    return "[".concat(key, "]");
  }).join(""));
}
function parseNormalisedJsonPath(path) {
  const parsed = [];
  const parseRe = /\['(.*?)'\]|\[(\d+)\]/g;
  let match;
  while ((match = parseRe.exec(path)) !== null) {
    if (match[1] !== void 0) {
      const key = match[1].replace(/\\(\\|f|n|r|t|')/g, m => {
        return UNESCAPE[m];
      });
      parsed.push(key);
      continue;
    }
    if (match[2] !== void 0) {
      parsed.push(parseInt(match[2], 10));
      continue;
    }
  }
  return parsed;
}
function defineEditLink(_studioUrl) {
  const studioUrl = _studioUrl.replace(/\/$/, "");
  return (sourceDocument, path) => "".concat(studioUrl, "/intent/edit/id=").concat(sourceDocument._id, ";path=").concat(encodeJsonPathToUriComponent(path));
}
function encodeJsonPathToUriComponent(path) {
  const sourcePath = Array.isArray(path) ? path : parseNormalisedJsonPath(path);
  return encodeURIComponent(sourcePath.map((key, i) =>
  // eslint-disable-next-line no-nested-ternary
  typeof key === "number" ? "[".concat(key, "]") : i > 0 ? ".".concat(key) : key).join(""));
}
function isRecord(value) {
  return typeof value === "object" && value !== null;
}
function isArray(value) {
  return value !== null && Array.isArray(value);
}
function encode(response, encoder) {
  if (!response.resultSourceMap) {
    throw new TypeError("Missing resultSourceMap");
  }
  response.result = encodeIntoResult(response, encoder);
  return response;
}
function encodeIntoResult(response, encoder) {
  return walkMap(response.result, (value, path) => {
    if (typeof value !== "string") {
      return value;
    }
    const resolveMappingResult = resolveMapping(path, response.resultSourceMap);
    if (!resolveMappingResult) {
      return value;
    }
    const [mapping,, pathSuffix] = resolveMappingResult;
    if (mapping.type !== "value") {
      return value;
    }
    if (mapping.source.type !== "documentValue") {
      return value;
    }
    const sourceDocument = response.resultSourceMap.documents[mapping.source.document];
    const sourcePath = response.resultSourceMap.paths[mapping.source.path];
    return encoder(value, sourceDocument, sourcePath + pathSuffix);
  });
}
function walkMap(value, mappingFn) {
  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  if (isArray(value)) {
    return value.map((v, idx) => walkMap(v, mappingFn, path.concat(idx)));
  }
  if (isRecord(value)) {
    return Object.fromEntries(Object.entries(value).map(_ref => {
      let [k, v] = _ref;
      return [k, walkMap(v, mappingFn, path.concat(k))];
    }));
  }
  return mappingFn(value, path);
}
function resolveMapping(resultPath, csm, logger) {
  const resultJsonPath = normalisedJsonPath(resultPath);
  if (!csm.mappings) {
    logger == null ? void 0 : logger.error("Missing resultSourceMap.mappings", {
      resultSourceMap: csm
    });
    return void 0;
  }
  if (csm.mappings[resultJsonPath] !== void 0) {
    return [csm.mappings[resultJsonPath], resultJsonPath, ""];
  }
  const mappings = Object.entries(csm.mappings).filter(_ref2 => {
    let [key] = _ref2;
    return resultJsonPath.startsWith(key);
  }).sort((_ref3, _ref4) => {
    let [key1] = _ref3;
    let [key2] = _ref4;
    return key2.length - key1.length;
  });
  if (mappings.length == 0) {
    return void 0;
  }
  const [matchedPath, mapping] = mappings[0];
  const pathSuffix = resultJsonPath.substring(matchedPath.length);
  return [mapping, matchedPath, pathSuffix];
}
const filterDefault = _ref5 => {
  let {
    path
  } = _ref5;
  const endPath = path.at(-1);
  if (path.at(-2) === "slug" && endPath === "current") {
    return false;
  }
  if (typeof endPath === "string" && endPath.startsWith("_")) {
    return false;
  }
  if (typeof path.at(-2) === "number" && endPath === "style") {
    return false;
  }
  return true;
};
const TRUNCATE_LENGTH = 20;
function createTranscoder(studioUrl, encodeSourceMapAtPath, logger) {
  const createEditLink = defineEditLink(studioUrl);
  const report = {
    encoded: [],
    skipped: []
  };
  const transcode = (input, sourceDocument, sourcePath) => {
    if ((typeof encodeSourceMapAtPath === "function" ? encodeSourceMapAtPath({
      path: sourcePath,
      filterDefault
    }) : filterDefault({
      path: sourcePath,
      filterDefault
    })) === false) {
      if (logger) {
        report.skipped.push({
          path: JSON.stringify(sourcePath),
          value: "".concat(input.slice(0, TRUNCATE_LENGTH)).concat(input.length > TRUNCATE_LENGTH ? "..." : ""),
          length: input.length
        });
      }
      return input;
    }
    if (logger) {
      report.encoded.push({
        path: JSON.stringify(sourcePath),
        value: "".concat(input.slice(0, TRUNCATE_LENGTH)).concat(input.length > TRUNCATE_LENGTH ? "..." : ""),
        length: input.length
      });
    }
    return "".concat(stega.vercelStegaEncode({
      origin: "sanity.io",
      href: createEditLink(sourceDocument, sourcePath)
    })).concat(input);
  };
  return {
    report,
    transcode,
    walk: input => {
      report.encoded.length = 0;
      report.skipped.length = 0;
      return encode(input, (value, sourceDocument, path) => transcode(value, sourceDocument, parseNormalisedJsonPath(path)));
    }
  };
}
function transcodeResponse(_ref6) {
  let {
    studioUrl,
    encodeSourceMapAtPath,
    logger
  } = _ref6;
  const transcoder = createTranscoder(studioUrl, encodeSourceMapAtPath, logger);
  return {
    onResponse: response => {
      if (!isBodyResponse(response)) {
        return response;
      }
      if (Array.isArray(response.body) || typeof response.body === "string" || isPlainObject__default.default(response.body)) {
        if (!isContentSourceMapBody(response.body)) {
          if (logger) {
            logger == null ? void 0 : logger.error("[@sanity/preview-kit]: Missing Content Source Map from response body", response.body);
          }
          return response;
        }
        const body = transcoder.walk(response.body);
        if (logger) {
          const isSkipping = transcoder.report.skipped.length;
          const isEncoding = transcoder.report.encoded.length;
          if (isSkipping || isEncoding) {
            logger == null ? void 0 : logger.groupCollapsed("[@sanity/preview-kit]: Stega encoding source map into result");
            logger == null ? void 0 : logger.log("[@sanity/preview-kit]: Paths encoded: ".concat(transcoder.report.encoded.length, ", skipped: ").concat(transcoder.report.skipped.length));
          }
          if (transcoder.report.encoded.length > 0) {
            logger == null ? void 0 : logger.log("[@sanity/preview-kit]: Table of encoded paths");
            logger == null ? void 0 : logger.table(transcoder.report.encoded);
          }
          if (transcoder.report.skipped.length > 0) {
            const skipped = /* @__PURE__ */new Map();
            for (const {
              path
            } of transcoder.report.skipped) {
              skipped.set(path, JSON.parse(path));
            }
            logger == null ? void 0 : logger.log("[@sanity/preview-kit]: List of skipped paths", [...skipped.values()]);
          }
          if (isSkipping || isEncoding) {
            logger == null ? void 0 : logger.groupEnd();
          }
        }
        return {
          ...response,
          body
        };
      }
      return response;
    }
  };
}
function createHttpRequest(_ref7) {
  let {
    studioUrl,
    encodeSourceMapAtPath,
    logger
  } = _ref7;
  invariant__default.default(studioUrl, "Missing studioUrl in client config");
  const superRequester = client.requester.clone();
  superRequester.use(transcodeResponse({
    studioUrl,
    encodeSourceMapAtPath,
    logger
  }));
  function httpRequest(options) {
    let requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : superRequester;
    return requester({
      maxRedirects: 0,
      ...options
    });
  }
  httpRequest.defaultRequester = superRequester;
  return httpRequest;
}
function isBodyResponse(response) {
  return typeof response === "object" && response !== null;
}
function isContentSourceMapBody(body) {
  return typeof body === "object" && body !== null && "resultSourceMap" in body;
}
function mapToEditLinks(response, studioUrl) {
  const createEditLink = defineEditLink(studioUrl);
  return encodeIntoResult(response, (_, sourceDocument, path) => {
    return createEditLink(sourceDocument, path);
  });
}
const createClient = config => {
  const {
    encodeSourceMap = detectEnableSourceMap(),
    studioUrl = detectStudioUrl(),
    logger
  } = config;
  let shouldEncodeSourceMap = encodeSourceMap === true;
  if (encodeSourceMap === "auto") {
    shouldEncodeSourceMap = isVercelPreviewEnvironment();
  }
  try {
    if (shouldEncodeSourceMap) {
      logger == null ? void 0 : logger.debug("[@sanity/preview-kit]: Creating source map enabled client");
      const httpRequest = createHttpRequest({
        ...config,
        studioUrl
      });
      return new client.SanityClient(httpRequest, {
        ...config,
        // Source maps by Content Lake are required in order to know where to insert the encoded source maps into strings
        resultSourceMap: true
      });
    }
  } catch (err) {
    console.error("[@sanity/preview-kit]: Error creating client", err, "falling back to non-embedded sourcemap mode");
  }
  return client.createClient(config);
};
function isVercelPreviewEnvironment() {
  try {
    return undefined.VERCEL_ENV === "preview";
  } catch {}
  try {
    return process.env.VERCEL_ENV === "preview";
  } catch {}
  return false;
}
function detectEnableSourceMap() {
  try {
    return undefined.SANITY_SOURCE_MAP === "true" || "auto";
  } catch {}
  try {
    return process.env.SANITY_SOURCE_MAP === "true" || "auto";
  } catch {}
  return "auto";
}
function detectStudioUrl() {
  try {
    return undefined.SANITY_STUDIO_URL;
  } catch {}
  try {
    return process.env.SANITY_STUDIO_URL;
  } catch {}
}
exports.createClient = createClient;
exports.mapToEditLinks = mapToEditLinks;
//# sourceMappingURL=client.cjs.map
