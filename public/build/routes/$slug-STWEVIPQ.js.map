{
  "version": 3,
  "sources": ["browser-route-module:routes/$slug.tsx?browser", "../../../app/routes/$slug.tsx", "../../../app/components/Record.tsx", "../../../app/components/LikeDislike.tsx", "../../../app/components/SanityContent.tsx", "../../../node_modules/@portabletext/toolkit/src/asserters.ts", "../../../node_modules/@portabletext/toolkit/src/sortMarksByOccurences.ts", "../../../node_modules/@portabletext/toolkit/src/buildMarksTree.ts", "../../../node_modules/@portabletext/toolkit/src/nestLists.ts", "../../../node_modules/@portabletext/toolkit/src/toPlainText.ts", "../../../node_modules/@portabletext/toolkit/src/spanToPlainText.ts", "../../../node_modules/@portabletext/toolkit/src/types.ts", "../../../node_modules/@portabletext/react/src/components/merge.ts", "../../../node_modules/@portabletext/react/src/components/marks.tsx", "../../../node_modules/@portabletext/react/src/components/list.tsx", "../../../node_modules/@portabletext/react/src/warnings.ts", "../../../node_modules/@portabletext/react/src/components/unknown.tsx", "../../../node_modules/@portabletext/react/src/components/defaults.tsx", "../../../node_modules/@portabletext/react/src/react-portable-text.tsx", "../../../app/components/SanityImage.tsx"],
  "sourcesContent": ["export { default, links, meta } from \"./routes/$slug.tsx\";", "import type {\nActionFunction,\nLinksFunction,\nLoaderArgs,\nSerializeFrom,\nV2_MetaFunction } from\n'@remix-run/node';\nimport { json } from '@remix-run/node';\nimport type { RouteMatch } from '@remix-run/react';\nimport { useRouteLoaderData } from '@remix-run/react';\nimport {\nisRouteErrorResponse,\nuseLoaderData,\nuseRouteError } from\n'@remix-run/react';\nimport groq from 'groq';\n\nimport { PreviewWrapper } from '~/components/PreviewWrapper';\nimport { Record } from '~/components/Record';\nimport { getPreviewToken } from '~/lib/getPreviewToken';\nimport type { loader as rootLoader } from '~/root';\nimport { OG_IMAGE_HEIGHT, OG_IMAGE_WIDTH } from '~/routes/resource.og';\nimport { client, writeClient } from '~/sanity/client';\nimport styles from '~/styles/app.css';\nimport { recordZ } from '~/types/record';\n\nexport const links: LinksFunction = () => {\n  return [{ rel: 'stylesheet', href: styles }];\n};\n\nexport const meta: V2_MetaFunction = ({ data, matches }) => {\n  const rootData = (matches.find((match: RouteMatch) => match.id === `root`) as\n  {data: SerializeFrom<typeof rootLoader>;} |\n  undefined);\n  const home = rootData ? rootData.data.home : null;\n  const title = [data?.record?.title, home?.siteTitle].\n  filter(Boolean).\n  join(' | ');\n  const { ogImageUrl } = data;\n\n  return [\n  { title },\n  { property: 'twitter:card', content: 'summary_large_image' },\n  { property: 'twitter:title', content: title },\n  { property: 'og:title', content: title },\n  { property: 'og:image:width', content: String(OG_IMAGE_WIDTH) },\n  { property: 'og:image:height', content: String(OG_IMAGE_HEIGHT) },\n  { property: 'og:image', content: ogImageUrl }];\n\n};\n\n// Perform a `like` or `dislike` mutation on a `record` document\nexport const action: ActionFunction = async ({ request }) => {\n  if (request.method !== 'POST') {\n    throw new Response('Method not allowed', { status: 405 });\n  }\n\n  const { token, projectId } = writeClient.config();\n\n  if (!token) {\n    throw new Response(\n    `Setup \"SANITY_WRITE_TOKEN\" with a token with \"Editor\" permissions to your environment variables. Create one at https://sanity.io/manage/project/${projectId}/api#tokens`,\n    { status: 401 }\n    );\n  }\n\n  const body = await request.formData();\n  const id = String(body.get('id'));\n  const action = String(body.get('action'));\n\n  if (id) {\n    switch (action) {\n      case 'LIKE':\n        return await writeClient.\n        patch(id).\n        setIfMissing({ likes: 0 }).\n        inc({ likes: 1 }).\n        commit().\n        then(({ likes, dislikes }) => ({\n          likes: likes ?? 0,\n          dislikes: dislikes ?? 0\n        }));\n      case 'DISLIKE':\n        return await writeClient.\n        patch(id).\n        setIfMissing({ dislikes: 0 }).\n        inc({ dislikes: 1 }).\n        commit().\n        then(({ likes, dislikes }) => ({\n          likes: likes ?? 0,\n          dislikes: dislikes ?? 0\n        }));\n      default:\n        return json({ message: 'Invalid action' }, 400);\n    }\n  }\n\n  return json({ message: 'Bad request' }, 400);\n};\n\n// Load the `record` document with this slug\nexport const loader = async ({ params, request }: LoaderArgs) => {\n  const { preview } = await getPreviewToken(request);\n\n  const query = groq`*[_type == \"record\" && slug.current == $slug][0]{\n    _id,\n    title,\n    // GROQ can re-shape data in the request!\n    \"slug\": slug.current,\n    \"artist\": artist->title,\n    // coalesce() returns the first value that is not null\n    // so we can ensure we have at least a zero\n    \"likes\": coalesce(likes, 0),\n    \"dislikes\": coalesce(dislikes, 0),\n    // for simplicity in this demo these are typed as \"any\"\n    // we can make them type-safe with a little more work\n    // https://www.simeongriggs.dev/type-safe-groq-queries-for-sanity-data-with-zod\n    image,\n    content,\n    // this is how we extract values from arrays\n    tracks[]{\n      _key,\n      title,\n      duration\n    }\n  }`;\n\n  const record = await client\n  // Params from the loader uses the filename\n  // $slug.tsx has the params { slug: 'hello-world' }\n  .fetch(query, params)\n  // Parsed with Zod to validate data at runtime\n  // and generate a Typescript type\n  .then((res) => res ? recordZ.parse(res) : null);\n\n  if (!record) {\n    throw new Response('Not found', { status: 404 });\n  }\n\n  // Create social share image url\n  const { origin } = new URL(request.url);\n  const ogImageUrl = `${origin}/resource/og?id=${record._id}`;\n\n  return json({\n    record,\n    ogImageUrl,\n    query: preview ? query : null,\n    params: preview ? params : null\n  });\n};\n\nexport default function RecordPage() {\n  const { record, query, params } = useLoaderData<typeof loader>();\n\n  return (\n    <PreviewWrapper\n    data={record}\n    render={Record}\n    query={query}\n    params={params} />);\n\n\n}", "/* eslint-disable prettier/prettier */\nimport { LikeDislike } from '~/components/LikeDislike'\nimport { RecordCover } from '~/components/RecordCover'\nimport { SanityContent } from '~/components/SanityContent'\nimport { Title } from '~/components/Title'\nimport { secondsToMinutes } from '~/lib/secondsToMinutes'\nimport type { RecordDocument } from '~/types/record'\n\nexport function Record(props: RecordDocument) {\n  const { _id, title, artist, content, image, tracks, likes, dislikes } = props\n\n  return (\n    <article className=\"flex flex-col items-start gap-4 lg:flex-row lg:gap-12\">\n      <div className=\"grid-gap-4 mx-auto grid max-w-[70vw] grid-cols-1 \">\n        <RecordCover image={image} title={title} />\n        <LikeDislike id={_id} likes={likes} dislikes={dislikes} />\n      </div>\n      <div className=\"flex flex-shrink-0 flex-col gap-4 md:gap-6 lg:w-2/3\">\n        <header>\n          {title ? <Title>{title}</Title> : null}\n          {artist ? (\n            <h2 className=\"bg-black text-2xl font-bold tracking-tighter text-white\">\n              {artist}\n            </h2>\n          ) : null}\n        </header>\n        {content && content?.length > 0 ? (\n          <SanityContent value={content} />\n        ) : null}\n        {tracks && tracks?.length > 0 ? (\n          <>\n            <ul className=\"grid grid-cols-1 divide-y divide-gray-100 dark:divide-gray-900\">\n              <li className=\"py-3 text-2xl font-bold tracking-tighter\">\n                {tracks?.length === 1 ? `1 Track` : `${tracks?.length} Tracks`}\n              </li>\n              {tracks.map((track) => (\n                <li\n                  key={track._key}\n                  className=\"flex items-center justify-between py-3\"\n                >\n                  <span className=\"text-lg\">{track.title}</span>\n                  {track.duration ? (\n                    <span className=\"text-sm font-bold\">\n                      {secondsToMinutes(track.duration)}\n                    </span>\n                  ) : null}\n                </li>\n              ))}\n            </ul>\n          </>\n        ) : null}\n      </div>\n    </article>\n  )\n}\n", "import {useFetcher, useLocation} from '@remix-run/react'\nimport {ThumbsDown, ThumbsUp} from 'lucide-react'\n\ntype LikeDislikeProps = {\n  id: string\n  likes: number\n  dislikes: number\n}\n\nexport function LikeDislike(props: LikeDislikeProps) {\n  const {id} = props\n  const fetcher = useFetcher()\n  const location = useLocation()\n\n  // Use fresh data returned from the ActionFunction, if a mutation has just finished\n  const isDone = fetcher.state === 'idle' && fetcher.data !== null\n  const isWorking =\n    fetcher.state === 'loading' || fetcher.state === 'submitting'\n\n  const likes =\n    isDone && Number(fetcher?.data?.likes) ? fetcher.data.likes : props?.likes\n  const optimisticLikes =\n    fetcher.formData && fetcher.formData.get('action') === 'LIKE'\n      ? likes + 1\n      : likes\n  const displayLikes = optimisticLikes || likes\n\n  const dislikes =\n    isDone && Number(fetcher?.data?.dislikes)\n      ? fetcher.data.dislikes\n      : props?.dislikes\n  const optimisticDislikes =\n    fetcher.formData && fetcher.formData.get('action') === 'DISLIKE'\n      ? dislikes + 1\n      : dislikes\n  const displayDislikes = optimisticDislikes || dislikes\n\n  return (\n    <fetcher.Form\n      action={location.pathname}\n      className=\"flex items-center justify-center gap-4 bg-black text-white\"\n      method=\"post\"\n    >\n      <input name=\"id\" type=\"hidden\" value={id} />\n      <button\n        name=\"action\"\n        type=\"submit\"\n        value=\"LIKE\"\n        disabled={isWorking}\n        className=\"flex items-center gap-2 bg-black p-4 transition-all duration-100 ease-in-out hover:bg-cyan-400 hover:text-black disabled:opacity-50\"\n        title=\"Like\"\n      >\n        <span className=\"text-xs font-bold\">{displayLikes}</span>\n        <ThumbsUp />\n        <span className=\"sr-only\">Like</span>\n      </button>\n      <button\n        name=\"action\"\n        type=\"submit\"\n        value=\"DISLIKE\"\n        disabled={isWorking}\n        className=\"flex items-center gap-2 bg-black p-4 transition-all duration-100 ease-in-out hover:bg-cyan-400 hover:text-black disabled:opacity-50\"\n        title=\"Dislike\"\n      >\n        <ThumbsDown />\n        <span className=\"text-xs font-bold\">{displayDislikes}</span>\n        <span className=\"sr-only\">Dislike</span>\n      </button>\n    </fetcher.Form>\n  )\n}\n", "import {PortableText} from '@portabletext/react'\n\nimport {SanityImage} from '~/components/SanityImage'\n\ntype ContentProps = {\n  value: any[]\n}\n\nconst components = {\n  types: {\n    image: SanityImage,\n  },\n}\n\nexport function SanityContent(props: ContentProps) {\n  const {value} = props\n\n  return (\n    <div className=\"prose font-serif dark:prose-invert md:prose-2xl prose-a:text-cyan-600 dark:prose-a:text-cyan-200\">\n      <PortableText value={value} components={components} />\n    </div>\n  )\n}\n", "import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text span.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text span, otherwise false\n */\nexport function isPortableTextSpan(\n  node: ArbitraryTypedObject | PortableTextSpan\n): node is PortableTextSpan {\n  return (\n    node._type === 'span' &&\n    'text' in node &&\n    typeof node.text === 'string' &&\n    (typeof node.marks === 'undefined' ||\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text block.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text block, otherwise false\n */\nexport function isPortableTextBlock(\n  node: PortableTextBlock | TypedObject\n): node is PortableTextBlock {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === 'string' &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== '@' &&\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!('markDefs' in node) ||\n      (Array.isArray(node.markDefs) &&\n        // Every mark definition needs to have an `_key` to be mappable in child spans\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\n    // `children` is required and needs to be an array\n    'children' in node &&\n    Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted portable list item block.\n *\n * @param block - Block to check\n * @returns True if valid Portable Text list item block, otherwise false\n */\nexport function isPortableTextListItemBlock(\n  block: PortableTextBlock | TypedObject\n): block is PortableTextListItemBlock {\n  return (\n    isPortableTextBlock(block) &&\n    'listItem' in block &&\n    typeof block.listItem === 'string' &&\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\n  )\n}\n\n/**\n * Loose check to determine if block is a toolkit list node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param block - Block to check\n * @returns True if toolkit list, otherwise false\n */\nexport function isPortableTextToolkitList(\n  block: TypedObject | ToolkitPortableTextList\n): block is ToolkitPortableTextList {\n  return block._type === '@list'\n}\n\n/**\n * Loose check to determine if span is a toolkit span node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param span - Span to check\n * @returns True if toolkit span, otherwise false\n */\nexport function isPortableTextToolkitSpan(\n  span: TypedObject | ToolkitNestedPortableTextSpan\n): span is ToolkitNestedPortableTextSpan {\n  return span._type === '@span'\n}\n\n/**\n * Loose check to determine if node is a toolkit text node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param node - Node to check\n * @returns True if toolkit text node, otherwise false\n */\nexport function isPortableTextToolkitTextNode(\n  node: TypedObject | ToolkitTextNode\n): node is ToolkitTextNode {\n  return node._type === '@text'\n}\n", "import type {PortableTextSpan, TypedObject} from '@portabletext/types'\nimport {isPortableTextSpan} from './asserters'\n\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\n\n/**\n * Figures out the optimal order of marks, in order to minimize the amount of\n * nesting/repeated elements in environments such as HTML. For instance, a naive\n * implementation might render something like:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded text</strong>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\n * </strong>\n * ```\n *\n * This is particularly necessary for cases like links, where you don't want multiple\n * individual links for different segments of the link text, even if parts of it are\n * bolded/italicized.\n *\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\n *\n * The marks are sorted in the following order:\n *\n *  1. Marks that are shared amongst the most adjacent siblings\n *  2. Non-default marks (links, custom metadata)\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\n *\n * @param span - The current span to sort\n * @param index - The index of the current span within the block\n * @param blockChildren - All children of the block being sorted\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\n */\nexport function sortMarksByOccurences(\n  span: PortableTextSpan | TypedObject,\n  index: number,\n  blockChildren: (PortableTextSpan | TypedObject)[]\n): string[] {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return []\n  }\n\n  if (!span.marks.length) {\n    return []\n  }\n\n  // Slicing because we'll be sorting with `sort()`, which mutates\n  const marks = span.marks.slice()\n  const occurences: Record<string, number> = {}\n  marks.forEach((mark) => {\n    occurences[mark] = 1\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex]\n\n      if (\n        sibling &&\n        isPortableTextSpan(sibling) &&\n        Array.isArray(sibling.marks) &&\n        sibling.marks.indexOf(mark) !== -1\n      ) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n  })\n\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\n}\n\nfunction sortMarks<U extends string, T extends Record<U, number>>(\n  occurences: T,\n  markA: U,\n  markB: U\n): number {\n  const aOccurences = occurences[markA]\n  const bOccurences = occurences[markB]\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA)\n  const bKnownPos = knownDecorators.indexOf(markB)\n\n  // Sort known decorators last\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos\n  }\n\n  // Sort other marks simply by key\n  return markA.localeCompare(markB)\n}\n", "import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextMarkDefinition,\n} from '@portabletext/types'\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\nimport {isPortableTextSpan} from './asserters'\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\n\n/**\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\n * For instance, a naive span-by-span rendering might yield:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded and </strong>\n * <em><strong>italicized text</strong></em>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a>\n *   and some bolded and <em>italicized text</em>\n * </strong>\n * ```\n *\n * Note that since \"native\" Portable Text spans cannot be nested,\n * this function returns an array of \"toolkit specific\" types:\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\n *\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\n * creating an actual tree.\n *\n * @param block - The Portable Text block to create a tree of nodes from\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\n */\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\n  block: PortableTextBlock<M>\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\n  const {children, markDefs = []} = block\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\n    _type: '@span',\n    children: [],\n    markType: '<unknown>',\n  }\n\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i]\n    if (!span) {\n      continue\n    }\n\n    const marksNeeded = sortedMarks[i] || []\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos]?.markKey || ''\n        const index = marksNeeded.indexOf(mark)\n\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = nodeStack[nodeStack.length - 1]\n    if (!currentNode) {\n      continue\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs.find((def) => def._key === markKey)\n      const markType = markDef ? markDef._type : markKey\n      const node: ToolkitNestedPortableTextSpan<M> = {\n        _type: '@span',\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey,\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    }\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(\n        lines.map((text) => ({_type: '@text', text}))\n      )\n    } else {\n      // This is some other inline object, not a text span\n      currentNode.children = currentNode.children.concat(span)\n    }\n  }\n\n  return rootNode.children\n}\n", "import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\nimport type {\n  ToolkitListNestMode,\n  ToolkitPortableTextDirectList,\n  ToolkitPortableTextHtmlList,\n  ToolkitPortableTextList,\n  ToolkitPortableTextListItem,\n} from './types'\nimport {\n  isPortableTextListItemBlock,\n  isPortableTextSpan,\n  isPortableTextToolkitList,\n} from './asserters'\n\nexport type ToolkitNestListsOutputNode<T> =\n  | T\n  | ToolkitPortableTextHtmlList\n  | ToolkitPortableTextDirectList\n\n/**\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\n * native Portable Text data structures.\n *\n * Note that the list node is not a native Portable Text node type, and thus is represented\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\n *\n * The nesting can be configured in two modes:\n *\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\n *\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\n *\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\n *\n * @param blocks - Array of Portable Text blocks and other arbitrary types\n * @param mode - Mode to use for nesting, `direct` or `html`\n * @returns Array of potentially nested nodes optimized for rendering\n */\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct'\n): (T | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'html'\n): (T | ToolkitPortableTextHtmlList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct' | 'html'\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: ToolkitListNestMode\n): ToolkitNestListsOutputNode<T>[] {\n  const tree: ToolkitNestListsOutputNode<T>[] = []\n  let currentList: ToolkitPortableTextList | undefined\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!block) {\n      continue\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block)\n      currentList = undefined\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // we actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = currentList.children[\n          currentList.children.length - 1\n        ] as ToolkitPortableTextListItem\n\n        const newLastChild: ToolkitPortableTextListItem = {\n          ...lastListItem,\n          children: [...lastListItem.children, newList],\n        }\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\n          newList as ToolkitPortableTextDirectList\n        )\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if ((block.level || 1) < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block, i, mode)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(\n  block: PortableTextListItemBlock,\n  index: number,\n  mode: ToolkitListNestMode\n): ToolkitPortableTextList {\n  return {\n    _type: '@list',\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block],\n  }\n}\n\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\n  rootNode: T,\n  matching: Partial<PortableTextListItemBlock>\n): ToolkitPortableTextList | undefined {\n  const level = matching.level || 1\n  const style = matching.listItem || 'normal'\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    isPortableTextToolkitList(rootNode) &&\n    (rootNode.level || 1) === level &&\n    filterOnType &&\n    (rootNode.listItem || 'normal') === style\n  ) {\n    return rootNode\n  }\n\n  if (!('children' in rootNode)) {\n    return undefined\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1]\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\n}\n", "import type {ArbitraryTypedObject, PortableTextBlock} from '@portabletext/types'\nimport {isPortableTextBlock, isPortableTextSpan} from './asserters'\n\nconst leadingSpace = /^\\s/\nconst trailingSpace = /^\\s/\n\n/**\n * Takes a Portable Text block (or an array of them) and returns the text value\n * of all the Portable Text span nodes. Adds whitespace when encountering inline,\n * non-span nodes to ensure text flow is optimal.\n *\n * Note that this only accounts for regular Portable Text blocks - any text inside\n * custom content types are not included in the output.\n *\n * @param block - Single block or an array of blocks to extract text from\n * @returns The plain-text content of the blocks\n */\nexport function toPlainText(\n  block: PortableTextBlock | ArbitraryTypedObject[] | PortableTextBlock[]\n): string {\n  const blocks = Array.isArray(block) ? block : [block]\n  let text = ''\n\n  blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) {\n      return\n    }\n\n    let pad = false\n    current.children.forEach((span) => {\n      if (isPortableTextSpan(span)) {\n        // If the previous element was a non-span, and we have no natural whitespace\n        // between the previous and the next span, insert it to give the spans some\n        // room to breathe. However, don't do so if this is the first span.\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? ' ' : ''\n        text += span.text\n        pad = false\n      } else {\n        pad = true\n      }\n    })\n\n    if (index !== blocks.length - 1) {\n      text += '\\n\\n'\n    }\n  })\n\n  return text\n}\n", "import type {ToolkitNestedPortableTextSpan} from './types'\nimport {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\n\n/**\n * Returns the plain-text representation of a\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\n *\n * Useful if you have a subset of nested nodes and want the text from just those,\n * instead of for the entire Portable Text block.\n *\n * @param span - Span node to get text from (Portable Text toolkit specific type)\n * @returns The plain-text version of the span\n */\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\n  let text = ''\n  span.children.forEach((current) => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current)\n    }\n  })\n  return text\n}\n", "import type {\n  ArbitraryTypedObject,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n} from '@portabletext/types'\n\n/**\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_HTML = 'html'\n\n/**\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_DIRECT = 'direct'\n\n/**\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\n */\nexport type ToolkitListNestMode = 'html' | 'direct'\n\n/**\n * Toolkit-specific type representing a nested list\n *\n * See the `nestLists()` function for more info\n */\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\n\n/**\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\n */\nexport interface ToolkitPortableTextHtmlList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes will appear as children of the _list items_\n   */\n  mode: 'html'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\n   */\n  children: ToolkitPortableTextListItem[]\n}\n\n/**\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\n * inside of the lists children, alongside other blocks.\n */\nexport interface ToolkitPortableTextDirectList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes can appear as direct children\n   */\n  mode: 'direct'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - either portable text list items, or another, deeper list\n   */\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\n}\n\n/**\n * Toolkit-specific type representing a list item block, but where the children can be another list\n */\nexport interface ToolkitPortableTextListItem\n  extends PortableTextListItemBlock<\n    PortableTextMarkDefinition,\n    PortableTextSpan | ToolkitPortableTextList\n  > {}\n\n/**\n * Toolkit-specific type representing a text node, used when nesting spans.\n *\n * See the {@link buildMarksTree | `buildMarksTree()` function}\n */\nexport interface ToolkitTextNode {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@text'\n\n  /**\n   * The actual string value of the text node\n   */\n  text: string\n}\n\n/**\n * Toolkit-specific type representing a portable text span that can hold other spans.\n * In this type, each span only has a single mark, instead of an array of them.\n */\nexport interface ToolkitNestedPortableTextSpan<\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition\n> {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@span'\n\n  /**\n   * Unique key for this span\n   */\n  _key?: string\n\n  /**\n   * Holds the value (definition) of the mark in the case of annotations.\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markDef?: M\n\n  /**\n   * The key of the mark definition (in the case of annotations).\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markKey?: string\n\n  /**\n   * Type of the mark. For annotations, this is the `_type` property of the value.\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\n   */\n  markType: string\n\n  /**\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\n   * or any inline object type.\n   */\n  children: (\n    | ToolkitTextNode\n    | ToolkitNestedPortableTextSpan<PortableTextMarkDefinition>\n    | ArbitraryTypedObject\n  )[]\n}\n", "import type {PortableTextReactComponents, PortableTextComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents\n): PortableTextReactComponents {\n  const {block, list, listItem, marks, types, ...rest} = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextReactComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextReactComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextReactComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextReactComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextReactComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types'\n): PortableTextReactComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextReactComponents[typeof key]\n  }\n\n  return parentVal\n}\n", "import type {TypedObject} from '@portabletext/types'\nimport React from 'react'\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => (\n  <a href={value?.href}>{children}</a>\n)\n\nconst underlineStyle = {textDecoration: 'underline'}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  em: ({children}) => <em>{children}</em>,\n  strong: ({children}) => <strong>{children}</strong>,\n  code: ({children}) => <code>{children}</code>,\n  underline: ({children}) => <span style={underlineStyle}>{children}</span>,\n  'strike-through': ({children}) => <del>{children}</del>,\n  link,\n}\n", "import React from 'react'\nimport type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => <ol>{children}</ol>,\n  bullet: ({children}) => <ul>{children}</ul>,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => <li>{children}</li>\n", "const getTemplate = (type: string, prop: string): string =>\n  `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  console.warn(message)\n}\n", "import React from 'react'\nimport type {PortableTextReactComponents} from '../types'\nimport {unknownTypeWarning} from '../warnings'\n\nconst hidden = {display: 'none'}\n\nexport const DefaultUnknownType: PortableTextReactComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline ? <span style={hidden}>{warning}</span> : <div style={hidden}>{warning}</div>\n}\n\nexport const DefaultUnknownMark: PortableTextReactComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return <span className={`unknown__pt__mark__${markType}`}>{children}</span>\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextReactComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return <p>{children}</p>\n}\n\nexport const DefaultUnknownList: PortableTextReactComponents['unknownList'] = ({children}) => {\n  return <ul>{children}</ul>\n}\n\nexport const DefaultUnknownListItem: PortableTextReactComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return <li>{children}</li>\n}\n", "import React from 'react'\nimport type {PortableTextBlockStyle} from '@portabletext/types'\nimport type {PortableTextBlockComponent, PortableTextReactComponents} from '../types'\nimport {defaultMarks} from './marks'\nimport {defaultLists, DefaultListItem} from './list'\nimport {\n  DefaultUnknownType,\n  DefaultUnknownMark,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownBlockStyle,\n} from './unknown'\n\nexport const DefaultHardBreak = () => <br />\n\nexport const defaultBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => <p>{children}</p>,\n  blockquote: ({children}) => <blockquote>{children}</blockquote>,\n  h1: ({children}) => <h1>{children}</h1>,\n  h2: ({children}) => <h2>{children}</h2>,\n  h3: ({children}) => <h3>{children}</h3>,\n  h4: ({children}) => <h4>{children}</h4>,\n  h5: ({children}) => <h5>{children}</h5>,\n  h6: ({children}) => <h6>{children}</h6>,\n}\n\nexport const defaultComponents: PortableTextReactComponents = {\n  types: {},\n\n  block: defaultBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n", "import React, {ReactNode, useMemo} from 'react'\nimport {\n  LIST_NEST_MODE_HTML,\n  ToolkitNestedPortableTextSpan,\n  ToolkitTextNode,\n} from '@portabletext/toolkit'\nimport type {\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextProps,\n  PortableTextReactComponents,\n  ReactPortableTextList,\n  Serializable,\n  SerializedBlock,\n} from './types'\nimport {\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  nestLists,\n  spanToPlainText,\n  buildMarksTree,\n} from '@portabletext/toolkit'\nimport type {\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\nimport {mergeComponents} from './components/merge'\nimport {defaultComponents} from './components/defaults'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function PortableText<B extends TypedObject = PortableTextBlock>({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning,\n}: PortableTextProps<B>) {\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(input) ? input : [input]\n  const nested = nestLists(blocks, listNestingMode || LIST_NEST_MODE_HTML)\n\n  const components = useMemo(() => {\n    return componentOverrides\n      ? mergeComponents(defaultComponents, componentOverrides)\n      : defaultComponents\n  }, [componentOverrides])\n\n  const renderNode = useMemo(\n    () => getNodeRenderer(components, handleMissingComponent),\n    [components, handleMissingComponent]\n  )\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode})\n  )\n\n  return <>{rendered}</>\n}\n\nconst getNodeRenderer = (\n  components: PortableTextReactComponents,\n  handleMissingComponent: MissingComponentHandler\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): ReactNode {\n    const {node, index, isInline} = options\n    const key = node._key || `node-${index}`\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index, key)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index, key)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node, index, key)\n    }\n\n    if (hasCustomComponentForNode(node)) {\n      return renderCustomBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node, key)\n    }\n\n    return renderUnknownType(node, index, key, isInline)\n  }\n\n  function hasCustomComponentForNode(node: TypedObject): boolean {\n    return node._type in components.types\n  }\n\n  /* eslint-disable react/jsx-no-bind */\n  function renderListItem(\n    node: PortableTextListItemBlock<PortableTextMarkDefinition, PortableTextSpan>,\n    index: number,\n    key: string\n  ) {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const Li = handler || components.unknownListItem\n\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block serializer says to use\n      const {listItem, ...blockNode} = node\n      children = renderNode({node: blockNode, index, isInline: false, renderNode})\n    }\n\n    return (\n      <Li key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </Li>\n    )\n  }\n\n  function renderList(node: ReactPortableTextList, index: number, key: string) {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: childIndex,\n        isInline: false,\n        renderNode,\n      })\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const List = handler || components.unknownList\n\n    if (List === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {nodeType: 'listStyle', type: style})\n    }\n\n    return (\n      <List key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </List>\n    )\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan, _index: number, key: string) {\n    const {markDef, markType, markKey} = node\n    const Span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({node: child, index: childIndex, isInline: true, renderNode})\n    )\n\n    if (Span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {nodeType: 'mark', type: markType})\n    }\n\n    return (\n      <Span\n        key={key}\n        text={spanToPlainText(node)}\n        value={markDef}\n        markType={markType}\n        markKey={markKey}\n        renderNode={renderNode}\n      >\n        {children}\n      </Span>\n    )\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, key: string, isInline: boolean) {\n    const {_key, ...props} = serializeBlock({node, index, isInline, renderNode})\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const Block = handler || components.unknownBlockStyle\n\n    if (Block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return <Block key={key} {...props} value={props.node} renderNode={renderNode} />\n  }\n\n  function renderText(node: ToolkitTextNode, key: string) {\n    if (node.text === '\\n') {\n      const HardBreak = components.hardBreak\n      return HardBreak ? <HardBreak key={key} /> : '\\n'\n    }\n\n    return node.text\n  }\n\n  function renderUnknownType(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    handleMissingComponent(unknownTypeWarning(node._type), {nodeType: 'block', type: node._type})\n\n    const UnknownType = components.unknownType\n    return <UnknownType key={key} {...nodeOptions} />\n  }\n\n  function renderCustomBlock(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    const Node = components.types[node._type]\n    return Node ? <Node key={key} {...nodeOptions} /> : null\n  }\n  /* eslint-enable react/jsx-no-bind */\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode})\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n", "/* eslint-disable prettier/prettier */\nimport type { PortableTextComponentProps } from '@portabletext/react'\nimport type { SanityImageSource } from '@sanity/asset-utils'\nimport { getImageDimensions } from '@sanity/asset-utils'\nimport urlBuilder from '@sanity/image-url'\nimport React from 'react'\n\nimport { projectDetails } from '~/sanity/projectDetails'\n\ntype SanityImageAssetWithAlt = SanityImageSource & { alt?: string }\n\nexport function SanityImage(\n  props: PortableTextComponentProps<SanityImageAssetWithAlt>\n) {\n  const { value, isInline } = props\n  const { width, height } = getImageDimensions(value)\n\n  return (\n    <img\n      className=\"not-prose h-auto w-full \"\n      src={urlBuilder(projectDetails())\n        .image(value)\n        .width(isInline ? 100 : 800)\n        .fit('max')\n        .auto('format')\n        .url()}\n      alt={value.alt || ''}\n      loading=\"lazy\"\n      style={{\n        // Display alongside text if image appears inside a block text span\n        display: isInline ? 'inline-block' : 'block',\n\n        // Avoid jumping around with aspect-ratio CSS property\n        aspectRatio: width / height,\n      }}\n    />\n  )\n}\n"],
  "mappings": "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",
  "names": ["isPortableTextSpan", "node", "_type", "text", "marks", "Array", "isArray", "every", "mark", "isPortableTextBlock", "markDefs", "def", "_key", "children", "child", "isPortableTextListItemBlock", "block", "listItem", "level", "isPortableTextToolkitList", "isPortableTextToolkitSpan", "span", "isPortableTextToolkitTextNode", "knownDecorators", "sortMarksByOccurences", "index", "blockChildren", "length", "slice", "occurences", "forEach", "siblingIndex", "sibling", "indexOf", "sort", "markA", "markB", "sortMarks", "aOccurences", "bOccurences", "aKnownPos", "bKnownPos", "localeCompare", "buildMarksTree", "_a", "sortedMarks", "map", "rootNode", "markType", "nodeStack", "i", "marksNeeded", "pos", "markKey", "splice", "currentNode", "markDef", "find", "push", "lines", "split", "line", "concat", "nestLists", "blocks", "mode", "tree", "currentList", "listFromBlock", "blockMatchesList", "newList", "lastListItem", "newLastChild", "matchingBranch", "match", "findListMatching", "console", "warn", "list", "matching", "style", "filterOnType", "spanToPlainText", "span", "text", "children", "forEach", "current", "isPortableTextToolkitTextNode", "isPortableTextToolkitSpan", "LIST_NEST_MODE_HTML", "mergeComponents", "parent", "overrides", "block", "list", "listItem", "marks", "types", "rest", "mergeDeeply", "key", "override", "parentVal", "link", "_ref", "children", "value", "jsx", "href", "underlineStyle", "textDecoration", "defaultMarks", "em", "_ref2", "strong", "_ref3", "code", "_ref4", "underline", "_ref5", "style", "_ref6", "defaultLists", "number", "_ref7", "bullet", "_ref8", "DefaultListItem", "_ref9", "getTemplate", "type", "prop", "concat", "unknownTypeWarning", "typeName", "unknownMarkWarning", "markType", "unknownBlockStyleWarning", "blockStyle", "unknownListStyleWarning", "listStyle", "unknownListItemStyleWarning", "printWarning", "message", "console", "warn", "hidden", "display", "DefaultUnknownType", "_ref10", "isInline", "warning", "_type", "DefaultUnknownMark", "_ref11", "className", "DefaultUnknownBlockStyle", "_ref12", "DefaultUnknownList", "_ref13", "DefaultUnknownListItem", "_ref14", "DefaultHardBreak", "defaultBlockStyles", "normal", "_ref15", "blockquote", "_ref16", "h1", "_ref17", "h2", "_ref18", "h3", "_ref19", "h4", "_ref20", "h5", "_ref21", "h6", "_ref22", "defaultComponents", "hardBreak", "unknownType", "unknownMark", "unknownList", "unknownListItem", "unknownBlockStyle", "PortableText", "_ref23", "input", "components", "componentOverrides", "listNestingMode", "onMissingComponent", "missingComponentHandler", "handleMissingComponent", "noop", "blocks", "Array", "isArray", "nested", "nestLists", "LIST_NEST_MODE_HTML", "useMemo", "renderNode", "getNodeRenderer", "rendered", "map", "node", "index", "options", "_key", "isPortableTextToolkitList", "renderList", "isPortableTextListItemBlock", "renderListItem", "isPortableTextToolkitSpan", "renderSpan", "hasCustomComponentForNode", "renderCustomBlock", "isPortableTextBlock", "renderBlock", "isPortableTextToolkitTextNode", "renderText", "renderUnknownType", "tree", "serializeBlock", "renderer", "handler", "Li", "nodeType", "blockNode", "child", "childIndex", "component", "List", "_index", "markDef", "markKey", "Span", "text", "spanToPlainText", "props", "Block", "HardBreak", "nodeOptions", "UnknownType", "Node", "buildMarksTree", "i", "import_jsx_dev_runtime", "urlBuilder", "import_jsx_dev_runtime", "import_jsx_dev_runtime", "import_jsx_dev_runtime"]
}
