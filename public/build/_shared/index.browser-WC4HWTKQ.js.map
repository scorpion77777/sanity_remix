{
  "version": 3,
  "sources": ["../../../node_modules/fast-deep-equal/index.js", "../../../node_modules/throttle-debounce/throttle.js", "../../../node_modules/throttle-debounce/debounce.js", "../../../node_modules/groq-js/dist/index.mjs", "../../../node_modules/groq-js/src/values/Path.ts", "../../../node_modules/groq-js/src/values/StreamValue.ts", "../../../node_modules/groq-js/src/values/dateHelpers.ts", "../../../node_modules/groq-js/src/values/utils.ts", "../../../node_modules/groq-js/src/evaluator/equality.ts", "../../../node_modules/groq-js/src/evaluator/matching.ts", "../../../node_modules/groq-js/src/evaluator/ordering.ts", "../../../node_modules/groq-js/src/evaluator/operators.ts", "../../../node_modules/groq-js/src/evaluator/scope.ts", "../../../node_modules/groq-js/src/evaluator/evaluate.ts", "../../../node_modules/groq-js/src/evaluator/constantEvaluate.ts", "../../../node_modules/groq-js/src/evaluator/pt.ts", "../../../node_modules/groq-js/src/evaluator/scoring.ts", "../../../node_modules/groq-js/src/evaluator/functions.ts", "../../../node_modules/groq-js/src/markProcessor.ts", "../../../node_modules/groq-js/src/rawParser.js", "../../../node_modules/groq-js/src/traversal.ts", "../../../node_modules/groq-js/src/parser.ts", "../../../node_modules/@sanity/groq-store/src/listen.ts", "../../../node_modules/@sanity/groq-store/src/drafts.ts", "../../../node_modules/@sanity/groq-store/src/patch.ts", "../../../node_modules/@sanity/groq-store/src/syncingDataset.ts", "../../../node_modules/@sanity/groq-store/src/groqStore.ts", "../../../node_modules/@sanity/groq-store/src/browser/getDocuments.ts", "../../../node_modules/@sanity/groq-store/src/browser/support.ts", "../../../node_modules/@sanity/groq-store/src/browser/index.ts"],
  "sourcesContent": ["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */\nexport default function (delay, callback, options) {\n\tconst {\n\t\tnoTrailing = false,\n\t\tnoLeading = false,\n\t\tdebounceMode = undefined\n\t} = options || {};\n\t/*\n\t * After wrapper has stopped being called, this timeout ensures that\n\t * `callback` is executed at the proper times in `throttle` and `end`\n\t * debounce modes.\n\t */\n\tlet timeoutID;\n\tlet cancelled = false;\n\n\t// Keep track of the last time `callback` was executed.\n\tlet lastExec = 0;\n\n\t// Function to clear existing timeout\n\tfunction clearExistingTimeout() {\n\t\tif (timeoutID) {\n\t\t\tclearTimeout(timeoutID);\n\t\t}\n\t}\n\n\t// Function to cancel next exec\n\tfunction cancel(options) {\n\t\tconst { upcomingOnly = false } = options || {};\n\t\tclearExistingTimeout();\n\t\tcancelled = !upcomingOnly;\n\t}\n\n\t/*\n\t * The `wrapper` function encapsulates all of the throttling / debouncing\n\t * functionality and when executed will limit the rate at which `callback`\n\t * is executed.\n\t */\n\tfunction wrapper(...arguments_) {\n\t\tlet self = this;\n\t\tlet elapsed = Date.now() - lastExec;\n\n\t\tif (cancelled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Execute `callback` and update the `lastExec` timestamp.\n\t\tfunction exec() {\n\t\t\tlastExec = Date.now();\n\t\t\tcallback.apply(self, arguments_);\n\t\t}\n\n\t\t/*\n\t\t * If `debounceMode` is true (at begin) this is used to clear the flag\n\t\t * to allow future `callback` executions.\n\t\t */\n\t\tfunction clear() {\n\t\t\ttimeoutID = undefined;\n\t\t}\n\n\t\tif (!noLeading && debounceMode && !timeoutID) {\n\t\t\t/*\n\t\t\t * Since `wrapper` is being called for the first time and\n\t\t\t * `debounceMode` is true (at begin), execute `callback`\n\t\t\t * and noLeading != true.\n\t\t\t */\n\t\t\texec();\n\t\t}\n\n\t\tclearExistingTimeout();\n\n\t\tif (debounceMode === undefined && elapsed > delay) {\n\t\t\tif (noLeading) {\n\t\t\t\t/*\n\t\t\t\t * In throttle mode with noLeading, if `delay` time has\n\t\t\t\t * been exceeded, update `lastExec` and schedule `callback`\n\t\t\t\t * to execute after `delay` ms.\n\t\t\t\t */\n\t\t\t\tlastExec = Date.now();\n\t\t\t\tif (!noTrailing) {\n\t\t\t\t\ttimeoutID = setTimeout(debounceMode ? clear : exec, delay);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n\t\t\t\t * `callback`.\n\t\t\t\t */\n\t\t\t\texec();\n\t\t\t}\n\t\t} else if (noTrailing !== true) {\n\t\t\t/*\n\t\t\t * In trailing throttle mode, since `delay` time has not been\n\t\t\t * exceeded, schedule `callback` to execute `delay` ms after most\n\t\t\t * recent execution.\n\t\t\t *\n\t\t\t * If `debounceMode` is true (at begin), schedule `clear` to execute\n\t\t\t * after `delay` ms.\n\t\t\t *\n\t\t\t * If `debounceMode` is false (at end), schedule `callback` to\n\t\t\t * execute after `delay` ms.\n\t\t\t */\n\t\t\ttimeoutID = setTimeout(\n\t\t\t\tdebounceMode ? clear : exec,\n\t\t\t\tdebounceMode === undefined ? delay - elapsed : delay\n\t\t\t);\n\t\t}\n\t}\n\n\twrapper.cancel = cancel;\n\n\t// Return the wrapper function.\n\treturn wrapper;\n}\n", "/* eslint-disable no-undefined */\n\nimport throttle from './throttle.js';\n\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                        to `callback` when the debounced-function is executed.\n * @param {object} [options] -           An object to configure options.\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n *\n * @returns {Function} A new, debounced function.\n */\nexport default function (delay, callback, options) {\n\tconst { atBegin = false } = options || {};\n\treturn throttle(delay, callback, { debounceMode: atBegin !== false });\n}\n", "export { evaluate, parse } from './1.mjs';\n//# sourceMappingURL=index.mjs.map\n", "function escapeRegExp(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction pathRegExp(pattern: string) {\n  const re = []\n  for (const part of pattern.split('.')) {\n    if (part === '*') {\n      re.push('[^.]+')\n    } else if (part === '**') {\n      re.push('.*')\n    } else {\n      re.push(escapeRegExp(part))\n    }\n  }\n\n  return new RegExp(`^${re.join('.')}$`)\n}\n\nexport class Path {\n  private pattern: string\n  private patternRe: RegExp\n\n  constructor(pattern: string) {\n    this.pattern = pattern\n    this.patternRe = pathRegExp(pattern)\n  }\n\n  matches(str: string): boolean {\n    return this.patternRe.test(str)\n  }\n\n  toJSON(): string {\n    return this.pattern\n  }\n}\n", "import type {Value} from './types'\n\nexport class StreamValue {\n  type: 'stream' = 'stream'\n  private generator: () => AsyncGenerator<Value, void, unknown>\n  private ticker: Promise<void> | null\n  private isDone: boolean\n  private data: Value[]\n\n  constructor(generator: () => AsyncGenerator<Value, void, unknown>) {\n    this.generator = generator\n    this.ticker = null\n    this.isDone = false\n    this.data = []\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isArray(): boolean {\n    return true\n  }\n\n  async get(): Promise<any> {\n    const result = []\n    for await (const value of this) {\n      result.push(await value.get())\n    }\n    return result\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Value, void, unknown> {\n    let i = 0\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i]\n      }\n\n      if (this.isDone) {\n        return\n      }\n\n      await this._nextTick()\n    }\n  }\n\n  _nextTick(): Promise<void> {\n    if (this.ticker) {\n      return this.ticker\n    }\n\n    let currentResolver: (value?: void | PromiseLike<void> | undefined) => void\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve\n      })\n    }\n\n    const tick = () => {\n      currentResolver()\n      setupTicker()\n    }\n\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value)\n        tick()\n      }\n\n      this.isDone = true\n      tick()\n    }\n\n    setupTicker()\n    fetch()\n    return this.ticker!\n  }\n}\n", "const RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/\n\nexport function parseRFC3339(str: string): Date | null {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str)\n  }\n  return null\n}\n\nexport function formatRFC3339(d: Date): string {\n  const year = addLeadingZero(d.getUTCFullYear(), 4)\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2)\n  const day = addLeadingZero(d.getUTCDate(), 2)\n  const hour = addLeadingZero(d.getUTCHours(), 2)\n  const minute = addLeadingZero(d.getUTCMinutes(), 2)\n  const second = addLeadingZero(d.getUTCSeconds(), 2)\n\n  let fractionalSecond = ''\n  const millis = d.getMilliseconds()\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`\n  }\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`\n}\n\ntype Stringer = {\n  toString(): string\n}\n\nfunction addLeadingZero(num: Stringer, targetLength: number) {\n  let str = num.toString()\n  while (str.length < targetLength) {\n    str = `0${str}`\n  }\n  return str\n}\n", "import {formatRFC3339, parseRFC3339} from './dateHelpers'\nimport {Path} from './Path'\nimport {StreamValue} from './StreamValue'\nimport {BooleanValue, GroqType, NullValue, Value} from './types'\n\nexport class StaticValue<P, T extends GroqType> {\n  data: P\n  type: T\n\n  constructor(data: P, type: T) {\n    this.data = data\n    this.type = type\n  }\n\n  isArray(): boolean {\n    return this.type === 'array'\n  }\n\n  // eslint-disable-next-line require-await\n  async get(): Promise<any> {\n    return this.data\n  }\n\n  [Symbol.asyncIterator](): Generator<Value, void, unknown> {\n    if (Array.isArray(this.data)) {\n      return (function* (data) {\n        for (const element of data) {\n          yield fromJS(element)\n        }\n      })(this.data)\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`)\n  }\n}\n\nexport const NULL_VALUE: NullValue = new StaticValue(null, 'null')\nexport const TRUE_VALUE: BooleanValue = new StaticValue(true, 'boolean')\nexport const FALSE_VALUE: BooleanValue = new StaticValue(false, 'boolean')\n\nexport class DateTime {\n  date: Date\n\n  constructor(date: Date) {\n    this.date = date\n  }\n\n  static parseToValue(str: string): Value {\n    const date = parseRFC3339(str)\n    if (date) {\n      return new StaticValue(new DateTime(date), 'datetime')\n    }\n    return NULL_VALUE\n  }\n\n  equals(other: DateTime): boolean {\n    return this.date.getTime() == other.date.getTime()\n  }\n\n  add(secs: number): DateTime {\n    const copy = new Date(this.date.getTime())\n    copy.setTime(copy.getTime() + secs * 1000)\n    return new DateTime(copy)\n  }\n\n  difference(other: DateTime): number {\n    return (this.date.getTime() - other.date.getTime()) / 1000\n  }\n\n  compareTo(other: DateTime): number {\n    return this.date.getTime() - other.date.getTime()\n  }\n\n  toString(): string {\n    return formatRFC3339(this.date)\n  }\n\n  toJSON(): string {\n    return this.toString()\n  }\n}\n\nexport function fromNumber(num: number): Value {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, 'number')\n  }\n  return NULL_VALUE\n}\n\nexport function fromString(str: string): Value {\n  return new StaticValue(str, 'string')\n}\n\nexport function fromDateTime(dt: DateTime): Value {\n  return new StaticValue(dt, 'datetime')\n}\n\nexport function fromPath(path: Path): Value {\n  return new StaticValue(path, 'path')\n}\n\nfunction isIterator(obj?: Iterator<any>) {\n  return obj && typeof obj.next === 'function'\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function fromJS(val: any): Value {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value)\n      }\n    })\n  } else if (val === null || val === undefined) {\n    return NULL_VALUE\n  }\n  return new StaticValue(val, getType(val)) as any\n}\n\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getType(data: any): GroqType {\n  if (data === null || typeof data === 'undefined') {\n    return 'null'\n  }\n  if (Array.isArray(data)) {\n    return 'array'\n  }\n  if (data instanceof Path) {\n    return 'path'\n  }\n  if (data instanceof DateTime) {\n    return 'datetime'\n  }\n  return typeof data as GroqType\n}\n", "import {Value} from '../values'\n\nexport function isEqual(a: Value, b: Value): boolean {\n  if (\n    (a.type === 'string' && b.type === 'string') ||\n    (a.type === 'boolean' && b.type === 'boolean') ||\n    (a.type === 'null' && b.type === 'null') ||\n    (a.type === 'number' && b.type === 'number')\n  ) {\n    return a.data === b.data\n  }\n\n  if (a.type === 'datetime' && b.type === 'datetime') {\n    return a.data.equals(b.data)\n  }\n\n  return false\n}\n", "import {Value} from '../values'\n\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g\nconst MAX_TERM_LENGTH = 1024\n\nexport type Token = string\n\nexport type Pattern = (tokens: Token[]) => boolean\n\nexport function matchText(tokens: Token[], patterns: Pattern[]): boolean {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false\n  }\n\n  return patterns.every((pattern) => pattern(tokens))\n}\n\nexport function matchTokenize(text: string): Token[] {\n  return text.replace(EDGE_CHARS, '').match(CHARS) || []\n}\n\nexport function matchAnalyzePattern(text: string): Pattern[] {\n  const termsRe = matchPatternRegex(text)\n  return termsRe.map((re) => (tokens: Token[]) => tokens.some((token) => re.test(token)))\n}\n\nexport function matchPatternRegex(text: string): RegExp[] {\n  const terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || []\n  return terms.map(\n    (term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*')}$`, 'i')\n  )\n}\n\nexport async function gatherText(value: Value, cb: (str: string) => void): Promise<boolean> {\n  if (value.type === 'string') {\n    cb(value.data)\n    return true\n  }\n\n  if (value.isArray()) {\n    let success = true\n    for await (const part of value) {\n      if (part.type === 'string') {\n        cb(part.data)\n      } else {\n        success = false\n      }\n    }\n    return success\n  }\n\n  return false\n}\n", "import {getType, GroqType} from '../values'\n\nconst TYPE_ORDER: {[key in GroqType]?: number} = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4,\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function partialCompare(a: any, b: any): null | number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  if (aType !== bType) {\n    return null\n  }\n\n  switch (aType) {\n    case 'number':\n    case 'boolean':\n      return a - b\n    case 'string':\n      if (a < b) return -1\n      if (a > b) return 1\n      return 0\n    case 'datetime':\n      return a.compareTo(b)\n    default:\n      return null\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function totalCompare(a: any, b: any): number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  const aTypeOrder = TYPE_ORDER[aType] || 100\n  const bTypeOrder = TYPE_ORDER[bType] || 100\n\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder\n  }\n\n  let result = partialCompare(a, b)\n  if (result === null) {\n    result = 0\n  }\n  return result\n}\n", "import {OpCall} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromString,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {isEqual} from './equality'\nimport {gatherText, matchAnalyzePattern, matchText, matchTokenize, Pattern, Token} from './matching'\nimport {partialCompare} from './ordering'\n\ntype GroqOperatorFn = (left: Value, right: Value) => Value | PromiseLike<Value>\n\nexport const operators: {[key in OpCall]: GroqOperatorFn} = {\n  '==': function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '!=': function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  '>': function gt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '>=': function gte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<': function lt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<=': function lte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  // eslint-disable-next-line func-name-matching\n  in: async function inop(left, right) {\n    if (right.type === 'path') {\n      if (left.type !== 'string') {\n        return NULL_VALUE\n      }\n\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE\n        }\n      }\n\n      return FALSE_VALUE\n    }\n\n    return NULL_VALUE\n  },\n\n  match: async function match(left, right) {\n    let tokens: Token[] = []\n    let patterns: Pattern[] = []\n\n    await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part))\n    })\n\n    const didSucceed = await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part))\n    })\n    if (!didSucceed) {\n      return FALSE_VALUE\n    }\n\n    const matched = matchText(tokens, patterns)\n\n    return matched ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '+': function plus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data + right.data)\n    }\n\n    if (left.type === 'string' && right.type === 'string') {\n      return fromString(left.data + right.data)\n    }\n\n    if (left.type === 'object' && right.type === 'object') {\n      return fromJS({...left.data, ...right.data})\n    }\n\n    if (left.type === 'array' && right.type === 'array') {\n      return fromJS(left.data.concat(right.data))\n    }\n\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val\n        }\n\n        for await (const val of right) {\n          yield val\n        }\n      })\n    }\n\n    return NULL_VALUE\n  },\n\n  '-': function minus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(-right.data))\n    }\n\n    if (left.type === 'datetime' && right.type === 'datetime') {\n      return fromNumber(left.data.difference(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data - right.data)\n    }\n\n    return NULL_VALUE\n  },\n\n  '*': numericOperator((a, b) => a * b),\n  '/': numericOperator((a, b) => a / b),\n  '%': numericOperator((a, b) => a % b),\n  '**': numericOperator((a, b) => Math.pow(a, b)),\n}\n\nfunction numericOperator(impl: (a: number, b: number) => number): GroqOperatorFn {\n  return function (left, right) {\n    if (left.type === 'number' && right.type === 'number') {\n      const result = impl(left.data, right.data)\n      return fromNumber(result)\n    }\n\n    return NULL_VALUE\n  }\n}\n", "import {Value} from '../values'\nimport {Context} from './types'\n\nexport class Scope {\n  public params: Record<string, unknown>\n  public source: Value\n  public value: Value\n  public parent: Scope | null\n  public context: Context\n  public isHidden = false\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(\n    params: Record<string, unknown>,\n    source: Value,\n    value: Value,\n    context: Context,\n    parent: Scope | null\n  ) {\n    this.params = params\n    this.source = source\n    this.value = value\n    this.context = context\n    this.parent = parent\n  }\n\n  createNested(value: Value): Scope {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent)\n    }\n    return new Scope(this.params, this.source, value, this.context, this)\n  }\n\n  createHidden(value: Value): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n", "import {ExprNode, FuncCallNode, PipeFuncCallNode} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {operators} from './operators'\nimport {partialCompare} from './ordering'\nimport {Scope} from './scope'\nimport {EvaluateOptions, Executor} from './types'\n\nexport function evaluate(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor = evaluate\n): Value | PromiseLike<Value> {\n  const func = EXECUTORS[node.type]\n  return func(node as any, scope, execute)\n}\n\ntype NarrowNode<T, N> = T extends {type: N} ? T : never\n\ntype ExecutorMap = {\n  [key in ExprNode['type']]: (\n    node: NarrowNode<ExprNode, key>,\n    scope: Scope,\n    exec: Executor\n  ) => Value | PromiseLike<Value>\n}\n\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(\n  value: Value | PromiseLike<Value>,\n  cb: (val: Value) => Value\n): Value | PromiseLike<Value> {\n  if ('then' in value) {\n    return value.then(cb)\n  }\n\n  return cb(value)\n}\n\nconst EXECUTORS: ExecutorMap = {\n  This(_, scope) {\n    return scope.value\n  },\n\n  Selector() {\n    // These should be evaluated separely using a different evaluator.\n    // At the mooment we haven't implemented this.\n    throw new Error('Selectors can not be evaluated')\n  },\n\n  Everything(_, scope) {\n    return scope.source\n  },\n\n  Parameter({name}, scope) {\n    return fromJS(scope.params[name])\n  },\n\n  Context({key}, scope) {\n    if (key === 'before' || key === 'after') {\n      const value = scope.context[key]\n      return value || NULL_VALUE\n    }\n    throw new Error(`unknown context key: ${key}`)\n  },\n\n  Parent({n}, scope) {\n    let current = scope\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE\n      }\n\n      current = current.parent\n    }\n    return current.value\n  },\n\n  OpCall({op, left, right}, scope, execute) {\n    const func = operators[op]\n    if (!func) {\n      throw new Error(`Unknown operator: ${op}`)\n    }\n    const leftValue = execute(left, scope)\n    const rightValue = execute(right, scope)\n\n    // Avoid uneccesary promises\n    // This is required for constant evaluation to work correctly.\n    if ('then' in leftValue || 'then' in rightValue) {\n      return (async () => func(await leftValue, await rightValue))()\n    }\n\n    return func(leftValue, rightValue)\n  },\n\n  async Select({alternatives, fallback}, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope)\n      if (altCond.type === 'boolean' && altCond.data === true) {\n        return execute(alt.value, scope)\n      }\n    }\n\n    if (fallback) {\n      return execute(fallback, scope)\n    }\n\n    return NULL_VALUE\n  },\n\n  async InRange({base, left, right, isInclusive}, scope, execute) {\n    const value = await execute(base, scope)\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    const leftCmp = partialCompare(await value.get(), await leftValue.get())\n    if (leftCmp === null) {\n      return NULL_VALUE\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get())\n    if (rightCmp === null) {\n      return NULL_VALUE\n    }\n\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  async Filter({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem)\n        const exprValue = await execute(expr, newScope)\n        if (exprValue.type === 'boolean' && exprValue.data === true) {\n          yield elem\n        }\n      }\n    })\n  },\n\n  async Projection({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (baseValue.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const newScope = scope.createNested(baseValue)\n    return execute(expr, newScope)\n  },\n\n  FuncCall({func, args}: FuncCallNode, scope: Scope, execute) {\n    return func(args, scope, execute)\n  },\n\n  async PipeFuncCall({func, base, args}: PipeFuncCallNode, scope: Scope, execute) {\n    const baseValue = await execute(base, scope)\n    return func(baseValue, args, scope, execute)\n  },\n\n  async AccessAttribute({base, name}, scope, execute) {\n    let value = scope.value\n    if (base) {\n      value = await execute(base, scope)\n    }\n    if (value.type === 'object') {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name])\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  async AccessElement({base, index}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    const data = await baseValue.get()\n    const finalIndex = index < 0 ? index + data.length : index\n    return fromJS(data[finalIndex])\n  },\n\n  async Slice({base, left, right, isInclusive}, scope, execute) {\n    const baseValue = await execute(base, scope)\n\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    // OPT: Here we can optimize when either indices are >= 0\n    const array = (await baseValue.get()) as any[]\n\n    let leftIdx = left\n    let rightIdx = right\n\n    // Handle negative index\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx\n    }\n\n    // Convert from inclusive to exclusive index\n    if (isInclusive) {\n      rightIdx++\n    }\n\n    if (leftIdx < 0) {\n      leftIdx = 0\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0\n    }\n\n    // Note: At this point the indices might point out-of-bound, but\n    // .slice handles this correctly.\n\n    return fromJS(array.slice(leftIdx, rightIdx))\n  },\n\n  async Deref({base}, scope, execute) {\n    const value = await execute(base, scope)\n\n    if (!scope.source.isArray()) {\n      return NULL_VALUE\n    }\n\n    if (value.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const id = value.data._ref\n    if (typeof id !== 'string') {\n      return NULL_VALUE\n    }\n\n    for await (const doc of scope.source) {\n      if (doc.type === 'object' && id === doc.data._id) {\n        return doc\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  Value({value}) {\n    return fromJS(value)\n  },\n\n  Group({base}, scope, execute) {\n    return execute(base, scope)\n  },\n\n  async Object({attributes}, scope, execute) {\n    const result: {[key: string]: any} = {}\n    for (const attr of attributes) {\n      const attrType = attr.type\n      switch (attr.type) {\n        case 'ObjectAttributeValue': {\n          const value = await execute(attr.value, scope)\n          result[attr.name] = await value.get()\n          break\n        }\n\n        case 'ObjectConditionalSplat': {\n          const cond = await execute(attr.condition, scope)\n          if (cond.type !== 'boolean' || cond.data === false) {\n            continue\n          }\n\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        case 'ObjectSplat': {\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        default:\n          throw new Error(`Unknown node type: ${attrType}`)\n      }\n    }\n    return fromJS(result)\n  },\n\n  Array({elements}, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope)\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v\n            }\n          }\n        } else {\n          yield value\n        }\n      }\n    })\n  },\n\n  Tuple() {\n    throw new Error('tuples can not be evaluated')\n  },\n\n  async Or({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n\n  async And({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return TRUE_VALUE\n  },\n\n  async Not({base}, scope, execute) {\n    const value = await execute(base, scope)\n    if (value.type !== 'boolean') {\n      return NULL_VALUE\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  Neg({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(-value.data)\n    })\n  },\n\n  Pos({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(value.data)\n    })\n  },\n\n  Asc() {\n    return NULL_VALUE\n  },\n\n  Desc() {\n    return NULL_VALUE\n  },\n\n  async ArrayCoerce({base}, scope, execute) {\n    const value = await execute(base, scope)\n    return value.isArray() ? value : NULL_VALUE\n  },\n\n  async Map({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        yield await execute(expr, newScope)\n      }\n    })\n  },\n\n  async FlatMap({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        const innerValue = await execute(expr, newScope)\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner\n          }\n        } else {\n          yield innerValue\n        }\n      }\n    })\n  },\n}\n\n/**\n * Evaluates a query.\n */\nexport function evaluateQuery(\n  tree: ExprNode,\n  options: EvaluateOptions = {}\n): Value | PromiseLike<Value> {\n  const root = fromJS(options.root)\n  const dataset = fromJS(options.dataset)\n  const params: {[key: string]: any} = {...options.params}\n\n  const scope = new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || new Date(),\n      identity: options.identity === undefined ? 'me' : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n    },\n    null\n  )\n  return evaluate(tree, scope)\n}\n", "import {ExprNode} from '../nodeTypes'\nimport {NULL_VALUE, Value} from '../values'\nimport {evaluate} from './evaluate'\nimport {Scope} from './scope'\n\nfunction canConstantEvaluate(node: ExprNode): boolean {\n  switch (node.type) {\n    case 'Group':\n    case 'Value':\n    case 'Parameter':\n      return true\n    case 'Pos':\n    case 'Neg':\n      return canConstantEvaluate(node.base)\n    case 'OpCall':\n      switch (node.op) {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case '**':\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right)\n        default:\n          return false\n      }\n    default:\n      return false\n  }\n}\n\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  {timestamp: new Date(0), identity: 'me', before: null, after: null},\n  null\n)\n\nexport function tryConstantEvaluate(node: ExprNode): Value | null {\n  if (!canConstantEvaluate(node)) {\n    return null\n  }\n\n  return constantEvaluate(node)\n}\n\nfunction constantEvaluate(node: ExprNode): Value {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate)\n  if ('then' in value) {\n    throw new Error('BUG: constant evaluate should never return a promise')\n  }\n  return value\n}\n", "import {Value} from '../values'\n\nexport async function portableTextContent(value: Value): Promise<string | null> {\n  if (value.type === 'object') {\n    return blockText(value.data)\n  } else if (value.isArray()) {\n    const texts = await arrayText(value)\n    if (texts.length > 0) {\n      return texts.join('\\n\\n')\n    }\n  }\n\n  return null\n}\n\nasync function arrayText(value: Value, result: string[] = []): Promise<string[]> {\n  for await (const block of value) {\n    if (block.type === 'object') {\n      const text = blockText(block.data)\n      if (text !== null) result.push(text)\n    } else if (block.isArray()) {\n      await arrayText(block, result)\n    }\n  }\n\n  return result\n}\n\nfunction blockText(obj: Record<string, unknown>): string | null {\n  if (typeof obj._type !== 'string') return null\n  const children = obj.children\n  if (!Array.isArray(children)) return null\n\n  let result = ''\n  for (const child of children) {\n    if (\n      child &&\n      typeof child === 'object' &&\n      typeof child._type === 'string' &&\n      child._type === 'span' &&\n      typeof child.text === 'string'\n    ) {\n      result += child.text\n    }\n  }\n  return result\n}\n", "import {ExprNode} from '../nodeTypes'\nimport {gatherText, matchPatternRegex, matchTokenize, Token} from './matching'\nimport {Scope} from './scope'\nimport {Executor} from './types'\n\n// BM25 similarity constants\nconst BM25k = 1.2\n\nexport async function evaluateScore(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor\n): Promise<number> {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScore(node.left, node.right, scope, execute)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = await evaluateScore(node.args[0], scope, execute)\n    const boost = await execute(node.args[1], scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = await execute(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nasync function evaluateMatchScore(\n  left: ExprNode,\n  right: ExprNode,\n  scope: Scope,\n  execute: Executor\n): Promise<number> {\n  const text = await execute(left, scope)\n  const pattern = await execute(right, scope)\n\n  let tokens: Token[] = []\n  let terms: RegExp[] = []\n\n  await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part))\n  })\n\n  const didSucceed = await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part))\n  })\n\n  if (!didSucceed) {\n    return 0\n  }\n\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0\n  }\n\n  let score = 0\n\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0)\n    score += (freq * (BM25k + 1)) / (freq + BM25k)\n  }\n\n  return score\n}\n", "import type {ExprNode} from '../nodeTypes'\nimport {\n  DateTime,\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  fromPath,\n  fromString,\n  getType,\n  NULL_VALUE,\n  Path,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {totalCompare} from './ordering'\nimport {portableTextContent} from './pt'\nimport {Scope} from './scope'\nimport {evaluateScore} from './scoring'\nimport {Executor} from './types'\n\nfunction hasReference(value: any, pathSet: Set<string>): boolean {\n  switch (getType(value)) {\n    case 'array':\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    case 'object':\n      if (value._ref) {\n        return pathSet.has(value._ref)\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    default:\n  }\n  return false\n}\n\nfunction countUTF8(str: string): number {\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i)\n    if (code >= 0xd800 && code <= 0xdbff) {\n      // High surrogate. Don't count this.\n      // By only counting the low surrogate we will correctly\n      // count the number of UTF-8 code points.\n      continue\n    }\n    count++\n  }\n  return count\n}\n\nexport type GroqFunctionArg = ExprNode\ntype WithOptions<T> = T & {\n  arity?: GroqFunctionArity\n  mode?: 'normal' | 'delta'\n}\n\nexport type GroqFunctionArity = number | ((count: number) => boolean)\n\nexport type GroqFunction = (\n  args: GroqFunctionArg[],\n  scope: Scope,\n  execute: Executor\n) => PromiseLike<Value>\n\nexport type FunctionSet = Record<string, WithOptions<GroqFunction> | undefined>\n\nexport type NamespaceSet = Record<string, FunctionSet | undefined>\n\n// underscored to not collide with environments like jest that give variables named `global` special treatment\nconst _global: FunctionSet = {}\n\n// eslint-disable-next-line require-await\n_global.anywhere = async function anywhere() {\n  throw new Error('not implemented')\n}\n\n_global.anywhere.arity = 1\n\n_global.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope)\n    if (value.type !== 'null') {\n      return value\n    }\n  }\n  return NULL_VALUE\n}\n\n_global.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (!inner.isArray()) {\n    return NULL_VALUE\n  }\n\n  let num = 0\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _ of inner) {\n    num++\n  }\n  return fromNumber(num)\n}\n_global.count.arity = 1\n\n_global.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope)\n  if (val.type === 'datetime') {\n    return val\n  }\n  if (val.type !== 'string') {\n    return NULL_VALUE\n  }\n  return DateTime.parseToValue(val.data)\n}\n_global.dateTime.arity = 1\n\n_global.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  return inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE\n}\n_global.defined.arity = 1\n\n// eslint-disable-next-line require-await\n_global.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity)\n}\n_global.identity.arity = 0\n\n_global.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n\n  if (inner.type === 'string') {\n    return fromNumber(countUTF8(inner.data))\n  }\n\n  if (inner.isArray()) {\n    let num = 0\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for await (const _ of inner) {\n      num++\n    }\n    return fromNumber(num)\n  }\n\n  return NULL_VALUE\n}\n_global.length.arity = 1\n\n_global.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (inner.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromPath(new Path(inner.data))\n}\n_global.path.arity = 1\n\n_global.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  switch (value.type) {\n    case 'number':\n    case 'string':\n    case 'boolean':\n    case 'datetime':\n      return fromString(`${value.data}`)\n    default:\n      return NULL_VALUE\n  }\n}\n_global.string.arity = 1\n\n_global.references = async function references(args, scope, execute) {\n  const pathSet = new Set<string>()\n  for (const arg of args) {\n    const path = await execute(arg, scope)\n    if (path.type === 'string') {\n      pathSet.add(path.data)\n    } else if (path.isArray()) {\n      for await (const elem of path) {\n        if (elem.type === 'string') {\n          pathSet.add(elem.data)\n        }\n      }\n    }\n  }\n\n  if (pathSet.size === 0) {\n    return FALSE_VALUE\n  }\n\n  const scopeValue = await scope.value.get()\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE\n}\n_global.references.arity = (c) => c >= 1\n\n_global.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (value.type !== 'number') {\n    return NULL_VALUE\n  }\n\n  const num = value.data\n  let prec = 0\n\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope)\n    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE\n    }\n    prec = precValue.data\n  }\n\n  if (prec === 0) {\n    if (num < 0) {\n      // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n      // The behavior we're interested in is to \"round half away from zero\".\n      return fromNumber(-Math.round(-num))\n    }\n    return fromNumber(Math.round(num))\n  }\n  return fromNumber(Number(num.toFixed(prec)))\n}\n_global.round.arity = (count) => count >= 1 && count <= 2\n\n// eslint-disable-next-line require-await\n_global.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString())\n}\n_global.now.arity = 0\n\n// eslint-disable-next-line require-await\n_global.boost = async function boost() {\n  // This should be handled by the scoring function.\n  throw new Error('unexpected boost call')\n}\n\n_global.boost.arity = 2\n\nconst string: FunctionSet = {}\n\nstring.lower = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toLowerCase())\n}\nstring.lower.arity = 1\n\nstring.upper = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toUpperCase())\n}\nstring.upper.arity = 1\n\nstring.split = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  if (str.data.length === 0) {\n    return fromJS([])\n  }\n  if (sep.data.length === 0) {\n    // This uses a Unicode codepoint splitting algorithm\n    return fromJS(Array.from(str.data))\n  }\n  return fromJS(str.data.split(sep.data))\n}\nstring.split.arity = 2\n\n_global.lower = string.lower\n_global.upper = string.upper\n\nstring.startsWith = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  const prefix = await execute(args[1], scope)\n  if (prefix.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n}\nstring.startsWith.arity = 2\n\nconst array: FunctionSet = {}\n\narray.join = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n  let buf = ''\n  let needSep = false\n  for await (const elem of arr) {\n    if (needSep) {\n      buf += sep.data\n    }\n    switch (elem.type) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        buf += `${elem.data}`\n        break\n      default:\n        return NULL_VALUE\n    }\n    needSep = true\n  }\n  return fromJS(buf)\n}\narray.join.arity = 2\n\narray.compact = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    for await (const elem of arr) {\n      if (elem.type !== 'null') {\n        yield elem\n      }\n    }\n  })\n}\narray.compact.arity = 1\n\narray.unique = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (!value.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    const added = new Set()\n    for await (const iter of value) {\n      switch (iter.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'datetime':\n          if (!added.has(iter.data)) {\n            added.add(iter.data)\n            yield iter\n          }\n          break\n        default:\n          yield iter\n      }\n    }\n  })\n}\narray.unique.arity = 1\n\nconst pt: FunctionSet = {}\npt.text = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  const text = await portableTextContent(value)\n\n  if (text === null) {\n    return NULL_VALUE\n  }\n\n  return fromString(text)\n}\n\npt.text.arity = 1\n\nconst sanity: FunctionSet = {}\n// eslint-disable-next-line require-await\nsanity.projectId = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId)\n  }\n\n  return NULL_VALUE\n}\n// eslint-disable-next-line require-await\nsanity.dataset = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset)\n  }\n\n  return NULL_VALUE\n}\n\nexport type GroqPipeFunction = (\n  base: Value,\n  args: ExprNode[],\n  scope: Scope,\n  execute: Executor\n) => PromiseLike<Value>\n\nexport const pipeFunctions: {[key: string]: WithOptions<GroqPipeFunction>} = {}\n\npipeFunctions.order = async function order(base, args, scope, execute) {\n  // eslint-disable-next-line max-len\n  // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n  await true\n\n  if (!base.isArray()) {\n    return NULL_VALUE\n  }\n\n  const mappers = []\n  const directions: string[] = []\n  let n = 0\n\n  for (let mapper of args) {\n    let direction = 'asc'\n\n    if (mapper.type === 'Desc') {\n      direction = 'desc'\n      mapper = mapper.base\n    } else if (mapper.type === 'Asc') {\n      mapper = mapper.base\n    }\n\n    mappers.push(mapper)\n    directions.push(direction)\n    n++\n  }\n\n  const aux = []\n  let idx = 0\n\n  for await (const value of base) {\n    const newScope = scope.createNested(value)\n    const tuple = [await value.get(), idx]\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope)\n      tuple.push(await result.get())\n    }\n    aux.push(tuple)\n    idx++\n  }\n\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2])\n      if (directions[i] === 'desc') {\n        c = -c\n      }\n      if (c !== 0) {\n        return c\n      }\n    }\n    // Fallback to sorting on the original index for stable sorting.\n    return aTuple[1] - bTuple[1]\n  })\n\n  return fromJS(aux.map((v) => v[0]))\n}\npipeFunctions.order.arity = (count) => count >= 1\n\n// eslint-disable-next-line require-await\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray()) return NULL_VALUE\n\n  // Anything that isn't an object should be sorted first.\n  const unknown: Array<any> = []\n  const scored: Array<ObjectWithScore> = []\n\n  for await (const value of base) {\n    if (value.type !== 'object') {\n      unknown.push(await value.get())\n      continue\n    }\n\n    const newScope = scope.createNested(value)\n    let valueScore = typeof value.data._score === 'number' ? value.data._score : 0\n\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute)\n    }\n\n    const newObject = Object.assign({}, value.data, {_score: valueScore})\n    scored.push(newObject)\n  }\n\n  scored.sort((a, b) => b._score - a._score)\n  return fromJS(scored)\n}\n\npipeFunctions.score.arity = (count) => count >= 1\n\ntype ObjectWithScore = Record<string, unknown> & {_score: number}\n\nconst delta: FunctionSet = {}\n// eslint-disable-next-line require-await\ndelta.operation = async function (args, scope) {\n  const hasBefore = scope.context.before !== null\n  const hasAfter = scope.context.after !== null\n\n  if (hasBefore && hasAfter) {\n    return fromString('update')\n  }\n\n  if (hasAfter) {\n    return fromString('create')\n  }\n\n  if (hasBefore) {\n    return fromString('delete')\n  }\n\n  return NULL_VALUE\n}\n\ndelta.changedAny = () => {\n  throw new Error('not implemented')\n}\ndelta.changedAny.arity = 1\ndelta.changedAny.mode = 'delta'\n\ndelta.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndelta.changedOnly.arity = 1\ndelta.changedOnly.mode = 'delta'\n\nconst diff: FunctionSet = {}\ndiff.changedAny = () => {\n  throw new Error('not implemented')\n}\ndiff.changedAny.arity = 3\n\ndiff.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndiff.changedOnly.arity = 3\n\nconst math: FunctionSet = {}\nmath.min = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data < n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.min.arity = 1\n\nmath.max = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data > n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.max.arity = 1\n\nmath.sum = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n  }\n  return fromJS(n)\n}\nmath.sum.arity = 1\n\nmath.avg = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  let c = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n    c++\n  }\n  if (c === 0) {\n    return NULL_VALUE\n  }\n  return fromJS(n / c)\n}\nmath.avg.arity = 1\n\nexport const namespaces: NamespaceSet = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n}\n", "import {ParseOptions} from './types'\n\nexport type MarkName =\n  | 'add'\n  | 'and'\n  | 'arr_expr'\n  | 'array_end'\n  | 'array_splat'\n  | 'array'\n  | 'asc'\n  | 'attr_ident'\n  | 'comp'\n  | 'dblparent'\n  | 'deref_field'\n  | 'deref'\n  | 'desc'\n  | 'div'\n  | 'exc_range'\n  | 'filter'\n  | 'float'\n  | 'func_args_end'\n  | 'func_call'\n  | 'ident'\n  | 'inc_range'\n  | 'integer'\n  | 'mod'\n  | 'mul'\n  | 'neg'\n  | 'not'\n  | 'object_end'\n  | 'object_expr'\n  | 'object_pair'\n  | 'object_splat_this'\n  | 'object_splat'\n  | 'object'\n  | 'or'\n  | 'pair'\n  | 'param'\n  | 'paren'\n  | 'parent'\n  | 'pipecall'\n  | 'pos'\n  | 'pow'\n  | 'project'\n  | 'sci'\n  | 'star'\n  | 'str_begin'\n  | 'sub'\n  | 'this'\n\nexport interface Mark {\n  name: string\n  position: number\n}\n\nexport type MarkVisitor<T> = Record<string, MarkVisitorFunc<T>>\nexport type MarkVisitorFunc<T> = (p: MarkProcessor, mark: Mark) => T\n\nexport class MarkProcessor {\n  private string: string\n  private marks: Mark[]\n  private index: number\n  parseOptions: ParseOptions\n  allowBoost = false\n\n  constructor(string: string, marks: Mark[], parseOptions: ParseOptions) {\n    this.string = string\n    this.marks = marks\n    this.index = 0\n    this.parseOptions = parseOptions\n  }\n\n  hasMark(pos = 0): boolean {\n    return this.index + pos < this.marks.length\n  }\n\n  getMark(pos = 0): Mark {\n    return this.marks[this.index + pos]\n  }\n\n  shift(): void {\n    this.index += 1\n  }\n\n  process<T>(visitor: MarkVisitor<T>): T {\n    const mark = this.marks[this.index]\n    this.shift()\n    const func = visitor[mark.name]\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`)\n    }\n    return func.call(visitor, this, mark)\n  }\n\n  processString(): string {\n    this.shift()\n    return this.processStringEnd()\n  }\n\n  processStringEnd(): string {\n    const prev = this.marks[this.index - 1]\n    const curr = this.marks[this.index]\n    this.shift()\n    return this.string.slice(prev.position, curr.position)\n  }\n\n  slice(len: number): string {\n    const pos = this.marks[this.index].position\n    return this.string.slice(pos, pos + len)\n  }\n}\n", "'use strict'\n\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/\nconst NUM = /^\\d+/\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1\nconst PREC_OR = 2\nconst PREC_AND = 3\nconst PREC_COMP = 4\nconst PREC_ORDER = 4\nconst PREC_ADD = 6\nconst PREC_SUB = 6\nconst PREC_MUL = 7\nconst PREC_DIV = 7\nconst PREC_MOD = 7\nconst PREC_POW = 8\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10\nconst PREC_NOT = 10\nconst PREC_NEG = 8\n\nfunction parse(str) {\n  let pos = 0\n  pos = skipWS(str, pos)\n  let result = parseExpr(str, pos, 0)\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position)\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position\n  delete result.failPosition\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos\n  let token = str[pos]\n  let marks\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0)\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position)\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks)\n          pos = skipWS(str, pos + 1)\n          while (true) {\n            rhs = parseExpr(str, pos, 0)\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position)\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1)\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++\n          marks.push({name: 'tuple_end', position: pos})\n          break\n        }\n        case ')': {\n          pos++\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks)\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}]\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos})\n            pos = skipWS(str, pos + 3)\n          }\n\n          let res = parseExpr(str, pos, 0)\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks)\n          pos = res.position\n          pos = skipWS(str, pos)\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1)\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++\n        marks.push({name: 'array_end', position: pos})\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '^': {\n      pos++\n      marks = []\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos})\n        pos += 2\n      }\n      marks.push({name: 'parent', position: startPos})\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}]\n      pos++\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}]\n      pos++\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT)\n      if (identLen) {\n        pos += 1 + identLen\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ]\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM)\n      if (numLen) {\n        pos += numLen\n        let name = 'integer'\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM)\n          if (fracLen) {\n            name = 'float'\n            pos += 1 + fracLen\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci'\n          pos++\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++\n          }\n          let expLen = parseRegex(str, pos, NUM)\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ]\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT)\n      if (identLen) {\n        pos += identLen\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos)\n            if (result.type === 'error') return result\n            marks = result.marks\n            pos = result.position\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ]\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12\n  let trav\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos)\n    if (innerPos === str.length) {\n      pos = innerPos\n      break\n    }\n\n    trav = parseTraversal(str, innerPos)\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos})\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks)\n        pos = trav.position\n        trav = parseTraversal(str, skipWS(str, pos))\n      }\n      marks.push({name: 'traversal_end', position: pos})\n      continue\n    }\n\n    let token = str[innerPos]\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1]\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR)\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks)\n            marks.unshift({name: 'pair', position: startPos})\n            pos = rhs.position\n            lhsLevel = PREC_PAIR\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = PREC_COMP\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'add', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_ADD\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'sub', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_SUB\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'pow', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_POW\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mul', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MUL\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'div', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_DIV\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mod', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MOD\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1\n        if (str[nextPos] === '=') {\n          nextPos++\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'or', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_OR\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1)\n          let identLen = parseRegex(str, identPos, IDENT)\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos)\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks)\n            marks.unshift({name: 'pipecall', position: startPos})\n            pos = result.position\n            lhsLevel = 11\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'and', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_AND\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos})\n        pos = innerPos + 4\n        lhsLevel = PREC_ORDER\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos})\n        pos = innerPos + 3\n        lhsLevel = PREC_ORDER\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT)\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2)\n\n            let isGroup = false\n\n            if (str[pos] === '(') {\n              isGroup = true\n              pos = skipWS(str, pos + 1)\n            }\n\n            let rangePos = pos\n            let result = parseExpr(str, pos, PREC_COMP + 1)\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position)\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range'\n              if (str[pos + 2] === '.') {\n                type = 'exc_range'\n                pos = skipWS(str, pos + 3)\n              } else {\n                pos = skipWS(str, pos + 2)\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1)\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos})\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks)\n              pos = rhs.position\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos})\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n              marks = marks.concat(result.marks)\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos)\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++\n            }\n\n            lhsLevel = PREC_COMP\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = 4\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1)\n      let identStart = pos\n      let identLen = parseRegex(str, pos, IDENT)\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}]\n      pos += 2\n\n      let identPos = skipWS(str, pos)\n      let identLen = parseRegex(str, identPos, IDENT)\n      if (identLen) {\n        pos = identPos + identLen\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos}\n        )\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position)\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range'\n        if (str[pos + 2] === '.') {\n          type = 'exc_range'\n          pos += 3\n        } else {\n          pos += 2\n        }\n\n        pos = skipWS(str, pos)\n        let rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1)\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos)\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos})\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos})\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = []\n\n  marks.push({name: 'func_call', position: startPos})\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos})\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 2)\n    let nameLen = parseRegex(str, pos, IDENT)\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen})\n    pos = skipWS(str, pos + nameLen)\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++\n    // Consume any whitespace in front of the function argument.\n    pos = skipWS(str, pos)\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 1)\n  }\n\n  let lastPos = pos\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks)\n      lastPos = result.position\n      pos = skipWS(str, result.position)\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1)\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos})\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}]\n  pos = skipWS(str, pos + 1)\n\n  loop: while (str[pos] !== '}') {\n    let pairPos = pos\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3)\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0)\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos})\n        marks = marks.concat(expr.marks)\n        pos = expr.position\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos})\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0)\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position)\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0)\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos})\n        marks = marks.concat(expr.marks, value.marks)\n        pos = value.position\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks)\n        pos = expr.position\n      }\n    }\n    pos = skipWS(str, pos)\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1)\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++\n  marks.push({name: 'object_end', position: pos})\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos]\n  pos = pos + 1\n  const marks = [{name: 'str', position: pos}]\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos})\n        pos++\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos})\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3})\n            pos = str.indexOf('}', pos + 3)\n            marks.push({name: 'unicode_hex_end', position: pos})\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2})\n            marks.push({name: 'unicode_hex_end', position: pos + 6})\n            pos += 5\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1})\n          pos += 1\n        }\n        marks.push({name: 'str_start', position: pos + 1})\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0] : null\n}\n\nexport {parse}\n", "/* eslint-disable camelcase */\nimport {ExprNode} from './nodeTypes'\n\nexport type Traversal = (base: ExprNode) => ExprNode\n\n/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a: Traversal, b: Traversal): Traversal {\n  return (base: ExprNode) => b(a(base))\n}\n\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'Map', base, expr: inner({type: 'This'})})\n}\n\nfunction flatMap(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'FlatMap', base, expr: inner({type: 'This'})})\n}\n\nexport type TraversalResult = {\n  type: 'a-a' | 'a-b' | 'b-a' | 'b-b'\n  build: Traversal\n}\n\nexport function traverseArray(build: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-a',\n      build: build,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(build, right.build),\n      }\n\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(build, right.build),\n      }\n\n    case 'b-b':\n      return {\n        type: 'a-a',\n        build: join(build, map(right.build)),\n      }\n\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(build, flatMap(right.build)),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traversePlain(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseElement(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'a-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseProjection(\n  mapper: Traversal,\n  right: TraversalResult | null\n): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(map(mapper), right.build),\n      }\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(map(mapper), right.build),\n      }\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n", "/* eslint-disable camelcase */\nimport {tryConstantEvaluate} from './evaluator'\nimport {GroqFunctionArity, namespaces, pipeFunctions} from './evaluator/functions'\nimport {Mark, MarkProcessor, MarkVisitor} from './markProcessor'\nimport {\n  ArrayElementNode,\n  ExprNode,\n  FuncCallNode,\n  ObjectAttributeNode,\n  ObjectSplatNode,\n  OpCall,\n  ParentNode,\n  SelectNode,\n} from './nodeTypes'\nimport {parse as rawParse} from './rawParser'\nimport {\n  TraversalResult,\n  traverseArray,\n  traverseElement,\n  traversePlain,\n  traverseProjection,\n} from './traversal'\nimport {ParseOptions} from './types'\n\ntype EscapeSequences = \"'\" | '\"' | '\\\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't'\n\nconst ESCAPE_SEQUENCE: {[key in EscapeSequences]: string} = {\n  \"'\": \"'\",\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n}\n\nfunction expandHex(str: string): string {\n  const charCode = parseInt(str, 16)\n  return String.fromCharCode(charCode)\n}\n\nclass GroqQueryError extends Error {\n  public name = 'GroqQueryError'\n}\n\nconst EXPR_BUILDER: MarkVisitor<ExprNode> = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER)\n    return {\n      type: 'Group',\n      base: inner,\n    }\n  },\n\n  everything() {\n    return {type: 'Everything'}\n  },\n\n  this() {\n    return {type: 'This'}\n  },\n\n  parent() {\n    return {\n      type: 'Parent',\n      n: 1,\n    }\n  },\n\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER) as ParentNode\n    return {\n      type: 'Parent',\n      n: next.n + 1,\n    }\n  },\n\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER)\n    const traversalList: Array<(right: TraversalResult | null) => TraversalResult> = []\n    while (p.getMark().name !== 'traversal_end') {\n      traversalList.push(p.process(TRAVERSE_BUILDER))\n    }\n    p.shift()\n    let traversal: TraversalResult | null = null\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal)\n    }\n    if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n      traversal = traverseArray((val) => val, traversal)\n    }\n    if (traversal === null) throw new Error('BUG: unexpected empty traversal')\n    return traversal.build(base)\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n\n    if (name === 'null') {\n      return {type: 'Value', value: null}\n    }\n    if (name === 'true') {\n      return {type: 'Value', value: true}\n    }\n    if (name === 'false') {\n      return {type: 'Value', value: false}\n    }\n\n    return {\n      type: 'AccessAttribute',\n      name,\n    }\n  },\n\n  neg(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Neg',\n      base,\n    }\n  },\n\n  pos(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Pos',\n      base,\n    }\n  },\n\n  add(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '+',\n      left,\n      right,\n    }\n  },\n\n  sub(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '-',\n      left,\n      right,\n    }\n  },\n\n  mul(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '*',\n      left,\n      right,\n    }\n  },\n\n  div(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '/',\n      left,\n      right,\n    }\n  },\n\n  mod(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '%',\n      left,\n      right,\n    }\n  },\n\n  pow(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '**',\n      left,\n      right,\n    }\n  },\n\n  comp(p) {\n    const left = p.process(EXPR_BUILDER)\n    const op = p.processString() as OpCall\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: op,\n      left: left,\n      right: right,\n    }\n  },\n\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER)\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'InRange',\n      base,\n      left,\n      right,\n      isInclusive,\n    }\n  },\n\n  str(p) {\n    let value = ''\n    // eslint-disable-next-line no-labels\n    loop: while (p.hasMark()) {\n      const mark = p.getMark()\n      switch (mark.name) {\n        case 'str_end':\n          value += p.processStringEnd()\n          // eslint-disable-next-line no-labels\n          break loop\n        case 'str_pause':\n          value += p.processStringEnd()\n          break\n        case 'str_start':\n          p.shift()\n          break\n        case 'single_escape': {\n          const char = p.slice(1)\n          p.shift()\n          value += ESCAPE_SEQUENCE[char as EscapeSequences]\n          break\n        }\n        case 'unicode_hex':\n          p.shift()\n          value += expandHex(p.processStringEnd())\n          break\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`)\n      }\n    }\n    return {type: 'Value', value}\n  },\n\n  integer(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  float(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  sci(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  object(p) {\n    const attributes: ObjectAttributeNode[] = []\n    while (p.getMark().name !== 'object_end') {\n      attributes.push(p.process(OBJECT_BUILDER))\n    }\n    p.shift()\n\n    return {\n      type: 'Object',\n      attributes,\n    }\n  },\n\n  array(p) {\n    const elements: ArrayElementNode[] = []\n    while (p.getMark().name !== 'array_end') {\n      let isSplat = false\n      if (p.getMark().name === 'array_splat') {\n        isSplat = true\n        p.shift()\n      }\n      const value = p.process(EXPR_BUILDER)\n      elements.push({\n        type: 'ArrayElement',\n        value,\n        isSplat,\n      })\n    }\n    p.shift()\n    return {\n      type: 'Array',\n      elements: elements,\n    }\n  },\n\n  tuple(p) {\n    const members: ExprNode[] = []\n    while (p.getMark().name !== 'tuple_end') {\n      members.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n    return {\n      type: 'Tuple',\n      members,\n    }\n  },\n\n  func_call(p) {\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n\n    const name = p.processString()\n    if (namespace === 'global' && name === 'select') {\n      const result: SelectNode = {\n        type: 'Select',\n        alternatives: [],\n      }\n\n      while (p.getMark().name !== 'func_args_end') {\n        if (p.getMark().name === 'pair') {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          p.shift()\n          const condition = p.process(EXPR_BUILDER)\n          const value = p.process(EXPR_BUILDER)\n          result.alternatives.push({\n            type: 'SelectAlternative',\n            condition,\n            value,\n          })\n        } else {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          const value = p.process(EXPR_BUILDER)\n          result.fallback = value\n        }\n      }\n      p.shift()\n      return result\n    }\n\n    const args: ExprNode[] = []\n\n    while (p.getMark().name !== 'func_args_end') {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        // Since the diff/delta functions aren't validated yet we only want to validate the selector\n        // being used. We expect the null valued arg to throw an error at evaluation time.\n        p.process(SELECTOR_BUILDER)\n        args.push({type: 'Selector'})\n      } else {\n        args.push(p.process(EXPR_BUILDER))\n      }\n    }\n\n    p.shift()\n\n    if (namespace === 'global' && (name === 'before' || name === 'after')) {\n      if (p.parseOptions.mode === 'delta') {\n        return {\n          type: 'Context',\n          key: name,\n        }\n      }\n    }\n\n    if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n      throw new GroqQueryError('unexpected boost')\n\n    const funcs = namespaces[namespace]\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const func = funcs[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n    if (func.arity !== undefined) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n\n    return {\n      type: 'FuncCall',\n      func,\n      name,\n      args,\n    }\n  },\n\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER)\n    p.shift() // Remove the func_call\n\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n    if (namespace !== 'global') {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const name = p.processString()\n    const args: ExprNode[] = []\n\n    const oldAllowBoost = p.allowBoost\n    if (name === 'score') {\n      // Only allow boost inside a score expression\n      p.allowBoost = true\n    }\n\n    for (;;) {\n      const markName = p.getMark().name\n      if (markName === 'func_args_end') {\n        break\n      }\n\n      if (name === 'order') {\n        if (markName === 'asc') {\n          p.shift()\n          args.push({type: 'Asc', base: p.process(EXPR_BUILDER)})\n          continue\n        } else if (markName === 'desc') {\n          p.shift()\n          args.push({type: 'Desc', base: p.process(EXPR_BUILDER)})\n          continue\n        }\n      }\n\n      args.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n\n    p.allowBoost = oldAllowBoost\n\n    const func = pipeFunctions[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`)\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    return {\n      type: 'PipeFuncCall',\n      func,\n      base,\n      name,\n      args,\n    }\n  },\n\n  pair(p) {\n    throw new GroqQueryError(`unexpected =>`)\n  },\n\n  and(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'And',\n      left,\n      right,\n    }\n  },\n\n  or(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'Or',\n      left,\n      right,\n    }\n  },\n\n  not(p) {\n    const base = p.process(EXPR_BUILDER)\n    return {\n      type: 'Not',\n      base,\n    }\n  },\n\n  asc(p) {\n    throw new GroqQueryError('unexpected asc')\n  },\n\n  desc(p) {\n    throw new GroqQueryError('unexpected desc')\n  },\n\n  param(p) {\n    const name = p.processString()\n\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: 'Value',\n        value: p.parseOptions.params[name],\n      }\n    }\n\n    return {\n      type: 'Parameter',\n      name,\n    }\n  },\n}\n\nconst OBJECT_BUILDER: MarkVisitor<ObjectAttributeNode> = {\n  object_expr(p) {\n    if (p.getMark().name === 'pair') {\n      p.shift()\n      const condition = p.process(EXPR_BUILDER)\n      const value = p.process(EXPR_BUILDER)\n\n      return {\n        type: 'ObjectConditionalSplat',\n        condition,\n        value,\n      }\n    }\n\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectAttributeValue',\n      name: extractPropertyKey(value),\n      value,\n    }\n  },\n\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER)\n    if (name.type !== 'Value') throw new Error('name must be string')\n\n    const value = p.process(EXPR_BUILDER)\n    return {\n      type: 'ObjectAttributeValue',\n      name: name.value,\n      value: value,\n    }\n  },\n\n  object_splat(p): ObjectSplatNode {\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectSplat',\n      value,\n    }\n  },\n\n  object_splat_this(): ObjectSplatNode {\n    return {\n      type: 'ObjectSplat',\n      value: {type: 'This'},\n    }\n  },\n}\n\nconst TRAVERSE_BUILDER: MarkVisitor<(rhs: TraversalResult | null) => TraversalResult> = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER)\n\n    const value = tryConstantEvaluate(expr)\n    if (value && value.type === 'number') {\n      return (right) =>\n        traverseElement((base) => ({type: 'AccessElement', base, index: value.data}), right)\n    }\n\n    if (value && value.type === 'string') {\n      return (right) =>\n        traversePlain((base) => ({type: 'AccessAttribute', base, name: value.data}), right)\n    }\n\n    return (right) =>\n      traverseArray(\n        (base) => ({\n          type: 'Filter',\n          base,\n          expr,\n        }),\n        right\n      )\n  },\n\n  slice(p) {\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n\n    const leftValue = tryConstantEvaluate(left)\n    const rightValue = tryConstantEvaluate(right)\n\n    if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n      throw new GroqQueryError('slicing must use constant numbers')\n    }\n\n    return (rhs) =>\n      traverseArray(\n        (base) => ({\n          type: 'Slice',\n          base,\n          left: leftValue.data,\n          right: rightValue.data,\n          isInclusive,\n        }),\n        rhs\n      )\n  },\n\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER)\n    return (right) =>\n      traverseProjection((base) => ({type: 'Projection', base: base, expr: obj}), right)\n  },\n\n  attr_access(p) {\n    const name = p.processString()\n\n    return (right) => traversePlain((base) => ({type: 'AccessAttribute', base, name}), right)\n  },\n\n  deref(p) {\n    let attr: string | null = null\n\n    if (p.getMark().name === 'deref_attr') {\n      p.shift()\n      attr = p.processString()\n    }\n\n    const wrap = (base: ExprNode): ExprNode =>\n      attr ? {type: 'AccessAttribute', base, name: attr} : base\n\n    return (right) =>\n      traversePlain(\n        (base) =>\n          wrap({\n            type: 'Deref',\n            base,\n          }),\n        right\n      )\n  },\n\n  array_postfix(p) {\n    return (right) => traverseArray((base) => ({type: 'ArrayCoerce', base}), right)\n  },\n}\n\nconst SELECTOR_BUILDER: MarkVisitor<null> = {\n  group(p) {\n    p.process(SELECTOR_BUILDER)\n    return null\n  },\n\n  everything() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  this() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  parent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  dblparent(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  traverse(p) {\n    p.process(SELECTOR_BUILDER)\n    while (p.getMark().name !== 'traversal_end') {\n      p.process(TRAVERSE_BUILDER)\n    }\n\n    p.shift()\n    return null\n  },\n\n  this_attr(p) {\n    p.processString()\n    return null\n  },\n\n  neg(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pos(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  add(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sub(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mul(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  div(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mod(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pow(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  comp(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  in_range(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  str(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  integer(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  float(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sci(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  object(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  array(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  tuple(p) {\n    // This should only throw an error until we add support for tuples in selectors.\n    throw new Error('Invalid selector syntax')\n  },\n\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark) as FuncCallNode\n    if (func.name === 'anywhere' && func.args.length === 1) return null\n\n    throw new Error('Invalid selector syntax')\n  },\n\n  pipecall(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pair(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  and(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  or(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  not(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  asc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  desc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  param(p) {\n    throw new Error('Invalid selector syntax')\n  },\n}\n\nfunction extractPropertyKey(node: ExprNode): string {\n  if (node.type === 'AccessAttribute' && !node.base) {\n    return node.name\n  }\n\n  if (\n    node.type === 'Deref' ||\n    node.type === 'Map' ||\n    node.type === 'Projection' ||\n    node.type === 'Slice' ||\n    node.type === 'Filter' ||\n    node.type === 'AccessElement' ||\n    node.type === 'ArrayCoerce'\n  ) {\n    return extractPropertyKey(node.base)\n  }\n\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`)\n}\n\nfunction validateArity(name: string, arity: GroqFunctionArity, count: number) {\n  if (typeof arity === 'number') {\n    if (count !== arity) {\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`\n      )\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`)\n    }\n  }\n}\n\nfunction argumentShouldBeSelector(namespace: string, functionName: string, argCount: number) {\n  const functionsRequiringSelectors = ['changedAny', 'changedOnly']\n\n  return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName)\n}\n\nclass GroqSyntaxError extends Error {\n  public position: number\n  public name = 'GroqSyntaxError'\n\n  constructor(position: number) {\n    super(`Syntax error in GROQ query at position ${position}`)\n    this.position = position\n  }\n}\n\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nexport function parse(input: string, options: ParseOptions = {}): ExprNode {\n  const result = rawParse(input)\n  if (result.type === 'error') {\n    throw new GroqSyntaxError(result.position)\n  }\n  const processor = new MarkProcessor(input, result.marks as Mark[], options)\n  return processor.process(EXPR_BUILDER)\n}\n", "import {Subscription, MutationEvent, Config, ApiError, EnvImplementations} from './types'\nimport type BrowserEventSource from '@sanity/eventsource/browser'\nimport type NodeEventSource from '@sanity/eventsource/node'\n\ntype EventSourceInstance = InstanceType<EnvImplementations['EventSource']>\n\n// The events used by Content Lake: https://www.sanity.io/docs/listening\nexport interface SharedEventSourceEventMap {\n  welcome: MessageEvent\n  mutation: MessageEvent\n  channelError: MessageEvent\n  disconnect: MessageEvent\n  error: Event\n}\ndeclare module 'event-source-polyfill' {\n  export interface EventSourceEventMap extends SharedEventSourceEventMap {}\n}\n\nconst isNativeBrowserEventSource = (\n  eventSource: EventSourceInstance\n): eventSource is InstanceType<typeof globalThis.EventSource> =>\n  typeof window !== 'undefined' &&\n  eventSource.addEventListener === window.EventSource.prototype.addEventListener\n\nconst isPolyfillEventSource = (\n  eventSource: EventSourceInstance\n): eventSource is InstanceType<typeof BrowserEventSource | typeof NodeEventSource> =>\n  !isNativeBrowserEventSource(eventSource)\n\nconst addEventSourceListener = (\n  eventSource: EventSourceInstance,\n  type: keyof SharedEventSourceEventMap,\n  listener: EventListener\n): void => {\n  if (isPolyfillEventSource(eventSource)) {\n    // Polyfilled event source does not accept option parameter\n    eventSource.addEventListener(type, listener as any)\n  } else {\n    eventSource.addEventListener(type, listener, false)\n  }\n}\n\nexport function listen(\n  EventSourceImpl: EnvImplementations['EventSource'],\n  config: Config,\n  handlers: {\n    open: () => void\n    error: (err: Error) => void\n    next: (event: MutationEvent) => void\n  }\n): Subscription {\n  const {projectId, dataset, token} = config\n  const headers = token ? {Authorization: `Bearer ${token}`} : undefined\n  const url = `https://${projectId}.api.sanity.io/v1/data/listen/${dataset}?query=*&effectFormat=mendoza`\n  const es = new EventSourceImpl(url, {withCredentials: true, headers})\n\n  addEventSourceListener(es, 'welcome', handlers.open)\n\n  addEventSourceListener(es, 'mutation', getMutationParser(handlers.next))\n\n  addEventSourceListener(es, 'channelError', (msg: any) => {\n    es.close()\n\n    let data\n    try {\n      data = JSON.parse(msg.data) as ApiError\n    } catch (err) {\n      handlers.error(new Error('Unknown error parsing listener message'))\n      return\n    }\n\n    handlers.error(\n      new Error(data.message || data.error || `Listener returned HTTP ${data.statusCode}`)\n    )\n  })\n\n  addEventSourceListener(es, 'error', (err: Event) => {\n    const origin = typeof window !== 'undefined' && window.location.origin\n    const hintSuffix = origin ? `, and that the CORS-origin (${origin}) is allowed` : ''\n    const errorMessage = isErrorLike(err) ? ` (${err.message})` : ''\n    handlers.error(\n      new Error(\n        `Error establishing listener - check that the project ID and dataset are correct${hintSuffix}${errorMessage}`\n      )\n    )\n  })\n\n  return {\n    unsubscribe: (): Promise<void> => Promise.resolve(es.close()),\n  }\n}\n\nfunction getMutationParser(cb: (event: MutationEvent) => void): (msg: any) => void {\n  return (msg: any) => {\n    let data\n    try {\n      data = JSON.parse(msg.data)\n    } catch (err) {\n      // intentional noop\n      return\n    }\n\n    cb(data)\n  }\n}\n\nfunction isErrorLike(err: unknown): err is {message: string} {\n  return typeof err === 'object' && err !== null && 'message' in err\n}\n", "import {SanityDocument} from '@sanity/types'\n\nexport function isDraft(doc: SanityDocument): boolean {\n  return doc._id.startsWith('drafts.')\n}\n\nexport function getPublishedId(document: SanityDocument): string {\n  return isDraft(document) ? document._id.slice(7) : document._id\n}\n", "import {SanityDocument} from '@sanity/types'\nimport {applyPatch} from 'mendoza'\n\nexport function applyPatchWithoutRev(\n  doc: SanityDocument | null,\n  patch: unknown[]\n): SanityDocument | null {\n  const patchDoc = {...doc} as Omit<SanityDocument, '_rev'>\n  delete patchDoc._rev\n  return applyPatch(patchDoc, patch)\n}\n", "import {SanityDocument} from '@sanity/types'\nimport {listen} from './listen'\nimport {getPublishedId} from './drafts'\nimport {applyPatchWithoutRev} from './patch'\nimport {Config, EnvImplementations, MutationEvent, Subscription} from './types'\n\nconst DEBOUNCE_MS = 25\n\nfunction noop() {\n  return Promise.resolve()\n}\n\nexport function getSyncingDataset(\n  config: Config,\n  onNotifyUpdate: (docs: SanityDocument[]) => void,\n  {getDocuments, EventSource}: EnvImplementations\n): Subscription & {loaded: Promise<void>} {\n  const {\n    projectId,\n    dataset,\n    listen: useListener,\n    overlayDrafts,\n    documentLimit,\n    token,\n    includeTypes,\n  } = config\n\n  // We don't want to flush updates while we're in the same transaction, so a normal\n  // throttle/debounce wouldn't do it. We need to wait and see if the next mutation is\n  // within the same transaction as the previous, and if not we can flush. Of course,\n  // we can't wait forever, so an upper threshold of X ms should be counted as \"ok to flush\"\n  let stagedDocs: SanityDocument[] | undefined\n  let previousTrx: string | undefined\n  let flushTimeout: NodeJS.Timer | undefined\n\n  const onUpdate = (docs: SanityDocument[]) => {\n    stagedDocs = undefined\n    flushTimeout = undefined\n    previousTrx = undefined\n    onNotifyUpdate(overlayDrafts ? overlay(docs) : docs)\n  }\n\n  if (!useListener) {\n    const loaded = getDocuments({projectId, dataset, documentLimit, token, includeTypes})\n      .then(onUpdate)\n      .then(noop)\n    return {unsubscribe: noop, loaded}\n  }\n\n  const indexedDocuments = new Map<string, SanityDocument>()\n\n  // undefined until the listener has been set up and the initial export is done\n  let documents: SanityDocument[] | undefined\n\n  // holds any mutations that happen while fetching documents so they can be applied after updates\n  const buffer: MutationEvent[] = []\n\n  // Return a promise we can resolve once we've established a listener and reconciled any mutations\n  let onDoneLoading: () => void\n  let onLoadError: (error: Error) => void\n  const loaded = new Promise<void>((resolve, reject) => {\n    onDoneLoading = resolve\n    onLoadError = reject\n  })\n\n  const onOpen = async () => {\n    const initial = await getDocuments({projectId, dataset, documentLimit, token, includeTypes})\n    documents = applyBufferedMutations(initial, buffer)\n    documents.forEach((doc) => indexedDocuments.set(doc._id, doc))\n    onUpdate(documents)\n    onDoneLoading()\n  }\n\n  const onMutationReceived = (msg: MutationEvent) => {\n    if (documents) {\n      applyMutation(msg)\n      scheduleUpdate(documents, msg)\n    } else {\n      buffer.push(msg)\n    }\n  }\n\n  const listener = listen(EventSource, config, {\n    next: onMutationReceived,\n    open: onOpen,\n    error: (error: Error) => onLoadError(error),\n  })\n\n  const scheduleUpdate = (docs: SanityDocument[], msg: MutationEvent) => {\n    clearTimeout(flushTimeout)\n\n    if (previousTrx !== msg.transactionId && stagedDocs) {\n      // This is a new transaction, meaning we can immediately flush any pending\n      // doc updates if there are any\n      onUpdate(stagedDocs)\n      previousTrx = undefined\n    } else {\n      previousTrx = msg.transactionId\n      stagedDocs = docs.slice()\n    }\n\n    flushTimeout = setTimeout(onUpdate, DEBOUNCE_MS, docs.slice())\n  }\n\n  const applyMutation = (msg: MutationEvent) => {\n    if (!msg.effects || msg.documentId.startsWith('_.')) {\n      return\n    }\n\n    const document = indexedDocuments.get(msg.documentId) || null\n    replaceDocument(msg.documentId, applyPatchWithoutRev(document, msg.effects.apply))\n  }\n\n  const replaceDocument = (id: string, document: SanityDocument | null) => {\n    const current = indexedDocuments.get(id)\n    const docs = documents || []\n    const position = current ? docs.indexOf(current) : -1\n\n    if (position === -1 && document) {\n      // Didn't exist previously, but was now created. Add it.\n      docs.push(document)\n      indexedDocuments.set(id, document)\n    } else if (document) {\n      // Existed previously and still does. Replace it.\n      docs.splice(position, 1, document)\n      indexedDocuments.set(id, document)\n    } else {\n      // Existed previously, but is now deleted. Remove it.\n      docs.splice(position, 1)\n      indexedDocuments.delete(id)\n    }\n  }\n\n  return {unsubscribe: listener.unsubscribe, loaded}\n}\n\nfunction applyBufferedMutations(\n  documents: SanityDocument[],\n  mutations: MutationEvent[]\n): SanityDocument[] {\n  // Group by document ID\n  const groups = new Map<string, MutationEvent[]>()\n  mutations.forEach((mutation) => {\n    const group = groups.get(mutation.documentId) || []\n    group.push(mutation)\n    groups.set(mutation.documentId, group)\n  })\n\n  // Discard all mutations that happened before our current document\n  groups.forEach((group, id) => {\n    const document = documents.find((doc) => doc._id === id)\n    if (!document) {\n      // @todo handle\n      // eslint-disable-next-line no-console\n      console.warn('Received mutation for missing document %s', id)\n      return\n    }\n\n    // Mutations are sorted by timestamp, apply any that arrived after\n    // we fetched the initial documents\n    let hasFoundRevision = false\n    let current: SanityDocument | null = document\n    group.forEach((mutation) => {\n      hasFoundRevision = hasFoundRevision || mutation.previousRev === document._rev\n      if (!hasFoundRevision) {\n        return\n      }\n\n      if (mutation.effects) {\n        current = applyPatchWithoutRev(current, mutation.effects.apply)\n      }\n    })\n\n    // Replace the indexed documents\n    documents.splice(documents.indexOf(document), 1, current)\n  })\n\n  return documents\n}\n\nfunction overlay(documents: SanityDocument[]): SanityDocument[] {\n  const overlayed = new Map<string, SanityDocument>()\n\n  documents.forEach((doc) => {\n    const existing = overlayed.get(getPublishedId(doc))\n    if (doc._id.startsWith('drafts.')) {\n      // Drafts always overlay\n      overlayed.set(getPublishedId(doc), pretendThatItsPublished(doc))\n    } else if (!existing) {\n      // Published documents only override if draft doesn't exist\n      overlayed.set(doc._id, doc)\n    }\n  })\n\n  return Array.from(overlayed.values())\n}\n\n// Strictly speaking it would be better to allow groq-js to resolve `draft.<id>`,\n// but for now this will have to do\nfunction pretendThatItsPublished(doc: SanityDocument): SanityDocument {\n  return {...doc, _id: getPublishedId(doc)}\n}\n", "import groq from 'groq'\nimport deepEqual from 'fast-deep-equal'\nimport {throttle} from 'throttle-debounce'\nimport {SanityDocument} from '@sanity/types'\nimport {parse, evaluate} from 'groq-js'\nimport {Config, EnvImplementations, GroqSubscription, GroqStore, Subscription} from './types'\nimport {getSyncingDataset} from './syncingDataset'\n\nexport function groqStore(config: Config, envImplementations: EnvImplementations): GroqStore {\n  let documents: SanityDocument[] = []\n  const executeThrottled = throttle(config.subscriptionThrottleMs || 50, executeAllSubscriptions)\n  const activeSubscriptions: GroqSubscription[] = []\n\n  let dataset: Subscription & {loaded: Promise<void>}\n\n  async function loadDataset() {\n    if (!dataset) {\n      dataset = getSyncingDataset(\n        config,\n        (docs) => {\n          documents = docs\n          executeThrottled()\n        },\n        envImplementations\n      )\n    }\n\n    await dataset.loaded\n  }\n\n  async function query<R = any>(groqQuery: string, params?: Record<string, unknown>): Promise<R> {\n    await loadDataset()\n    const tree = parse(groqQuery, {params})\n    const result = await evaluate(tree as any, {dataset: documents, params})\n    return result.get()\n  }\n\n  async function getDocument(documentId: string): Promise<SanityDocument | null> {\n    await loadDataset()\n    return query(groq`*[_id == $id][0]`, {id: documentId})\n  }\n\n  async function getDocuments(documentIds: string[]): Promise<(SanityDocument | null)[]> {\n    await loadDataset()\n    const subQueries = documentIds.map((id) => `*[_id == \"${id}\"][0]`).join(',\\n')\n    return query(`[${subQueries}]`)\n  }\n\n  function subscribe<R = any>(\n    groqQuery: string,\n    params: Record<string, unknown>,\n    callback: (error: Error | undefined, result?: R) => void\n  ): Subscription {\n    if (!config.listen) {\n      throw new Error('Cannot use `subscribe()` without `listen: true`')\n    }\n\n    // @todo Execute the query against an empty dataset for validation purposes\n\n    // Store the subscription so we can re-run the query on new data\n    const subscription = {query: groqQuery, params, callback}\n    activeSubscriptions.push(subscription)\n\n    let unsubscribed = false\n    const unsubscribe = () => {\n      if (unsubscribed) {\n        return Promise.resolve()\n      }\n\n      unsubscribed = true\n      activeSubscriptions.splice(activeSubscriptions.indexOf(subscription), 1)\n      return Promise.resolve()\n    }\n\n    executeQuerySubscription(subscription)\n    return {unsubscribe}\n  }\n\n  function executeQuerySubscription(subscription: GroqSubscription) {\n    return query(subscription.query, subscription.params)\n      .then((res) => {\n        if ('previousResult' in subscription && deepEqual(subscription.previousResult, res)) {\n          return\n        }\n\n        subscription.previousResult = res\n        subscription.callback(undefined, res)\n      })\n      .catch((err) => {\n        subscription.callback(err)\n      })\n  }\n\n  function executeAllSubscriptions() {\n    activeSubscriptions.forEach(executeQuerySubscription)\n  }\n\n  function close() {\n    executeThrottled.cancel()\n    return dataset ? dataset.unsubscribe() : Promise.resolve()\n  }\n\n  return {query, getDocument, getDocuments, subscribe, close}\n}\n", "import {SanityDocument} from '@sanity/types'\nimport {EnvImplementations} from '../types'\n\ntype StreamError = {error: {description?: string; type: string}}\ntype StreamResult = SanityDocument | StreamError\n\nexport const getDocuments: EnvImplementations['getDocuments'] = async function getDocuments({\n  projectId,\n  dataset,\n  token,\n  documentLimit,\n  includeTypes = [],\n}: {\n  projectId: string\n  dataset: string\n  token?: string\n  documentLimit?: number\n  includeTypes?: string[]\n}): Promise<SanityDocument[]> {\n  const baseUrl = `https://${projectId}.api.sanity.io/v1/data/export/${dataset}`\n  const params =\n    includeTypes.length > 0 ? new URLSearchParams({types: includeTypes?.join(',')}) : ''\n  const url = `${baseUrl}?${params}`\n  const headers = token ? {Authorization: `Bearer ${token}`} : undefined\n  const response = await fetch(url, {credentials: 'include', headers})\n\n  if (response.status !== 200) {\n    throw new Error(`Error streaming dataset: ${getError(await response.json())}`)\n  }\n\n  const stream = getDocumentStream(response.body)\n  const reader = stream.getReader()\n\n  const documents: SanityDocument[] = []\n  let result\n  let document\n  do {\n    result = await reader.read()\n    document = result.value\n\n    if (isStreamError(document)) {\n      throw new Error(`Error streaming dataset: ${document.error}`)\n    } else if (document && isRelevantDocument(document)) {\n      documents.push(document)\n    }\n\n    if (documentLimit && documents.length > documentLimit) {\n      reader.cancel('Reached document limit')\n      throw new Error(\n        `Error streaming dataset: Reached limit of ${documentLimit} documents. Try using the includeTypes option to reduce the amount of documents, or increase the limit.`\n      )\n    }\n  } while (!result.done)\n\n  return documents\n}\n\nfunction getDocumentStream(body: Response['body']): ReadableStream<StreamResult> {\n  if (!body) {\n    throw new Error('Failed to read body from response')\n  }\n\n  let reader: ReadableStreamDefaultReader<Uint8Array> | undefined\n  let cancelled = false\n\n  function cancel() {\n    cancelled = true\n    if (reader) {\n      reader.cancel()\n    }\n  }\n\n  return new ReadableStream<SanityDocument>({\n    start(controller): void | PromiseLike<void> {\n      reader = body.getReader()\n      const decoder = new TextDecoder()\n      let buffer = ''\n\n      reader\n        .read()\n        .then(processResult)\n        .catch((err) => controller.error(err))\n\n      async function processResult(result: ReadableStreamReadResult<Uint8Array>): Promise<void> {\n        if (result.done) {\n          if (cancelled) {\n            return\n          }\n\n          buffer = buffer.trim()\n          if (buffer.length === 0) {\n            controller.close()\n            return\n          }\n\n          controller.enqueue(JSON.parse(buffer))\n          controller.close()\n          return\n        }\n\n        buffer += decoder.decode(result.value, {stream: true})\n        const lines = buffer.split('\\n')\n\n        for (let i = 0; i < lines.length - 1; ++i) {\n          const line = lines[i].trim()\n          if (line.length === 0) {\n            continue\n          }\n\n          try {\n            controller.enqueue(JSON.parse(line))\n          } catch (err) {\n            controller.error(err)\n            cancel()\n            return\n          }\n        }\n\n        buffer = lines[lines.length - 1]\n\n        if (!reader) {\n          return\n        }\n\n        try {\n          processResult(await reader.read())\n        } catch (err) {\n          controller.error(err)\n        }\n      }\n    },\n\n    cancel,\n  })\n}\n\nfunction isStreamError(result: StreamResult | undefined): result is StreamError {\n  if (!result) {\n    return false\n  }\n\n  if (!('error' in result) || typeof result.error !== 'object' || result.error === null) {\n    return false\n  }\n\n  return (\n    'description' in result.error &&\n    typeof (result as StreamError).error.description === 'string' &&\n    !('_id' in result)\n  )\n}\n\nfunction getError(body: any): string {\n  if (typeof body === 'object' && 'error' in body && 'message' in body) {\n    return body.message || body.error\n  }\n\n  return '<unknown error>'\n}\n\nfunction isRelevantDocument(doc: SanityDocument): boolean {\n  return !doc._id.startsWith('_.')\n}\n", "export function assertEnvSupport(): void {\n  const required = ['EventSource', 'ReadableStream', 'fetch']\n  const unsupported = required.filter((api) => !(api in window))\n\n  if (unsupported.length > 0) {\n    throw new Error(`Browser not supported. Missing browser APIs: ${unsupported.join(', ')}`)\n  }\n}\n", "import {groqStore as groqStoreApi} from '../groqStore'\nimport {Config, GroqStore} from '../types'\nimport {getDocuments} from './getDocuments'\nimport {assertEnvSupport} from './support'\n\n/** @public */\nexport function groqStore(config: Config): GroqStore {\n  assertEnvSupport()\n\n  const EventSource = config.EventSource ?? window.EventSource\n\n  if (config.token) {\n    if (!config.EventSource) {\n      throw new Error(\n        'When the `token` option is used the `EventSource` option must also be provided.'\n      )\n    }\n    if (config.EventSource === window.EventSource)\n      throw new Error(\n        'When the `token` option is used the `EventSource` option must also be provided. ' +\n          'EventSource cannot be `window.EventSource`, as it does not support passing a token.'\n      )\n  }\n\n  return groqStoreApi(config, {\n    EventSource,\n    getDocuments,\n  })\n}\n\nexport {default as groq} from 'groq'\nexport type {Subscription, GroqStore, EnvImplementations} from '../types'\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,WAAO,UAAU,SAAS,MAAM,GAAG,GAAG;AACpC,UAAI,MAAM;AAAG,eAAO;AAEpB,UAAI,KAAK,KAAK,OAAO,KAAK,YAAY,OAAO,KAAK,UAAU;AAC1D,YAAI,EAAE,gBAAgB,EAAE;AAAa,iBAAO;AAE5C,YAAIA,SAAQ,GAAG;AACf,YAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,UAAAA,UAAS,EAAE;AACX,cAAIA,WAAU,EAAE;AAAQ,mBAAO;AAC/B,eAAK,IAAIA,SAAQ,QAAQ;AACvB,gBAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;AAAG,qBAAO;AACjC,iBAAO;AAAA,QACT;AAIA,YAAI,EAAE,gBAAgB;AAAQ,iBAAO,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE;AAC5E,YAAI,EAAE,YAAY,OAAO,UAAU;AAAS,iBAAO,EAAE,QAAQ,MAAM,EAAE,QAAQ;AAC7E,YAAI,EAAE,aAAa,OAAO,UAAU;AAAU,iBAAO,EAAE,SAAS,MAAM,EAAE,SAAS;AAEjF,eAAO,OAAO,KAAK,CAAC;AACpB,QAAAA,UAAS,KAAK;AACd,YAAIA,YAAW,OAAO,KAAK,CAAC,EAAE;AAAQ,iBAAO;AAE7C,aAAK,IAAIA,SAAQ,QAAQ;AACvB,cAAI,CAAC,OAAO,UAAU,eAAe,KAAK,GAAG,KAAK,CAAC,CAAC;AAAG,mBAAO;AAEhE,aAAK,IAAIA,SAAQ,QAAQ,KAAI;AAC3B,cAAI,MAAM,KAAK,CAAC;AAEhB,cAAI,CAAC,MAAM,EAAE,GAAG,GAAG,EAAE,GAAG,CAAC;AAAG,mBAAO;AAAA,QACrC;AAEA,eAAO;AAAA,MACT;AAGA,aAAO,MAAI,KAAK,MAAI;AAAA,IACtB;AAAA;AAAA;;;;;;;;;;;AC7CA;;;;;AAuBe,SAAA,SAAUC,OAAOC,UAAUC,SAAS;AAK9CA,MAAAA,OAAAA,WAAW,CAAA,GAJf,kBAAA,KACCC,YAAAA,aADD,oBAAA,SACc,QADd,iBAAA,iBAAA,KAECC,WAAAA,YAFD,mBAAA,SAEa,QAFb,gBAAA,oBAAA,KAGCC,cAAAA,eAHD,sBAAA,SAGgBC,SAHhB;AAUA,MAAIC;AACJ,MAAIC,YAAY;AAGhB,MAAIC,WAAW;AAGf,WAASC,uBAAuB;AAC/B,QAAIH,WAAW;AACdI,mBAAaJ,SAAD;IACZ;EACD;AAGQK,WAAAA,OAAOV,UAAS;AACSA,QAAAA,QAAAA,YAAW,CAAA,GAA5C,qBAAA,MAAQW,cAAAA,eAAR,uBAAA,SAAuB,QAAvB;AACAH,yBAAoB;AACpBF,gBAAY,CAACK;EACb;AAOD,WAASC,UAAuB;AAAA,aAAA,OAAA,UAAA,QAAZC,aAAY,IAAA,MAAA,IAAA,GAAA,OAAA,GAAA,OAAA,MAAA,QAAA;AAAZA,iBAAY,IAAA,IAAA,UAAA,IAAA;IAAA;AAC3BC,QAAAA,OAAO;AACX,QAAIC,UAAUC,KAAKC,IAAL,IAAaV;AAE3B,QAAID,WAAW;AACd;IACA;AAGD,aAASY,OAAO;AACfX,iBAAWS,KAAKC,IAAL;AACXlB,eAASoB,MAAML,MAAMD,UAArB;IACA;AAMD,aAASO,QAAQ;AAChBf,kBAAYD;IACZ;AAED,QAAI,CAACF,aAAaC,gBAAgB,CAACE,WAAW;AAM7Ca,WAAI;IACJ;AAEDV,yBAAoB;AAEpB,QAAIL,iBAAiBC,UAAaW,UAAUjB,OAAO;AAClD,UAAII,WAAW;AAMdK,mBAAWS,KAAKC,IAAL;AACP,YAAA,CAAChB,YAAY;AAChBI,sBAAYgB,WAAWlB,eAAeiB,QAAQF,MAAMpB,KAA9B;QACtB;MACD,OAAM;AAKNoB,aAAI;MACJ;IACD,WAAUjB,eAAe,MAAM;AAY/BI,kBAAYgB,WACXlB,eAAeiB,QAAQF,MACvBf,iBAAiBC,SAAYN,QAAQiB,UAAUjB,KAF1B;IAItB;EACD;AAEDc,UAAQF,SAASA;AAGjB,SAAOE;AACP;;;AErID;AAAA;AAAA;AAAA;AAAA;;;ACAA;;;;;SAASU,aAAaC,SAAgB;AAC7B,SAAAA,QAAOC,QAAQ,uBAAuB,MAAM;AACrD;AAEA,SAASC,WAAWC,SAAiB;AACnC,QAAMC,KAAK,CAAA;AACX,aAAWC,QAAQF,QAAQG,MAAM,GAAG,GAAG;AACrC,QAAID,SAAS,KAAK;AAChBD,SAAGG,KAAK,OAAO;IAAA,WACNF,SAAS,MAAM;AACxBD,SAAGG,KAAK,IAAI;IAAA,OACP;AACFH,SAAAG,KAAKR,aAAaM,IAAI,CAAC;IAC5B;EACF;AAEA,SAAO,IAAIG,OAAO,IAAAC,OAAIL,GAAGM,KAAK,GAAG,GAAI,GAAA,CAAA;AACvC;AAEO,IAAMC,OAAN,MAAW;EAIhBC,YAAYT,SAAiB;AAC3B,SAAKA,UAAUA;AACV,SAAAU,YAAYX,WAAWC,OAAO;EACrC;EAEAW,QAAQC,KAAsB;AACrB,WAAA,KAAKF,UAAUG,KAAKD,GAAG;EAChC;EAEAE,SAAiB;AACf,WAAO,KAAKd;EACd;AACF;ACjCO,IAAMe,cAAN,MAAkB;EAOvBN,YAAYO,WAAuD;AANlD,SAAAC,OAAA;AAOf,SAAKD,YAAYA;AACjB,SAAKE,SAAS;AACd,SAAKC,SAAS;AACd,SAAKC,OAAO,CAAA;EACd;;EAGAC,UAAmB;AACV,WAAA;EACT;EAEA,MAAMC,MAAoB;AACxB,UAAMC,SAAS,CAAA;AACf,qBAAiBC,SAAS,MAAM;AAC9BD,aAAOnB,KAAK,MAAMoB,MAAMF,IAAA,CAAK;IAC/B;AACO,WAAAC;EACT;EAEA,QAAQE,OAAOC,aAAa,IAA0C;AACpE,QAAIC,IAAI;AACR,WAAO,MAAM;AACX,aAAOA,IAAI,KAAKP,KAAKQ,QAAQD,KAAK;AAC1B,cAAA,KAAKP,KAAKO,CAAC;MACnB;AAEA,UAAI,KAAKR,QAAQ;AACf;MACF;AAEA,YAAM,KAAKU,UAAU;IACvB;EACF;EAEAA,YAA2B;AACzB,QAAI,KAAKX,QAAQ;AACf,aAAO,KAAKA;IACd;AAEI,QAAAY;AACJ,UAAMC,cAAcA,MAAM;AACxB,WAAKb,SAAS,IAAIc,QAASC,aAAY;AACnBH,0BAAAG;MAAA,CACnB;IAAA;AAGH,UAAMC,OAAOA,MAAM;AACDJ,sBAAA;AACJC,kBAAA;IAAA;AAGd,UAAMI,SAAQ,YAAY;AACP,uBAAAX,SAAS,KAAKR,UAAA,GAAa;AACrC,aAAAI,KAAKhB,KAAKoB,KAAK;AACfU,aAAA;MACP;AAEA,WAAKf,SAAS;AACTe,WAAA;IAAA;AAGKH,gBAAA;AACNI,IAAAA,OAAA;AACN,WAAO,KAAKjB;EACd;AACF;AC3EA,IAAMkB,gBAAgB;AAEf,SAASC,aAAazB,KAA0B;AACjD,MAAAwB,cAAcvB,KAAKD,GAAG,GAAG;AACpB,WAAA,IAAI0B,KAAK1B,GAAG;EACrB;AACO,SAAA;AACT;AAEO,SAAS2B,cAAcC,GAAiB;AAC7C,QAAMC,OAAOC,eAAeF,EAAEG,eAAA,GAAkB,CAAC;AACjD,QAAMC,QAAQF,eAAeF,EAAEK,YAAY,IAAI,GAAG,CAAC;AACnD,QAAMC,MAAMJ,eAAeF,EAAEO,WAAA,GAAc,CAAC;AAC5C,QAAMC,OAAON,eAAeF,EAAES,YAAA,GAAe,CAAC;AAC9C,QAAMC,SAASR,eAAeF,EAAEW,cAAA,GAAiB,CAAC;AAClD,QAAMC,SAASV,eAAeF,EAAEa,cAAA,GAAiB,CAAC;AAElD,MAAIC,mBAAmB;AACjB,QAAAC,SAASf,EAAEgB,gBAAgB;AACjC,MAAID,UAAU,GAAG;AACID,uBAAA,IAAAhD,OAAIoC,eAAea,QAAQ,CAAC,CAAA;EACjD;AAEA,SAAA,GAAAjD,OAAUmC,MAAQ,GAAA,EAAAnC,OAAAsC,OAAA,GAAA,EAAAtC,OAASwC,KAAO,GAAA,EAAAxC,OAAA0C,MAAA,GAAA,EAAA1C,OAAQ4C,QAAAA,GAAAA,EAAAA,OAAUE,MAAS,EAAA9C,OAAAgD,kBAAA,GAAA;AAC/D;AAMA,SAASZ,eAAee,KAAeC,cAAsB;AACvD,MAAA9C,MAAM6C,IAAIE,SAAS;AAChB,SAAA/C,IAAIgB,SAAS8B,cAAc;AAChC9C,UAAA,IAAAN,OAAUM,GAAA;EACZ;AACO,SAAAA;AACT;AC/BO,IAAMgD,cAAN,MAAyC;EAI9CnD,YAAYW,MAASH,MAAS;AAC5B,SAAKG,OAAOA;AACZ,SAAKH,OAAOA;EACd;EAEAI,UAAmB;AACjB,WAAO,KAAKJ,SAAS;EACvB;;EAGA,MAAMK,MAAoB;AACxB,WAAO,KAAKF;EACd;EAEA,CAACK,OAAOC,aAAa,IAAqC;AACxD,QAAImC,MAAMxC,QAAQ,KAAKD,IAAI,GAAG;AAC5B,aAAQ,WAAWA,MAAM;AACvB,mBAAW0C,WAAW1C,MAAM;AAC1B,gBAAM2C,OAAOD,OAAO;QACtB;MAAA,EACC,KAAK1C,IAAI;IACd;AACA,UAAM,IAAI4C,MAAA,wBAAA1D,OAA8B,KAAKW,IAAM,CAAA;EACrD;AACF;AAEO,IAAMgD,aAAwB,IAAIL,YAAY,MAAM,MAAM;AAC1D,IAAMM,aAA2B,IAAIN,YAAY,MAAM,SAAS;AAChE,IAAMO,cAA4B,IAAIP,YAAY,OAAO,SAAS;AAElE,IAAMQ,WAAN,MAAe;EAGpB3D,YAAY4D,MAAY;AACtB,SAAKA,OAAOA;EACd;EAEA,OAAOC,aAAa1D,KAAoB;AAChC,UAAAyD,OAAOhC,aAAazB,GAAG;AAC7B,QAAIyD,MAAM;AACR,aAAO,IAAIT,YAAY,IAAIQ,SAASC,IAAI,GAAG,UAAU;IACvD;AACO,WAAAJ;EACT;EAEAM,OAAOC,OAA0B;AAC/B,WAAO,KAAKH,KAAKI,QAAA,KAAaD,MAAMH,KAAKI,QAAQ;EACnD;EAEAC,IAAIC,MAAwB;AAC1B,UAAMC,OAAO,IAAItC,KAAK,KAAK+B,KAAKI,QAAAA,CAAS;AACzCG,SAAKC,QAAQD,KAAKH,QAAQ,IAAIE,OAAO,GAAI;AAClC,WAAA,IAAIP,SAASQ,IAAI;EAC1B;EAEAE,WAAWN,OAAyB;AAClC,YAAQ,KAAKH,KAAKI,QAAA,IAAYD,MAAMH,KAAKI,QAAAA,KAAa;EACxD;EAEAM,UAAUP,OAAyB;AACjC,WAAO,KAAKH,KAAKI,QAAA,IAAYD,MAAMH,KAAKI,QAAQ;EAClD;EAEAd,WAAmB;AACV,WAAApB,cAAc,KAAK8B,IAAI;EAChC;EAEAvD,SAAiB;AACf,WAAO,KAAK6C,SAAS;EACvB;AACF;AAEO,SAASqB,WAAWvB,KAAoB;AACzC,MAAAwB,OAAOC,SAASzB,GAAG,GAAG;AACjB,WAAA,IAAIG,YAAYH,KAAK,QAAQ;EACtC;AACO,SAAAQ;AACT;AAEO,SAASkB,WAAWvE,KAAoB;AACtC,SAAA,IAAIgD,YAAYhD,KAAK,QAAQ;AACtC;AAEO,SAASwE,aAAaC,IAAqB;AACzC,SAAA,IAAIzB,YAAYyB,IAAI,UAAU;AACvC;AAEO,SAASC,SAASC,OAAmB;AACnC,SAAA,IAAI3B,YAAY2B,OAAM,MAAM;AACrC;AAEA,SAASC,WAAWC,KAAqB;AAChC,SAAAA,OAAO,OAAOA,IAAIC,SAAS;AACpC;AAGO,SAAS3B,OAAO4B,KAAiB;AAClC,MAAAH,WAAWG,GAAG,GAAG;AACZ,WAAA,IAAI5E,YAAY,mBAAmB;AACxC,uBAAiBS,SAASmE,KAAK;AAC7B,cAAM5B,OAAOvC,KAAK;MACpB;IAAA,CACD;EACQ,WAAAmE,QAAQ,QAAQA,QAAQ,QAAW;AACrC,WAAA1B;EACT;AACA,SAAO,IAAIL,YAAY+B,KAAKC,QAAQD,GAAG,CAAC;AAC1C;AAMO,SAASC,QAAQxE,MAAqB;AAC3C,MAAIA,SAAS,QAAQ,OAAOA,SAAS,aAAa;AACzC,WAAA;EACT;AACI,MAAAyC,MAAMxC,QAAQD,IAAI,GAAG;AAChB,WAAA;EACT;AACA,MAAIA,gBAAgBZ,MAAM;AACjB,WAAA;EACT;AACA,MAAIY,gBAAgBgD,UAAU;AACrB,WAAA;EACT;AACA,SAAO,OAAOhD;AAChB;ACtIgB,SAAAyE,QAAQC,GAAUC,GAAmB;AAEhD,MAAAD,EAAE7E,SAAS,YAAY8E,EAAE9E,SAAS,YAClC6E,EAAE7E,SAAS,aAAa8E,EAAE9E,SAAS,aACnC6E,EAAE7E,SAAS,UAAU8E,EAAE9E,SAAS,UAChC6E,EAAE7E,SAAS,YAAY8E,EAAE9E,SAAS,UACnC;AACO,WAAA6E,EAAE1E,SAAS2E,EAAE3E;EACtB;AAEA,MAAI0E,EAAE7E,SAAS,cAAc8E,EAAE9E,SAAS,YAAY;AAClD,WAAO6E,EAAE1E,KAAKmD,OAAOwB,EAAE3E,IAAI;EAC7B;AAEO,SAAA;AACT;ACfA,IAAM4E,QAAQ;AACd,IAAMC,sBAAsB;AAC5B,IAAMC,aAAa;AACnB,IAAMC,kBAAkB;AAMR,SAAAC,UAAUC,QAAiBC,UAA8B;AACvE,MAAID,OAAOzE,WAAW,KAAK0E,SAAS1E,WAAW,GAAG;AACzC,WAAA;EACT;AAEA,SAAO0E,SAASC,MAAOvG,aAAYA,QAAQqG,MAAM,CAAC;AACpD;AAEO,SAASG,cAAcC,MAAuB;AAC5C,SAAAA,KAAK3G,QAAQoG,YAAY,EAAE,EAAEQ,MAAMV,KAAK,KAAK,CAAA;AACtD;AAEO,SAASW,oBAAoBF,MAAyB;AACrD,QAAAG,UAAUC,kBAAkBJ,IAAI;AACtC,SAAOG,QAAQE,IAAK7G,QAAQoG,YAAoBA,OAAOU,KAAMC,WAAU/G,GAAGY,KAAKmG,KAAK,CAAC,CAAC;AACxF;AAEO,SAASH,kBAAkBJ,MAAwB;AAClD,QAAAQ,QAAQR,KAAK3G,QAAQoG,YAAY,EAAE,EAAEQ,MAAMT,mBAAmB,KAAK,CAAA;AACzE,SAAOgB,MAAMH,IACVI,UAAS,IAAI7G,OAAA,IAAAC,OAAW4G,KAAKC,MAAM,GAAGhB,eAAe,EAAErG,QAAQ,OAAO,IAAI,GAAA,GAAA,GAAM,GAAG,CAAA;AAExF;AAEsB,eAAAsH,WAAW5F,OAAc6F,IAA6C;AACtF,MAAA7F,MAAMP,SAAS,UAAU;AAC3BoG,OAAG7F,MAAMJ,IAAI;AACN,WAAA;EACT;AAEI,MAAAI,MAAMH,QAAAA,GAAW;AACnB,QAAIiG,UAAU;AACd,qBAAiBpH,QAAQsB,OAAO;AAC1B,UAAAtB,KAAKe,SAAS,UAAU;AAC1BoG,WAAGnH,KAAKkB,IAAI;MAAA,OACP;AACKkG,kBAAA;MACZ;IACF;AACO,WAAAA;EACT;AAEO,SAAA;AACT;ACpDA,IAAMC,aAA2C;EAC/CC,UAAU;EACVC,QAAQ;EACR5H,QAAQ;EACR6H,SAAS;AACX;AAGgB,SAAAC,eAAe7B,GAAQC,GAAuB;AACtD,QAAA6B,QAAQhC,QAAQE,CAAC;AACjB,QAAA+B,QAAQjC,QAAQG,CAAC;AAEvB,MAAI6B,UAAUC,OAAO;AACZ,WAAA;EACT;AAEA,UAAQD,OAAO;IACb,KAAK;IACL,KAAK;AACH,aAAO9B,IAAIC;IACb,KAAK;AACH,UAAID,IAAIC;AAAU,eAAA;AAClB,UAAID,IAAIC;AAAU,eAAA;AACX,aAAA;IACT,KAAK;AACI,aAAAD,EAAEf,UAAUgB,CAAC;IACtB;AACS,aAAA;EAAA;AAEb;AAGgB,SAAA+B,aAAahC,GAAQC,GAAgB;AAC7C,QAAA6B,QAAQhC,QAAQE,CAAC;AACjB,QAAA+B,QAAQjC,QAAQG,CAAC;AAEjB,QAAAgC,aAAaR,WAAWK,KAAK,KAAK;AAClC,QAAAI,aAAaT,WAAWM,KAAK,KAAK;AAExC,MAAIE,eAAeC,YAAY;AAC7B,WAAOD,aAAaC;EACtB;AAEI,MAAAzG,SAASoG,eAAe7B,GAAGC,CAAC;AAChC,MAAIxE,WAAW,MAAM;AACVA,aAAA;EACX;AACO,SAAAA;AACT;AChCO,IAAM0G,YAA+C;EAC1D,MAAM,SAASC,GAAGC,MAAMC,OAAO;AAC7B,WAAOvC,QAAQsC,MAAMC,KAAK,IAAIlE,aAAaC;EAC7C;EAEA,MAAM,SAASkE,IAAIF,MAAMC,OAAO;AAC9B,WAAOvC,QAAQsC,MAAMC,KAAK,IAAIjE,cAAcD;EAC9C;EAEA,KAAK,SAASoE,GAAGH,MAAMC,OAAO;AAC5B,QAAID,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS;AAAiB,aAAAgD;AAC9D,UAAM1C,SAASoG,eAAeQ,KAAK/G,MAAMgH,MAAMhH,IAAI;AAEnD,QAAIG,WAAW,MAAM;AACZ,aAAA0C;IACT;AACO,WAAA1C,SAAS,IAAI2C,aAAaC;EACnC;EAEA,MAAM,SAASoE,IAAIJ,MAAMC,OAAO;AAC9B,QAAID,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS;AAAiB,aAAAgD;AAC9D,UAAM1C,SAASoG,eAAeQ,KAAK/G,MAAMgH,MAAMhH,IAAI;AAEnD,QAAIG,WAAW,MAAM;AACZ,aAAA0C;IACT;AACO,WAAA1C,UAAU,IAAI2C,aAAaC;EACpC;EAEA,KAAK,SAASqE,GAAGL,MAAMC,OAAO;AAC5B,QAAID,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS;AAAiB,aAAAgD;AAC9D,UAAM1C,SAASoG,eAAeQ,KAAK/G,MAAMgH,MAAMhH,IAAI;AAEnD,QAAIG,WAAW,MAAM;AACZ,aAAA0C;IACT;AACO,WAAA1C,SAAS,IAAI2C,aAAaC;EACnC;EAEA,MAAM,SAASsE,IAAIN,MAAMC,OAAO;AAC9B,QAAID,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS;AAAiB,aAAAgD;AAC9D,UAAM1C,SAASoG,eAAeQ,KAAK/G,MAAMgH,MAAMhH,IAAI;AAEnD,QAAIG,WAAW,MAAM;AACZ,aAAA0C;IACT;AACO,WAAA1C,UAAU,IAAI2C,aAAaC;EACpC;;EAGAuE,IAAI,eAAeC,KAAKR,MAAMC,OAAO;AAC/B,QAAAA,MAAMnH,SAAS,QAAQ;AACrB,UAAAkH,KAAKlH,SAAS,UAAU;AACnB,eAAAgD;MACT;AAEA,aAAOmE,MAAMhH,KAAKT,QAAQwH,KAAK/G,IAAI,IAAI8C,aAAaC;IACtD;AAEI,QAAAiE,MAAM/G,QAAAA,GAAW;AACnB,uBAAiB0E,KAAKqC,OAAO;AACvB,YAAAvC,QAAQsC,MAAMpC,CAAC,GAAG;AACb,iBAAA7B;QACT;MACF;AAEO,aAAAC;IACT;AAEO,WAAAF;EACT;EAEAyC,OAAO,eAAeA,MAAMyB,MAAMC,OAAO;AACvC,QAAI/B,SAAkB,CAAA;AACtB,QAAIC,WAAsB,CAAA;AAEpB,UAAAc,WAAWe,MAAOjI,UAAS;AAC/BmG,eAASA,OAAO/F,OAAOkG,cAActG,IAAI,CAAC;IAAA,CAC3C;AAED,UAAM0I,aAAa,MAAMxB,WAAWgB,OAAQlI,UAAS;AACnDoG,iBAAWA,SAAShG,OAAOqG,oBAAoBzG,IAAI,CAAC;IAAA,CACrD;AACD,QAAI,CAAC0I,YAAY;AACR,aAAAzE;IACT;AAEM,UAAA0E,UAAUzC,UAAUC,QAAQC,QAAQ;AAE1C,WAAOuC,UAAU3E,aAAaC;EAChC;EAEA,KAAK,SAAS2E,KAAKX,MAAMC,OAAO;AAC9B,QAAID,KAAKlH,SAAS,cAAcmH,MAAMnH,SAAS,UAAU;AACvD,aAAOmE,aAAa+C,KAAK/G,KAAKsD,IAAI0D,MAAMhH,IAAI,CAAC;IAC/C;AAEA,QAAI+G,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS,UAAU;AACrD,aAAO+D,WAAWmD,KAAK/G,OAAOgH,MAAMhH,IAAI;IAC1C;AAEA,QAAI+G,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS,UAAU;AACrD,aAAOkE,WAAWgD,KAAK/G,OAAOgH,MAAMhH,IAAI;IAC1C;AAEA,QAAI+G,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS,UAAU;AAC9C,aAAA8C,OAAO;QAAC,GAAGoE,KAAK/G;QAAM,GAAGgH,MAAMhH;OAAK;IAC7C;AAEA,QAAI+G,KAAKlH,SAAS,WAAWmH,MAAMnH,SAAS,SAAS;AACnD,aAAO8C,OAAOoE,KAAK/G,KAAKd,OAAO8H,MAAMhH,IAAI,CAAC;IAC5C;AAEA,QAAI+G,KAAK9G,QAAA,KAAa+G,MAAM/G,QAAAA,GAAW;AAC9B,aAAA,IAAIN,YAAY,mBAAmB;AACxC,yBAAiB4E,OAAOwC,MAAM;AACtB,gBAAAxC;QACR;AAEA,yBAAiBA,OAAOyC,OAAO;AACvB,gBAAAzC;QACR;MAAA,CACD;IACH;AAEO,WAAA1B;EACT;EAEA,KAAK,SAAS8E,MAAMZ,MAAMC,OAAO;AAC/B,QAAID,KAAKlH,SAAS,cAAcmH,MAAMnH,SAAS,UAAU;AACvD,aAAOmE,aAAa+C,KAAK/G,KAAKsD,IAAI,CAAC0D,MAAMhH,IAAI,CAAC;IAChD;AAEA,QAAI+G,KAAKlH,SAAS,cAAcmH,MAAMnH,SAAS,YAAY;AACzD,aAAO+D,WAAWmD,KAAK/G,KAAK0D,WAAWsD,MAAMhH,IAAI,CAAC;IACpD;AAEA,QAAI+G,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS,UAAU;AACrD,aAAO+D,WAAWmD,KAAK/G,OAAOgH,MAAMhH,IAAI;IAC1C;AAEO,WAAA6C;EACT;EAEA,KAAK+E,gBAAgB,CAAClD,GAAGC,MAAMD,IAAIC,CAAC;EACpC,KAAKiD,gBAAgB,CAAClD,GAAGC,MAAMD,IAAIC,CAAC;EACpC,KAAKiD,gBAAgB,CAAClD,GAAGC,MAAMD,IAAIC,CAAC;EACpC,MAAMiD,gBAAgB,CAAClD,GAAGC,MAAMkD,KAAKC,IAAIpD,GAAGC,CAAC,CAAC;AAChD;AAEA,SAASiD,gBAAgBG,MAAwD;AACxE,SAAA,SAAUhB,MAAMC,OAAO;AAC5B,QAAID,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS,UAAU;AACrD,YAAMM,SAAS4H,KAAKhB,KAAK/G,MAAMgH,MAAMhH,IAAI;AACzC,aAAO4D,WAAWzD,MAAM;IAC1B;AAEO,WAAA0C;EAAA;AAEX;AC9KO,IAAMmF,QAAN,MAAY;;EASjB3I,YACE4I,QACAC,QACA9H,OACA+H,SACAC,QACA;AATF,SAAOC,WAAW;AAUhB,SAAKJ,SAASA;AACd,SAAKC,SAASA;AACd,SAAK9H,QAAQA;AACb,SAAK+H,UAAUA;AACf,SAAKC,SAASA;EAChB;EAEAE,aAAalI,OAAqB;AAChC,QAAI,KAAKiI,UAAU;AACV,aAAA,IAAIL,MAAM,KAAKC,QAAQ,KAAKC,QAAQ9H,OAAO,KAAK+H,SAAS,KAAKC,MAAM;IAC7E;AACO,WAAA,IAAIJ,MAAM,KAAKC,QAAQ,KAAKC,QAAQ9H,OAAO,KAAK+H,SAAS,IAAI;EACtE;EAEAI,aAAanI,OAAqB;AAC1B,UAAAD,SAAS,KAAKmI,aAAalI,KAAK;AACtCD,WAAOkI,WAAW;AACX,WAAAlI;EACT;AACF;ACvBO,SAASqI,SACdC,MACAC,OAE4B;AAAA,MAD5BC,UAAAC,UAAApI,SAAA,KAAAoI,UAAA,CAAA,MAAAC,SAAAD,UAAA,CAAA,IAAoBJ;AAEd,QAAAM,OAAOC,UAAUN,KAAK5I,IAAI;AACzB,SAAAiJ,KAAKL,MAAaC,OAAOC,OAAO;AACzC;AAeA,SAASK,iBACP5I,OACA6F,IAC4B;AAC5B,MAAI,UAAU7F,OAAO;AACZ,WAAAA,MAAM6I,KAAKhD,EAAE;EACtB;AAEA,SAAOA,GAAG7F,KAAK;AACjB;AAEA,IAAM2I,YAAyB;EAC7BG,KAAKC,GAAGT,OAAO;AACb,WAAOA,MAAMtI;EACf;EAEAgJ,WAAW;AAGH,UAAA,IAAIxG,MAAM,gCAAgC;EAClD;EAEAyG,WAAWF,GAAGT,OAAO;AACnB,WAAOA,MAAMR;EACf;EAEAoB,UAAUC,MAAQb,OAAO;AAAA,QAAf;MAACc;IAAI,IAAAD;AACb,WAAO5G,OAAO+F,MAAMT,OAAOuB,IAAI,CAAC;EAClC;EAEAC,QAAQC,OAAOhB,OAAO;AAAA,QAAd;MAACiB;IAAG,IAAAD;AACN,QAAAC,QAAQ,YAAYA,QAAQ,SAAS;AACjC,YAAAvJ,QAAQsI,MAAMP,QAAQwB,GAAG;AAC/B,aAAOvJ,SAASyC;IAClB;AACM,UAAA,IAAID,MAAM,wBAAA1D,OAAwByK,GAAK,CAAA;EAC/C;EAEAC,OAAOC,OAAKnB,OAAO;AAAA,QAAZ;MAACoB;IAAC,IAAAD;AACP,QAAIE,UAAUrB;AACd,aAASnI,IAAI,GAAGA,IAAIuJ,GAAGvJ,KAAK;AACtB,UAAA,CAACwJ,QAAQ3B,QAAQ;AACZ,eAAAvF;MACT;AAEAkH,gBAAUA,QAAQ3B;IACpB;AACA,WAAO2B,QAAQ3J;EACjB;EAEA4J,OAAAA,OAA0BtB,OAAOC,SAAS;AAAA,QAAnC;MAACsB;MAAIlD;MAAMC;IAAK,IAAAkD;AACf,UAAApB,OAAOjC,UAAUoD,EAAE;AACzB,QAAI,CAACnB,MAAM;AACH,YAAA,IAAIlG,MAAM,qBAAA1D,OAAqB+K,EAAI,CAAA;IAC3C;AACM,UAAAE,YAAYxB,QAAQ5B,MAAM2B,KAAK;AAC/B,UAAA0B,aAAazB,QAAQ3B,OAAO0B,KAAK;AAInC,QAAA,UAAUyB,aAAa,UAAUC,YAAY;AAC/C,cAAQ,YAAYtB,KAAK,MAAMqB,WAAW,MAAMC,UAAU,GAAG;IAC/D;AAEO,WAAAtB,KAAKqB,WAAWC,UAAU;EACnC;EAEA,MAAMC,OAAOC,OAA0B5B,OAAOC,SAAS;AAAA,QAA1C;MAAC4B;MAAcC;IAAQ,IAAAF;AAClC,eAAWG,OAAOF,cAAc;AAC9B,YAAMG,UAAU,MAAM/B,QAAQ8B,IAAIE,WAAWjC,KAAK;AAClD,UAAIgC,QAAQ7K,SAAS,aAAa6K,QAAQ1K,SAAS,MAAM;AAChD,eAAA2I,QAAQ8B,IAAIrK,OAAOsI,KAAK;MACjC;IACF;AAEA,QAAI8B,UAAU;AACL,aAAA7B,QAAQ6B,UAAU9B,KAAK;IAChC;AAEO,WAAA7F;EACT;EAEA,MAAM+H,QAAAA,OAA0ClC,OAAOC,SAAS;AAAA,QAAlD;MAACkC;MAAM9D;MAAMC;MAAO8D;IAAc,IAAAC;AAC9C,UAAM3K,QAAQ,MAAMuI,QAAQkC,MAAMnC,KAAK;AACvC,UAAMyB,YAAY,MAAMxB,QAAQ5B,MAAM2B,KAAK;AAC3C,UAAM0B,aAAa,MAAMzB,QAAQ3B,OAAO0B,KAAK;AAEvC,UAAAsC,UAAUzE,eAAe,MAAMnG,MAAMF,IAAAA,GAAO,MAAMiK,UAAUjK,IAAA,CAAK;AACvE,QAAI8K,YAAY,MAAM;AACb,aAAAnI;IACT;AACM,UAAAoI,WAAW1E,eAAe,MAAMnG,MAAMF,IAAAA,GAAO,MAAMkK,WAAWlK,IAAA,CAAK;AACzE,QAAI+K,aAAa,MAAM;AACd,aAAApI;IACT;AAEA,QAAIiI,aAAa;AACf,aAAOE,WAAW,KAAKC,YAAY,IAAInI,aAAaC;IACtD;AAEA,WAAOiI,WAAW,KAAKC,WAAW,IAAInI,aAAaC;EACrD;EAEA,MAAMmI,OAAOC,OAAczC,OAAOC,SAAS;AAAA,QAA9B;MAACkC;MAAMO;IAAI,IAAAD;AACtB,UAAME,YAAY,MAAM1C,QAAQkC,MAAMnC,KAAK;AACvC,QAAA,CAAC2C,UAAUpL,QAAA,GAAW;AACjB,aAAA4C;IACT;AACO,WAAA,IAAIlD,YAAY,mBAAmB;AACxC,uBAAiB2L,QAAQD,WAAW;AAC5B,cAAAE,WAAW7C,MAAMJ,aAAagD,IAAI;AACxC,cAAME,YAAY,MAAM7C,QAAQyC,MAAMG,QAAQ;AAC9C,YAAIC,UAAU3L,SAAS,aAAa2L,UAAUxL,SAAS,MAAM;AACrD,gBAAAsL;QACR;MACF;IAAA,CACD;EACH;EAEA,MAAMG,WAAWC,OAAchD,OAAOC,SAAS;AAAA,QAA9B;MAACkC;MAAMO;IAAI,IAAAM;AAC1B,UAAML,YAAY,MAAM1C,QAAQkC,MAAMnC,KAAK;AACvC,QAAA2C,UAAUxL,SAAS,UAAU;AACxB,aAAAgD;IACT;AAEM,UAAA0I,WAAW7C,MAAMJ,aAAa+C,SAAS;AACtC,WAAA1C,QAAQyC,MAAMG,QAAQ;EAC/B;EAEAI,SAAAA,OAAqCjD,OAAcC,SAAS;AAAA,QAAnD;MAACG;MAAM8C;IAAI,IAAAC;AACX,WAAA/C,KAAK8C,MAAMlD,OAAOC,OAAO;EAClC;EAEA,MAAMmD,aAAAA,QAAmDpD,OAAcC,SAAS;AAAA,QAA7D;MAACG;MAAM+B;MAAMe;IAAI,IAAAG;AAClC,UAAMV,YAAY,MAAM1C,QAAQkC,MAAMnC,KAAK;AAC3C,WAAOI,KAAKuC,WAAWO,MAAMlD,OAAOC,OAAO;EAC7C;EAEA,MAAMqD,gBAAgBC,QAAcvD,OAAOC,SAAS;AAAA,QAA9B;MAACkC;MAAMrB;IAAI,IAAAyC;AAC/B,QAAI7L,QAAQsI,MAAMtI;AAClB,QAAIyK,MAAM;AACAzK,cAAA,MAAMuI,QAAQkC,MAAMnC,KAAK;IACnC;AACI,QAAAtI,MAAMP,SAAS,UAAU;AAC3B,UAAIO,MAAMJ,KAAKkM,eAAe1C,IAAI,GAAG;AACnC,eAAO7G,OAAOvC,MAAMJ,KAAKwJ,IAAI,CAAC;MAChC;IACF;AAEO,WAAA3G;EACT;EAEA,MAAMsJ,cAAcC,QAAe1D,OAAOC,SAAS;AAAA,QAA/B;MAACkC;MAAMwB;IAAK,IAAAD;AAC9B,UAAMf,YAAY,MAAM1C,QAAQkC,MAAMnC,KAAK;AACvC,QAAA,CAAC2C,UAAUpL,QAAA,GAAW;AACjB,aAAA4C;IACT;AAEM,UAAA7C,OAAO,MAAMqL,UAAUnL,IAAI;AACjC,UAAMoM,aAAaD,QAAQ,IAAIA,QAAQrM,KAAKQ,SAAS6L;AAC9C,WAAA1J,OAAO3C,KAAKsM,UAAU,CAAC;EAChC;EAEA,MAAMC,MAAAA,QAAwC7D,OAAOC,SAAS;AAAA,QAAlD;MAACkC;MAAM9D;MAAMC;MAAO8D;IAAc,IAAA0B;AAC5C,UAAMnB,YAAY,MAAM1C,QAAQkC,MAAMnC,KAAK;AAEvC,QAAA,CAAC2C,UAAUpL,QAAA,GAAW;AACjB,aAAA4C;IACT;AAGM,UAAA4J,SAAS,MAAMpB,UAAUnL,IAAI;AAEnC,QAAIwM,UAAU3F;AACd,QAAI4F,WAAW3F;AAGf,QAAI0F,UAAU,GAAG;AACfA,gBAAUD,OAAMjM,SAASkM;IAC3B;AACA,QAAIC,WAAW,GAAG;AAChBA,iBAAWF,OAAMjM,SAASmM;IAC5B;AAGA,QAAI7B,aAAa;AACf6B;IACF;AAEA,QAAID,UAAU,GAAG;AACLA,gBAAA;IACZ;AACA,QAAIC,WAAW,GAAG;AACLA,iBAAA;IACb;AAKA,WAAOhK,OAAO8J,OAAM1G,MAAM2G,SAASC,QAAQ,CAAC;EAC9C;EAEA,MAAMC,MAAMC,QAAQnE,OAAOC,SAAS;AAAA,QAAxB;MAACkC;QAAIgC;AACf,UAAMzM,QAAQ,MAAMuI,QAAQkC,MAAMnC,KAAK;AAEvC,QAAI,CAACA,MAAMR,OAAOjI,QAAA,GAAW;AACpB,aAAA4C;IACT;AAEI,QAAAzC,MAAMP,SAAS,UAAU;AACpB,aAAAgD;IACT;AAEM,UAAAiK,KAAK1M,MAAMJ,KAAKuJ;AAClB,QAAA,OAAOuD,OAAO,UAAU;AACnB,aAAAjK;IACT;AAEiB,qBAAAkK,OAAOrE,MAAMR,QAAQ;AACpC,UAAI6E,IAAIlN,SAAS,YAAYiN,OAAOC,IAAI/M,KAAKgN,KAAK;AACzC,eAAAD;MACT;IACF;AAEO,WAAAlK;EACT;EAEAoK,MAAAC,QAAe;AAAA,QAAT;MAAC9M;QAAQ8M;AACb,WAAOvK,OAAOvC,KAAK;EACrB;EAEA+M,MAAMC,QAAQ1E,OAAOC,SAAS;AAAA,QAAxB;MAACkC;QAAIuC;AACF,WAAAzE,QAAQkC,MAAMnC,KAAK;EAC5B;EAEA,MAAM2E,OAAOC,QAAc5E,OAAOC,SAAS;AAAA,QAA9B;MAAC4E;QAAUD;AACtB,UAAMnN,SAA+B,CAAA;AACrC,eAAWqN,QAAQD,YAAY;AAC7B,YAAME,WAAWD,KAAK3N;AACtB,cAAQ2N,KAAK3N,MAAM;QACjB,KAAK,wBAAwB;AAC3B,gBAAMO,QAAQ,MAAMuI,QAAQ6E,KAAKpN,OAAOsI,KAAK;AAC7CvI,iBAAOqN,KAAKhE,IAAI,IAAI,MAAMpJ,MAAMF,IAAI;AACpC;QACF;QAEA,KAAK,0BAA0B;AAC7B,gBAAMwN,OAAO,MAAM/E,QAAQ6E,KAAK7C,WAAWjC,KAAK;AAChD,cAAIgF,KAAK7N,SAAS,aAAa6N,KAAK1N,SAAS,OAAO;AAClD;UACF;AAEA,gBAAMI,QAAQ,MAAMuI,QAAQ6E,KAAKpN,OAAOsI,KAAK;AACzC,cAAAtI,MAAMP,SAAS,UAAU;AACpBwN,mBAAAM,OAAOxN,QAAQC,MAAMJ,IAAI;UAClC;AACA;QACF;QAEA,KAAK,eAAe;AAClB,gBAAMI,QAAQ,MAAMuI,QAAQ6E,KAAKpN,OAAOsI,KAAK;AACzC,cAAAtI,MAAMP,SAAS,UAAU;AACpBwN,mBAAAM,OAAOxN,QAAQC,MAAMJ,IAAI;UAClC;AACA;QACF;QAEA;AACQ,gBAAA,IAAI4C,MAAM,sBAAA1D,OAAsBuO,QAAU,CAAA;MAAA;IAEtD;AACA,WAAO9K,OAAOxC,MAAM;EACtB;EAEAsC,MAAMmL,QAAYlF,OAAOC,SAAS;AAAA,QAA5B;MAACkF;QAAQD;AACN,WAAA,IAAIjO,YAAY,mBAAmB;AACxC,iBAAW+C,WAAWmL,UAAU;AAC9B,cAAMzN,QAAQ,MAAMuI,QAAQjG,QAAQtC,OAAOsI,KAAK;AAChD,YAAIhG,QAAQoL,SAAS;AACf,cAAA1N,MAAMH,QAAAA,GAAW;AACnB,6BAAiB8N,KAAK3N,OAAO;AACrB,oBAAA2N;YACR;UACF;QAAA,OACK;AACC,gBAAA3N;QACR;MACF;IAAA,CACD;EACH;EAEA4N,QAAQ;AACA,UAAA,IAAIpL,MAAM,6BAA6B;EAC/C;EAEA,MAAMqL,GAAGC,QAAexF,OAAOC,SAAS;AAAA,QAA/B;MAAC5B;MAAMC;IAAK,IAAAkH;AACnB,UAAM/D,YAAY,MAAMxB,QAAQ5B,MAAM2B,KAAK;AAC3C,UAAM0B,aAAa,MAAMzB,QAAQ3B,OAAO0B,KAAK;AAEzC,QAAAyB,UAAUtK,SAAS,WAAW;AAC5B,UAAAsK,UAAUnK,SAAS,MAAM;AACpB,eAAA8C;MACT;IACF;AAEI,QAAAsH,WAAWvK,SAAS,WAAW;AAC7B,UAAAuK,WAAWpK,SAAS,MAAM;AACrB,eAAA8C;MACT;IACF;AAEA,QAAIqH,UAAUtK,SAAS,aAAauK,WAAWvK,SAAS,WAAW;AAC1D,aAAAgD;IACT;AAEO,WAAAE;EACT;EAEA,MAAMoL,IAAIC,QAAe1F,OAAOC,SAAS;AAAA,QAA/B;MAAC5B;MAAMC;IAAK,IAAAoH;AACpB,UAAMjE,YAAY,MAAMxB,QAAQ5B,MAAM2B,KAAK;AAC3C,UAAM0B,aAAa,MAAMzB,QAAQ3B,OAAO0B,KAAK;AAEzC,QAAAyB,UAAUtK,SAAS,WAAW;AAC5B,UAAAsK,UAAUnK,SAAS,OAAO;AACrB,eAAA+C;MACT;IACF;AAEI,QAAAqH,WAAWvK,SAAS,WAAW;AAC7B,UAAAuK,WAAWpK,SAAS,OAAO;AACtB,eAAA+C;MACT;IACF;AAEA,QAAIoH,UAAUtK,SAAS,aAAauK,WAAWvK,SAAS,WAAW;AAC1D,aAAAgD;IACT;AAEO,WAAAC;EACT;EAEA,MAAMuL,IAAIC,QAAQ5F,OAAOC,SAAS;AAAA,QAAxB;MAACkC;QAAIyD;AACb,UAAMlO,QAAQ,MAAMuI,QAAQkC,MAAMnC,KAAK;AACnC,QAAAtI,MAAMP,SAAS,WAAW;AACrB,aAAAgD;IACT;AACO,WAAAzC,MAAMJ,OAAO+C,cAAcD;EACpC;EAEAyL,IAAIC,QAAQ9F,OAAOC,SAAS;AAAA,QAAxB;MAACkC;QAAI2D;AACP,WAAOxF,iBAAiBL,QAAQkC,MAAMnC,KAAK,GAAItI,WAAU;AACnD,UAAAA,MAAMP,SAAS,UAAU;AACpB,eAAAgD;MACT;AACO,aAAAe,WAAW,CAACxD,MAAMJ,IAAI;IAAA,CAC9B;EACH;EAEAyO,IAAIC,QAAQhG,OAAOC,SAAS;AAAA,QAAxB;MAACkC;QAAI6D;AACP,WAAO1F,iBAAiBL,QAAQkC,MAAMnC,KAAK,GAAItI,WAAU;AACnD,UAAAA,MAAMP,SAAS,UAAU;AACpB,eAAAgD;MACT;AACO,aAAAe,WAAWxD,MAAMJ,IAAI;IAAA,CAC7B;EACH;EAEA2O,MAAM;AACG,WAAA9L;EACT;EAEA+L,OAAO;AACE,WAAA/L;EACT;EAEA,MAAMgM,YAAYC,QAAQpG,OAAOC,SAAS;AAAA,QAAxB;MAACkC;QAAIiE;AACrB,UAAM1O,QAAQ,MAAMuI,QAAQkC,MAAMnC,KAAK;AAChC,WAAAtI,MAAMH,QAAQ,IAAIG,QAAQyC;EACnC;EAEA,MAAMkM,IAAIC,QAActG,OAAOC,SAAS;AAAA,QAA9B;MAACkC;MAAMO;IAAI,IAAA4D;AACnB,UAAM5O,QAAQ,MAAMuI,QAAQkC,MAAMnC,KAAK;AACnC,QAAA,CAACtI,MAAMH,QAAA,GAAW;AACb,aAAA4C;IACT;AAEO,WAAA,IAAIlD,YAAY,mBAAmB;AACxC,uBAAiB2L,QAAQlL,OAAO;AACxB,cAAAmL,WAAW7C,MAAMH,aAAa+C,IAAI;AAClC,cAAA,MAAM3C,QAAQyC,MAAMG,QAAQ;MACpC;IAAA,CACD;EACH;EAEA,MAAM0D,QAAQC,QAAcxG,OAAOC,SAAS;AAAA,QAA9B;MAACkC;MAAMO;IAAI,IAAA8D;AACvB,UAAM9O,QAAQ,MAAMuI,QAAQkC,MAAMnC,KAAK;AACnC,QAAA,CAACtI,MAAMH,QAAA,GAAW;AACb,aAAA4C;IACT;AAEO,WAAA,IAAIlD,YAAY,mBAAmB;AACxC,uBAAiB2L,QAAQlL,OAAO;AACxB,cAAAmL,WAAW7C,MAAMH,aAAa+C,IAAI;AACxC,cAAM6D,aAAa,MAAMxG,QAAQyC,MAAMG,QAAQ;AAC3C,YAAA4D,WAAWlP,QAAAA,GAAW;AACxB,2BAAiBmP,SAASD,YAAY;AAC9B,kBAAAC;UACR;QAAA,OACK;AACC,gBAAAD;QACR;MACF;IAAA,CACD;EACH;AACF;AAKO,SAASE,cACdC,MAE4B;AAAA,MAD5BC,UAA2B3G,UAAApI,SAAA,KAAAoI,UAAA,CAAA,MAAAC,SAAAD,UAAA,CAAA,IAAA,CAAA;AAErB,QAAA4G,OAAO7M,OAAO4M,QAAQC,IAAI;AAC1B,QAAAC,UAAU9M,OAAO4M,QAAQE,OAAO;AACtC,QAAMxH,SAA+B;IAAC,GAAGsH,QAAQtH;EAAM;AAEvD,QAAMS,QAAQ,IAAIV,MAChBC,QACAwH,SACAD,MACA;IACEE,WAAWH,QAAQG,aAAa,oBAAIxO,KAAK;IACzCyO,UAAUJ,QAAQI,aAAa,SAAY,OAAOJ,QAAQI;IAC1DC,QAAQL,QAAQK;IAChBC,OAAON,QAAQM,QAAQlN,OAAO4M,QAAQM,KAAK,IAAI;IAC/CC,QAAQP,QAAQO,SAASnN,OAAO4M,QAAQO,MAAM,IAAI;EACpD,GACA,IAAA;AAEK,SAAAtH,SAAS8G,MAAM5G,KAAK;AAC7B;ACzdA,SAASqH,oBAAoBtH,MAAyB;AACpD,UAAQA,KAAK5I,MAAM;IACjB,KAAK;IACL,KAAK;IACL,KAAK;AACI,aAAA;IACT,KAAK;IACL,KAAK;AACI,aAAAkQ,oBAAoBtH,KAAKoC,IAAI;IACtC,KAAK;AACH,cAAQpC,KAAKwB,IAAI;QACf,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;AACH,iBAAO8F,oBAAoBtH,KAAK1B,IAAI,KAAKgJ,oBAAoBtH,KAAKzB,KAAK;QACzE;AACS,iBAAA;MAAA;IAEb;AACS,aAAA;EAAA;AAEb;AAEA,IAAMgJ,cAAc,IAAIhI,MACtB,CAAC,GACDnF,YACAA,YACA;EAAC6M,WAAW,oBAAIxO,KAAK,CAAC;EAAGyO,UAAU;EAAMG,QAAQ;EAAMD,OAAO;AAAI,GAClE,IAAA;AAGK,SAASI,oBAAoBxH,MAA8B;AAC5D,MAAA,CAACsH,oBAAoBtH,IAAI,GAAG;AACvB,WAAA;EACT;AAEA,SAAOyH,iBAAiBzH,IAAI;AAC9B;AAEA,SAASyH,iBAAiBzH,MAAuB;AAC/C,QAAMrI,QAAQoI,SAASC,MAAMuH,aAAaE,gBAAgB;AAC1D,MAAI,UAAU9P,OAAO;AACb,UAAA,IAAIwC,MAAM,sDAAsD;EACxE;AACO,SAAAxC;AACT;ACnDA,eAAsB+P,oBAAoB/P,OAAsC;AAC1E,MAAAA,MAAMP,SAAS,UAAU;AACpB,WAAAuQ,UAAUhQ,MAAMJ,IAAI;EAAA,WAClBI,MAAMH,QAAA,GAAW;AACpB,UAAAoQ,QAAQ,MAAMC,UAAUlQ,KAAK;AAC/B,QAAAiQ,MAAM7P,SAAS,GAAG;AACb,aAAA6P,MAAMlR,KAAK,MAAM;IAC1B;EACF;AAEO,SAAA;AACT;AAEA,eAAemR,UAAUlQ,OAAwD;AAAA,MAA1CD,SAAmByI,UAAApI,SAAA,KAAAoI,UAAA,CAAA,MAAAC,SAAAD,UAAA,CAAA,IAAA,CAAA;AACxD,mBAAiB2H,SAASnQ,OAAO;AAC3B,QAAAmQ,MAAM1Q,SAAS,UAAU;AACrB,YAAAwF,OAAO+K,UAAUG,MAAMvQ,IAAI;AACjC,UAAIqF,SAAS;AAAMlF,eAAOnB,KAAKqG,IAAI;IAAA,WAC1BkL,MAAMtQ,QAAA,GAAW;AACpB,YAAAqQ,UAAUC,OAAOpQ,MAAM;IAC/B;EACF;AAEO,SAAAA;AACT;AAEA,SAASiQ,UAAU/L,KAA6C;AAC1D,MAAA,OAAOA,IAAImM,UAAU;AAAiB,WAAA;AAC1C,QAAMC,WAAWpM,IAAIoM;AACjB,MAAA,CAAChO,MAAMxC,QAAQwQ,QAAQ;AAAU,WAAA;AAErC,MAAItQ,SAAS;AACb,aAAWuQ,SAASD,UAAU;AAC5B,QACEC,SACA,OAAOA,UAAU,YACjB,OAAOA,MAAMF,UAAU,YACvBE,MAAMF,UAAU,UAChB,OAAOE,MAAMrL,SAAS,UACtB;AACAlF,gBAAUuQ,MAAMrL;IAClB;EACF;AACO,SAAAlF;AACT;ACxCA,IAAMwQ,QAAQ;AAEQ,eAAAC,cACpBnI,MACAC,OACAC,SACiB;AACjB,MAAIF,KAAK5I,SAAS,YAAY4I,KAAKwB,OAAO,SAAS;AACjD,WAAO4G,mBAAmBpI,KAAK1B,MAAM0B,KAAKzB,OAAO0B,OAAOC,OAAO;EACjE;AAEA,MAAIF,KAAK5I,SAAS,cAAc4I,KAAKe,SAAS,SAAS;AAC/C,UAAAsH,aAAa,MAAMF,cAAcnI,KAAKmD,KAAK,CAAC,GAAGlD,OAAOC,OAAO;AACnE,UAAMoI,SAAQ,MAAMpI,QAAQF,KAAKmD,KAAK,CAAC,GAAGlD,KAAK;AAC/C,QAAIqI,OAAMlR,SAAS,YAAYiR,aAAa,GAAG;AAC7C,aAAOA,aAAaC,OAAM/Q;IAC5B;AAEO,WAAA;EACT;AAEA,UAAQyI,KAAK5I,MAAM;IACjB,KAAK,MAAM;AACT,YAAMmR,YAAY,MAAMJ,cAAcnI,KAAK1B,MAAM2B,OAAOC,OAAO;AAC/D,YAAMsI,aAAa,MAAML,cAAcnI,KAAKzB,OAAO0B,OAAOC,OAAO;AACjE,aAAOqI,YAAYC;IACrB;IACA,KAAK,OAAO;AACV,YAAMD,YAAY,MAAMJ,cAAcnI,KAAK1B,MAAM2B,OAAOC,OAAO;AAC/D,YAAMsI,aAAa,MAAML,cAAcnI,KAAKzB,OAAO0B,OAAOC,OAAO;AAC7D,UAAAqI,cAAc,KAAKC,eAAe;AAAU,eAAA;AAChD,aAAOD,YAAYC;IACrB;IACA,SAAS;AACP,YAAMC,MAAM,MAAMvI,QAAQF,MAAMC,KAAK;AACrC,aAAOwI,IAAIrR,SAAS,aAAaqR,IAAIlR,SAAS,OAAO,IAAI;IAC3D;EAAA;AAEJ;AAEA,eAAe6Q,mBACb9J,MACAC,OACA0B,OACAC,SACiB;AACjB,QAAMtD,OAAO,MAAMsD,QAAQ5B,MAAM2B,KAAK;AACtC,QAAM9J,UAAU,MAAM+J,QAAQ3B,OAAO0B,KAAK;AAE1C,MAAIzD,SAAkB,CAAA;AACtB,MAAIY,QAAkB,CAAA;AAEhB,QAAAG,WAAWX,MAAOvG,UAAS;AAC/BmG,aAASA,OAAO/F,OAAOkG,cAActG,IAAI,CAAC;EAAA,CAC3C;AAED,QAAM0I,aAAa,MAAMxB,WAAWpH,SAAUE,UAAS;AACrD+G,YAAQA,MAAM3G,OAAOuG,kBAAkB3G,IAAI,CAAC;EAAA,CAC7C;AAED,MAAI,CAAC0I,YAAY;AACR,WAAA;EACT;AAEA,MAAIvC,OAAOzE,WAAW,KAAKqF,MAAMrF,WAAW,GAAG;AACtC,WAAA;EACT;AAEA,MAAI2Q,SAAQ;AAEZ,aAAWtS,MAAMgH,OAAO;AACtB,UAAMuL,OAAOnM,OAAOoM,OAAO,CAACC,GAAG1L,UAAU0L,KAAKzS,GAAGY,KAAKmG,KAAK,IAAI,IAAI,IAAI,CAAC;AAC9DuL,IAAAA,UAAAC,QAAQT,QAAQ,MAAOS,OAAOT;EAC1C;AAEO,SAAAQ;AACT;AC7DA,SAASI,aAAanR,OAAYoR,SAA+B;AACvD,UAAAhN,QAAQpE,KAAK,GAAG;IACtB,KAAK;AACH,iBAAW2N,KAAK3N,OAAO;AACjB,YAAAmR,aAAaxD,GAAGyD,OAAO,GAAG;AACrB,iBAAA;QACT;MACF;AACA;IACF,KAAK;AACH,UAAIpR,MAAMmJ,MAAM;AACP,eAAAiI,QAAQC,IAAIrR,MAAMmJ,IAAI;MAC/B;AACA,iBAAWwE,KAAKV,OAAOqE,OAAOtR,KAAK,GAAG;AAChC,YAAAmR,aAAaxD,GAAGyD,OAAO,GAAG;AACrB,iBAAA;QACT;MACF;AACA;EAAA;AAGG,SAAA;AACT;AAEA,SAASG,UAAUnS,KAAqB;AACtC,MAAIoS,SAAQ;AACZ,WAASrR,IAAI,GAAGA,IAAIf,IAAIgB,QAAQD,KAAK;AAC7B,UAAAsR,OAAOrS,IAAIsS,WAAWvR,CAAC;AACzB,QAAAsR,QAAQ,SAAUA,QAAQ,OAAQ;AAIpC;IACF;AACAD;EACF;AACOA,SAAAA;AACT;AAqBA,IAAMG,UAAuB,CAAA;AAG7BA,QAAQC,WAAW,eAAeA,WAAW;AACrC,QAAA,IAAIpP,MAAM,iBAAiB;AACnC;AAEAmP,QAAQC,SAASC,QAAQ;AAEzBF,QAAQG,WAAW,eAAeA,SAAStG,MAAMlD,OAAOC,SAAS;AAC/D,aAAWwJ,OAAOvG,MAAM;AACtB,UAAMxL,QAAQ,MAAMuI,QAAQwJ,KAAKzJ,KAAK;AAClC,QAAAtI,MAAMP,SAAS,QAAQ;AAClB,aAAAO;IACT;EACF;AACO,SAAAyC;AACT;AAEAkP,QAAQH,QAAQ,eAAeA,MAAMhG,MAAMlD,OAAOC,SAAS;AACzD,QAAMyG,QAAQ,MAAMzG,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACtC,MAAA,CAAC0G,MAAMnP,QAAA,GAAW;AACb,WAAA4C;EACT;AAEA,MAAIR,MAAM;AAEV,mBAAiB8G,KAAKiG,OAAO;AAC3B/M;EACF;AACA,SAAOuB,WAAWvB,GAAG;AACvB;AACA0P,QAAQH,MAAMK,QAAQ;AAEtBF,QAAQK,WAAW,eAAeA,SAASxG,MAAMlD,OAAOC,SAAS;AAC/D,QAAMpE,MAAM,MAAMoE,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAAnE,IAAI1E,SAAS,YAAY;AACpB,WAAA0E;EACT;AACI,MAAAA,IAAI1E,SAAS,UAAU;AAClB,WAAAgD;EACT;AACO,SAAAG,SAASE,aAAaqB,IAAIvE,IAAI;AACvC;AACA+R,QAAQK,SAASH,QAAQ;AAEzBF,QAAQM,UAAU,eAAeA,QAAQzG,MAAMlD,OAAOC,SAAS;AAC7D,QAAMyG,QAAQ,MAAMzG,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACnC,SAAA0G,MAAMvP,SAAS,SAASkD,cAAcD;AAC/C;AACAiP,QAAQM,QAAQJ,QAAQ;AAGxBF,QAAQpC,WAAW,eAAeA,SAAS/D,MAAMlD,OAAO;AAC/C,SAAA3E,WAAW2E,MAAMP,QAAQwH,QAAQ;AAC1C;AACAoC,QAAQpC,SAASsC,QAAQ;AAEzBF,QAAQvR,SAAS,eAAeA,OAAOoL,MAAMlD,OAAOC,SAAS;AAC3D,QAAMyG,QAAQ,MAAMzG,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AAEtC,MAAA0G,MAAMvP,SAAS,UAAU;AAC3B,WAAO+D,WAAW+N,UAAUvC,MAAMpP,IAAI,CAAC;EACzC;AAEI,MAAAoP,MAAMnP,QAAAA,GAAW;AACnB,QAAIoC,MAAM;AAEV,qBAAiB8G,KAAKiG,OAAO;AAC3B/M;IACF;AACA,WAAOuB,WAAWvB,GAAG;EACvB;AAEO,SAAAQ;AACT;AACAkP,QAAQvR,OAAOyR,QAAQ;AAEvBF,QAAQ5N,OAAO,eAAeA,KAAKyH,MAAMlD,OAAOC,SAAS;AACvD,QAAMyG,QAAQ,MAAMzG,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACtC,MAAA0G,MAAMvP,SAAS,UAAU;AACpB,WAAAgD;EACT;AAEA,SAAOqB,SAAS,IAAI9E,KAAKgQ,MAAMpP,IAAI,CAAC;AACtC;AACA+R,QAAQ5N,KAAK8N,QAAQ;AAErBF,QAAQtT,SAAS,eAAeA,OAAOmN,MAAMlD,OAAOC,SAAS;AAC3D,QAAMvI,QAAQ,MAAMuI,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AAC1C,UAAQtI,MAAMP,MAAM;IAClB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACI,aAAAkE,WAAA,GAAA7E,OAAckB,MAAMJ,IAAM,CAAA;IACnC;AACS,aAAA6C;EAAA;AAEb;AACAkP,QAAQtT,OAAOwT,QAAQ;AAEvBF,QAAQO,aAAa,eAAeA,WAAW1G,MAAMlD,OAAOC,SAAS;AAC7D,QAAA6I,UAAA,oBAAce,IAAY;AAChC,aAAWJ,OAAOvG,MAAM;AACtB,UAAMzH,QAAO,MAAMwE,QAAQwJ,KAAKzJ,KAAK;AACjCvE,QAAAA,MAAKtE,SAAS,UAAU;AAClB2R,cAAAlO,IAAIa,MAAKnE,IAAI;IAAA,WACZmE,MAAKlE,QAAA,GAAW;AACzB,uBAAiBqL,QAAQnH,OAAM;AACzB,YAAAmH,KAAKzL,SAAS,UAAU;AAClB2R,kBAAAlO,IAAIgI,KAAKtL,IAAI;QACvB;MACF;IACF;EACF;AAEI,MAAAwR,QAAQgB,SAAS,GAAG;AACf,WAAAzP;EACT;AAEA,QAAM0P,aAAa,MAAM/J,MAAMtI,MAAMF,IAAI;AACzC,SAAOqR,aAAakB,YAAYjB,OAAO,IAAI1O,aAAaC;AAC1D;AACAgP,QAAQO,WAAWL,QAASX,OAAMA,KAAK;AAEvCS,QAAQW,QAAQ,eAAeA,MAAM9G,MAAMlD,OAAOC,SAAS;AACzD,QAAMvI,QAAQ,MAAMuI,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACtC,MAAAtI,MAAMP,SAAS,UAAU;AACpB,WAAAgD;EACT;AAEA,QAAMR,MAAMjC,MAAMJ;AAClB,MAAI2S,OAAO;AAEP,MAAA/G,KAAKpL,WAAW,GAAG;AACrB,UAAMoS,YAAY,MAAMjK,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AAC1C,QAAAkK,UAAU/S,SAAS,YAAY+S,UAAU5S,OAAO,KAAK,CAAC6D,OAAOgP,UAAUD,UAAU5S,IAAI,GAAG;AACnF,aAAA6C;IACT;AACA8P,WAAOC,UAAU5S;EACnB;AAEA,MAAI2S,SAAS,GAAG;AACd,QAAItQ,MAAM,GAAG;AAGX,aAAOuB,WAAW,CAACiE,KAAK6K,MAAM,CAACrQ,GAAG,CAAC;IACrC;AACA,WAAOuB,WAAWiE,KAAK6K,MAAMrQ,GAAG,CAAC;EACnC;AACA,SAAOuB,WAAWC,OAAOxB,IAAIyQ,QAAQH,IAAI,CAAC,CAAC;AAC7C;AACAZ,QAAQW,MAAMT,QAASL,YAAUA,UAAS,KAAKA,UAAS;AAGxDG,QAAQgB,MAAM,eAAeA,IAAInH,MAAMlD,OAAO;AAC5C,SAAO3E,WAAW2E,MAAMP,QAAQuH,UAAUsD,YAAAA,CAAa;AACzD;AACAjB,QAAQgB,IAAId,QAAQ;AAGpBF,QAAQhB,QAAQ,eAAeA,QAAQ;AAE/B,QAAA,IAAInO,MAAM,uBAAuB;AACzC;AAEAmP,QAAQhB,MAAMkB,QAAQ;AAEtB,IAAMxT,UAAsB,CAAA;AAE5BA,QAAOwU,QAAQ,eAAgBrH,MAAMlD,OAAOC,SAAS;AACnD,QAAMvI,QAAQ,MAAMuI,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AAEtC,MAAAtI,MAAMP,SAAS,UAAU;AACpB,WAAAgD;EACT;AAEA,SAAOkB,WAAW3D,MAAMJ,KAAKkT,YAAA,CAAa;AAC5C;AACAzU,QAAOwU,MAAMhB,QAAQ;AAErBxT,QAAO0U,QAAQ,eAAgBvH,MAAMlD,OAAOC,SAAS;AACnD,QAAMvI,QAAQ,MAAMuI,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AAEtC,MAAAtI,MAAMP,SAAS,UAAU;AACpB,WAAAgD;EACT;AAEA,SAAOkB,WAAW3D,MAAMJ,KAAKoT,YAAA,CAAa;AAC5C;AACA3U,QAAO0U,MAAMlB,QAAQ;AAErBxT,QAAOM,QAAQ,eAAgB6M,MAAMlD,OAAOC,SAAS;AACnD,QAAMnJ,MAAM,MAAMmJ,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAAlJ,IAAIK,SAAS,UAAU;AAClB,WAAAgD;EACT;AACA,QAAMwQ,MAAM,MAAM1K,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAA2K,IAAIxT,SAAS,UAAU;AAClB,WAAAgD;EACT;AAEI,MAAArD,IAAIQ,KAAKQ,WAAW,GAAG;AAClB,WAAAmC,OAAO,CAAA,CAAE;EAClB;AACI,MAAA0Q,IAAIrT,KAAKQ,WAAW,GAAG;AAEzB,WAAOmC,OAAOF,MAAM6Q,KAAK9T,IAAIQ,IAAI,CAAC;EACpC;AACA,SAAO2C,OAAOnD,IAAIQ,KAAKjB,MAAMsU,IAAIrT,IAAI,CAAC;AACxC;AACAvB,QAAOM,MAAMkT,QAAQ;AAErBF,QAAQkB,QAAQxU,QAAOwU;AACvBlB,QAAQoB,QAAQ1U,QAAO0U;AAEvB1U,QAAO8U,aAAa,eAAgB3H,MAAMlD,OAAOC,SAAS;AACxD,QAAMnJ,MAAM,MAAMmJ,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAAlJ,IAAIK,SAAS,UAAU;AAClB,WAAAgD;EACT;AAEA,QAAM2Q,SAAS,MAAM7K,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACvC,MAAA8K,OAAO3T,SAAS,UAAU;AACrB,WAAAgD;EACT;AAEA,SAAOrD,IAAIQ,KAAKuT,WAAWC,OAAOxT,IAAI,IAAI8C,aAAaC;AACzD;AACAtE,QAAO8U,WAAWtB,QAAQ;AAE1B,IAAMxF,QAAqB,CAAA;AAE3BA,MAAMtN,OAAO,eAAgByM,MAAMlD,OAAOC,SAAS;AACjD,QAAM8K,MAAM,MAAM9K,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAA,CAAC+K,IAAIxT,QAAA,GAAW;AACX,WAAA4C;EACT;AACA,QAAMwQ,MAAM,MAAM1K,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAA2K,IAAIxT,SAAS,UAAU;AAClB,WAAAgD;EACT;AACA,MAAI6Q,MAAM;AACV,MAAIC,UAAU;AACd,mBAAiBrI,QAAQmI,KAAK;AAC5B,QAAIE,SAAS;AACXD,aAAOL,IAAIrT;IACb;AACA,YAAQsL,KAAKzL,MAAM;MACjB,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;AACH6T,eAAA,GAAAxU,OAAUoM,KAAKtL,IAAA;AACf;MACF;AACS,eAAA6C;IAAA;AAED8Q,cAAA;EACZ;AACA,SAAOhR,OAAO+Q,GAAG;AACnB;AACAjH,MAAMtN,KAAK8S,QAAQ;AAEnBxF,MAAMmH,UAAU,eAAgBhI,MAAMlD,OAAOC,SAAS;AACpD,QAAM8K,MAAM,MAAM9K,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAA,CAAC+K,IAAIxT,QAAA,GAAW;AACX,WAAA4C;EACT;AAEO,SAAA,IAAIlD,YAAY,mBAAmB;AACxC,qBAAiB2L,QAAQmI,KAAK;AACxB,UAAAnI,KAAKzL,SAAS,QAAQ;AAClB,cAAAyL;MACR;IACF;EAAA,CACD;AACH;AACAmB,MAAMmH,QAAQ3B,QAAQ;AAEtBxF,MAAMoH,SAAS,eAAgBjI,MAAMlD,OAAOC,SAAS;AACnD,QAAMvI,QAAQ,MAAMuI,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACtC,MAAA,CAACtI,MAAMH,QAAA,GAAW;AACb,WAAA4C;EACT;AAEO,SAAA,IAAIlD,YAAY,mBAAmB;AAClC,UAAAmU,QAAA,oBAAYvB,IAAI;AACtB,qBAAiBwB,QAAQ3T,OAAO;AAC9B,cAAQ2T,KAAKlU,MAAM;QACjB,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;AACH,cAAI,CAACiU,MAAMrC,IAAIsC,KAAK/T,IAAI,GAAG;AACnB8T,kBAAAxQ,IAAIyQ,KAAK/T,IAAI;AACb,kBAAA+T;UACR;AACA;QACF;AACQ,gBAAAA;MAAA;IAEZ;EAAA,CACD;AACH;AACAtH,MAAMoH,OAAO5B,QAAQ;AAErB,IAAM+B,KAAkB,CAAA;AACxBA,GAAG3O,OAAO,eAAgBuG,MAAMlD,OAAOC,SAAS;AAC9C,QAAMvI,QAAQ,MAAMuI,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,QAAArD,OAAO,MAAM8K,oBAAoB/P,KAAK;AAE5C,MAAIiF,SAAS,MAAM;AACV,WAAAxC;EACT;AAEA,SAAOkB,WAAWsB,IAAI;AACxB;AAEA2O,GAAG3O,KAAK4M,QAAQ;AAEhB,IAAMrC,SAAsB,CAAA;AAE5BA,OAAOqE,YAAY,eAAgBrI,MAAMlD,OAAO;AAC1C,MAAAA,MAAMP,QAAQyH,QAAQ;AACxB,WAAO7L,WAAW2E,MAAMP,QAAQyH,OAAOqE,SAAS;EAClD;AAEO,SAAApR;AACT;AAEA+M,OAAOH,UAAU,eAAgB7D,MAAMlD,OAAO;AACxC,MAAAA,MAAMP,QAAQyH,QAAQ;AACxB,WAAO7L,WAAW2E,MAAMP,QAAQyH,OAAOH,OAAO;EAChD;AAEO,SAAA5M;AACT;AASO,IAAMqR,gBAAgE,CAAA;AAE7EA,cAAcC,QAAQ,eAAeA,MAAMtJ,MAAMe,MAAMlD,OAAOC,SAAS;AAG/D,QAAA;AAEF,MAAA,CAACkC,KAAK5K,QAAA,GAAW;AACZ,WAAA4C;EACT;AAEA,QAAMuR,UAAU,CAAA;AAChB,QAAMC,aAAuB,CAAA;AAC7B,MAAIvK,IAAI;AAER,WAASwK,UAAU1I,MAAM;AACvB,QAAI2I,YAAY;AAEZ,QAAAD,OAAOzU,SAAS,QAAQ;AACd0U,kBAAA;AACZD,eAASA,OAAOzJ;IAAA,WACPyJ,OAAOzU,SAAS,OAAO;AAChCyU,eAASA,OAAOzJ;IAClB;AAEAuJ,YAAQpV,KAAKsV,MAAM;AACnBD,eAAWrV,KAAKuV,SAAS;AACzBzK;EACF;AAEA,QAAM0K,MAAM,CAAA;AACZ,MAAIC,MAAM;AAEV,mBAAiBrU,SAASyK,MAAM;AACxB,UAAAU,WAAW7C,MAAMJ,aAAalI,KAAK;AACzC,UAAMsU,QAAQ,CAAC,MAAMtU,MAAMF,IAAA,GAAOuU,GAAG;AACrC,aAASlU,IAAI,GAAGA,IAAIuJ,GAAGvJ,KAAK;AAC1B,YAAMJ,SAAS,MAAMwI,QAAQyL,QAAQ7T,CAAC,GAAGgL,QAAQ;AACjDmJ,YAAM1V,KAAK,MAAMmB,OAAOD,IAAA,CAAK;IAC/B;AACAsU,QAAIxV,KAAK0V,KAAK;AACdD;EACF;AAEID,MAAAG,KAAK,CAACC,QAAQC,WAAW;AAC3B,aAAStU,IAAI,GAAGA,IAAIuJ,GAAGvJ,KAAK;AACtB,UAAA+Q,IAAI5K,aAAakO,OAAOrU,IAAI,CAAC,GAAGsU,OAAOtU,IAAI,CAAC,CAAC;AAC7C,UAAA8T,WAAW9T,CAAC,MAAM,QAAQ;AAC5B+Q,YAAI,CAACA;MACP;AACA,UAAIA,MAAM,GAAG;AACJ,eAAAA;MACT;IACF;AAEA,WAAOsD,OAAO,CAAC,IAAIC,OAAO,CAAC;EAAA,CAC5B;AAEM,SAAAlS,OAAO6R,IAAI9O,IAAKqI,OAAMA,EAAE,CAAC,CAAC,CAAC;AACpC;AACAmG,cAAcC,MAAMlC,QAASL,YAAUA,UAAS;AAGhDsC,cAAc/C,QAAQ,eAAeA,MAAMtG,MAAMe,MAAMlD,OAAOC,SAAS;AACjE,MAAA,CAACkC,KAAK5K,QAAQ;AAAU,WAAA4C;AAG5B,QAAMiS,UAAsB,CAAA;AAC5B,QAAMC,SAAiC,CAAA;AAEvC,mBAAiB3U,SAASyK,MAAM;AAC1B,QAAAzK,MAAMP,SAAS,UAAU;AAC3BiV,cAAQ9V,KAAK,MAAMoB,MAAMF,IAAA,CAAK;AAC9B;IACF;AAEM,UAAAqL,WAAW7C,MAAMJ,aAAalI,KAAK;AACrC,QAAA4U,aAAa,OAAO5U,MAAMJ,KAAKiV,WAAW,WAAW7U,MAAMJ,KAAKiV,SAAS;AAE7E,eAAW9C,OAAOvG,MAAM;AACtBoJ,oBAAc,MAAMpE,cAAcuB,KAAK5G,UAAU5C,OAAO;IAC1D;AAEM,UAAAuM,YAAY7H,OAAOM,OAAO,CAAC,GAAGvN,MAAMJ,MAAM;MAACiV,QAAQD;IAAA,CAAW;AACpED,WAAO/V,KAAKkW,SAAS;EACvB;AAEAH,SAAOJ,KAAK,CAACjQ,GAAGC,MAAMA,EAAEsQ,SAASvQ,EAAEuQ,MAAM;AACzC,SAAOtS,OAAOoS,MAAM;AACtB;AAEAb,cAAc/C,MAAMc,QAASL,YAAUA,UAAS;AAIhD,IAAMuD,QAAqB,CAAA;AAE3BA,MAAMC,YAAY,eAAgBxJ,MAAMlD,OAAO;AACvC,QAAA2M,YAAY3M,MAAMP,QAAQ2H,WAAW;AACrC,QAAAwF,WAAW5M,MAAMP,QAAQ0H,UAAU;AAEzC,MAAIwF,aAAaC,UAAU;AACzB,WAAOvR,WAAW,QAAQ;EAC5B;AAEA,MAAIuR,UAAU;AACZ,WAAOvR,WAAW,QAAQ;EAC5B;AAEA,MAAIsR,WAAW;AACb,WAAOtR,WAAW,QAAQ;EAC5B;AAEO,SAAAlB;AACT;AAEAsS,MAAMI,aAAa,MAAM;AACjB,QAAA,IAAI3S,MAAM,iBAAiB;AACnC;AACAuS,MAAMI,WAAWtD,QAAQ;AACzBkD,MAAMI,WAAWC,OAAO;AAExBL,MAAMM,cAAc,MAAM;AAClB,QAAA,IAAI7S,MAAM,iBAAiB;AACnC;AACAuS,MAAMM,YAAYxD,QAAQ;AAC1BkD,MAAMM,YAAYD,OAAO;AAEzB,IAAME,OAAoB,CAAA;AAC1BA,KAAKH,aAAa,MAAM;AAChB,QAAA,IAAI3S,MAAM,iBAAiB;AACnC;AACA8S,KAAKH,WAAWtD,QAAQ;AAExByD,KAAKD,cAAc,MAAM;AACjB,QAAA,IAAI7S,MAAM,iBAAiB;AACnC;AACA8S,KAAKD,YAAYxD,QAAQ;AAEzB,IAAM0D,OAAoB,CAAA;AAC1BA,KAAKC,MAAM,eAAgBhK,MAAMlD,OAAOC,SAAS;AAC/C,QAAM8K,MAAM,MAAM9K,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAA,CAAC+K,IAAIxT,QAAA,GAAW;AACX,WAAA4C;EACT;AAEI,MAAAiH;AACJ,mBAAiBwB,QAAQmI,KAAK;AAC5B,QAAInI,KAAKzL,SAAS;AAAQ;AACtB,QAAAyL,KAAKzL,SAAS,UAAU;AACnB,aAAAgD;IACT;AACA,QAAIiH,MAAM,UAAawB,KAAKtL,OAAO8J,GAAG;AACpCA,UAAIwB,KAAKtL;IACX;EACF;AACA,SAAO2C,OAAOmH,CAAC;AACjB;AACA6L,KAAKC,IAAI3D,QAAQ;AAEjB0D,KAAKE,MAAM,eAAgBjK,MAAMlD,OAAOC,SAAS;AAC/C,QAAM8K,MAAM,MAAM9K,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAA,CAAC+K,IAAIxT,QAAA,GAAW;AACX,WAAA4C;EACT;AAEI,MAAAiH;AACJ,mBAAiBwB,QAAQmI,KAAK;AAC5B,QAAInI,KAAKzL,SAAS;AAAQ;AACtB,QAAAyL,KAAKzL,SAAS,UAAU;AACnB,aAAAgD;IACT;AACA,QAAIiH,MAAM,UAAawB,KAAKtL,OAAO8J,GAAG;AACpCA,UAAIwB,KAAKtL;IACX;EACF;AACA,SAAO2C,OAAOmH,CAAC;AACjB;AACA6L,KAAKE,IAAI5D,QAAQ;AAEjB0D,KAAKG,MAAM,eAAgBlK,MAAMlD,OAAOC,SAAS;AAC/C,QAAM8K,MAAM,MAAM9K,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAA,CAAC+K,IAAIxT,QAAA,GAAW;AACX,WAAA4C;EACT;AAEA,MAAIiH,IAAI;AACR,mBAAiBwB,QAAQmI,KAAK;AAC5B,QAAInI,KAAKzL,SAAS;AAAQ;AACtB,QAAAyL,KAAKzL,SAAS,UAAU;AACnB,aAAAgD;IACT;AACAiH,SAAKwB,KAAKtL;EACZ;AACA,SAAO2C,OAAOmH,CAAC;AACjB;AACA6L,KAAKG,IAAI7D,QAAQ;AAEjB0D,KAAKI,MAAM,eAAgBnK,MAAMlD,OAAOC,SAAS;AAC/C,QAAM8K,MAAM,MAAM9K,QAAQiD,KAAK,CAAC,GAAGlD,KAAK;AACpC,MAAA,CAAC+K,IAAIxT,QAAA,GAAW;AACX,WAAA4C;EACT;AAEA,MAAIiH,IAAI;AACR,MAAIwH,IAAI;AACR,mBAAiBhG,QAAQmI,KAAK;AAC5B,QAAInI,KAAKzL,SAAS;AAAQ;AACtB,QAAAyL,KAAKzL,SAAS,UAAU;AACnB,aAAAgD;IACT;AACAiH,SAAKwB,KAAKtL;AACVsR;EACF;AACA,MAAIA,MAAM,GAAG;AACJ,WAAAzO;EACT;AACO,SAAAF,OAAOmH,IAAIwH,CAAC;AACrB;AACAqE,KAAKI,IAAI9D,QAAQ;AAEV,IAAM+D,aAA2B;EACtCC,QAAQlE;EACRtT,QAAAA;EACAgO;EACAuH;EACAmB;EACAO;EACA9F;EACA+F;AACF;ACtlBO,IAAMO,gBAAN,MAAoB;EAOzB7W,YAAYZ,SAAgB0X,OAAeC,cAA4B;AAF1D,SAAAC,aAAA;AAGX,SAAK5X,SAASA;AACd,SAAK0X,QAAQA;AACb,SAAK9J,QAAQ;AACb,SAAK+J,eAAeA;EACtB;EAEAE,UAA0B;AAAA,QAAlBC,MAAAA,UAAAA,SAAAA,KAAAA,UAAAA,CAAAA,MAAAA,SAAAA,UAAAA,CAAAA,IAAM;AACZ,WAAO,KAAKlK,QAAQkK,MAAM,KAAKJ,MAAM3V;EACvC;EAEAgW,UAAuB;AAAA,QAAfD,MAAAA,UAAAA,SAAAA,KAAAA,UAAAA,CAAAA,MAAAA,SAAAA,UAAAA,CAAAA,IAAM;AACZ,WAAO,KAAKJ,MAAM,KAAK9J,QAAQkK,GAAG;EACpC;EAEAE,QAAc;AACZ,SAAKpK,SAAS;EAChB;EAEAqK,QAAWC,SAA4B;AACrC,UAAMC,OAAO,KAAKT,MAAM,KAAK9J,KAAK;AAClC,SAAKoK,MAAM;AACL,UAAA3N,OAAO6N,QAAQC,KAAKpN,IAAI;AAC9B,QAAI,CAACV,MAAM;AACT,YAAM,IAAIlG,MAAA,oBAAA1D,OAA0B0X,KAAKpN,IAAM,CAAA;IACjD;AACA,WAAOV,KAAK+N,KAAKF,SAAS,MAAMC,IAAI;EACtC;EAEAE,gBAAwB;AACtB,SAAKL,MAAM;AACX,WAAO,KAAKM,iBAAiB;EAC/B;EAEAA,mBAA2B;AACzB,UAAMC,OAAO,KAAKb,MAAM,KAAK9J,QAAQ,CAAC;AACtC,UAAM4K,OAAO,KAAKd,MAAM,KAAK9J,KAAK;AAClC,SAAKoK,MAAM;AACX,WAAO,KAAKhY,OAAOsH,MAAMiR,KAAKE,UAAUD,KAAKC,QAAQ;EACvD;EAEAnR,MAAMoR,KAAqB;AACzB,UAAMZ,MAAM,KAAKJ,MAAM,KAAK9J,KAAK,EAAE6K;AACnC,WAAO,KAAKzY,OAAOsH,MAAMwQ,KAAKA,MAAMY,GAAG;EACzC;AACF;AC5GA,IAAMC,KAAK;AACX,IAAMC,MAAM;AACZ,IAAMC,QAAQ;AAGd,IAAMC,YAAY;AAClB,IAAMC,UAAU;AAChB,IAAMC,WAAW;AACjB,IAAMC,YAAY;AAClB,IAAMC,aAAa;AACnB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AAGjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AAEjB,SAASC,QAAM7Y,KAAK;AAClB,MAAI+W,MAAM;AACJA,QAAA+B,OAAO9Y,KAAK+W,GAAG;AACrB,MAAIpW,SAASoY,UAAU/Y,KAAK+W,KAAK,CAAC;AAClC,MAAIpW,OAAON,SAAS;AAAgB,WAAAM;AAC9BoW,QAAA+B,OAAO9Y,KAAKW,OAAO+W,QAAQ;AAC7B,MAAAX,QAAQ/W,IAAIgB,QAAQ;AACtB,QAAIL,OAAOqY,cAAc;AACvBjC,YAAMpW,OAAOqY,eAAe;IAC9B;AACA,WAAO;MAAC3Y,MAAM;MAASqX,UAAUX;IAAG;EACtC;AACA,SAAOpW,OAAO+W;AACd,SAAO/W,OAAOqY;AACP,SAAArY;AACT;AAEA,SAASoY,UAAU/Y,KAAK+W,KAAKkC,OAAO;AAkBlC,MAAIC,WAAWnC;AACX,MAAA3Q,QAAQpG,IAAI+W,GAAG;AACf,MAAAJ;AAEJ,UAAQvQ,OAAO;IACb,KAAK,KAAK;AACJ,UAAA+S,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+W,MAAM,CAAC,GAAG2B,QAAQ;AACvD,UAAIS,IAAI9Y,SAAS;AAAgB,eAAA8Y;AACzBxC,cAAA,CAAC;QAAC3M,MAAM;QAAO0N,UAAUwB;MAAS,CAAA,EAAExZ,OAAOyZ,IAAIxC,KAAK;AAC5DI,YAAMoC,IAAIzB;AACV;IACF;IACA,KAAK,KAAK;AACJ,UAAAyB,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+W,MAAM,CAAC,GAAG6B,QAAQ;AACvD,UAAIO,IAAI9Y,SAAS;AAAgB,eAAA8Y;AACzBxC,cAAA,CAAC;QAAC3M,MAAM;QAAO0N,UAAUwB;MAAS,CAAA,EAAExZ,OAAOyZ,IAAIxC,KAAK;AAC5DI,YAAMoC,IAAIzB;AACV;IACF;IACA,KAAK,KAAK;AACJ,UAAAyB,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+W,MAAM,CAAC,GAAG,CAAC;AAChD,UAAIoC,IAAI9Y,SAAS;AAAgB,eAAA8Y;AAC3BpC,YAAA+B,OAAO9Y,KAAKmZ,IAAIzB,QAAQ;AACtB,cAAA1X,IAAI+W,GAAG,GAAG;QAChB,KAAK,KAAK;AAEAJ,kBAAA,CAAC;YAAC3M,MAAM;YAAS0N,UAAUwB;UAAS,CAAA,EAAExZ,OAAOyZ,IAAIxC,KAAK;AACxDI,gBAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;AACzB,iBAAO,MAAM;AACLoC,kBAAAJ,UAAU/Y,KAAK+W,KAAK,CAAC;AAC3B,gBAAIoC,IAAI9Y,SAAS;AAAgB,qBAAA8Y;AAC3BpC,kBAAA+B,OAAO9Y,KAAKmZ,IAAIzB,QAAQ;AAC1B,gBAAA1X,IAAI+W,GAAG,MAAM;AAAK;AAChBA,kBAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;UAC3B;AACI,cAAA/W,IAAI+W,GAAG,MAAM;AAAK,mBAAO;cAAC1W,MAAM;cAASqX,UAAUX;YAAG;AAC1DA;AACAJ,gBAAMnX,KAAK;YAACwK,MAAM;YAAa0N,UAAUX;WAAI;AAC7C;QACF;QACA,KAAK,KAAK;AACRA;AACQJ,kBAAA,CAAC;YAAC3M,MAAM;YAAS0N,UAAUwB;UAAS,CAAA,EAAExZ,OAAOyZ,IAAIxC,KAAK;AAC9D;QACF;QACA;AACE,iBAAO;YAACtW,MAAM;YAASqX,UAAUX;UAAG;MAAA;AAExC;IACF;IACA,KAAK,KAAK;AACJ,UAAAoC,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+W,MAAM,CAAC,GAAG4B,QAAQ;AACvD,UAAIQ,IAAI9Y,SAAS;AAAgB,eAAA8Y;AACzBxC,cAAA,CAAC;QAAC3M,MAAM;QAAO0N,UAAUwB;MAAS,CAAA,EAAExZ,OAAOyZ,IAAIxC,KAAK;AAC5DI,YAAMoC,IAAIzB;AACV;IACF;IACA,KAAK,KAAK;AACJ,UAAA/W,SAASyY,YAAYpZ,KAAK+W,GAAG;AACjC,UAAIpW,OAAON,SAAS;AAAgB,eAAAM;AACpCgW,cAAQhW,OAAOgW;AACfI,YAAMpW,OAAO+W;AACb;IACF;IACA,KAAK;AACHf,cAAQ,CAAC;QAAC3M,MAAM;QAAS0N,UAAUX;OAAI;AACjCA,YAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;AAErB,UAAA/W,IAAI+W,GAAG,MAAM,KAAK;AACpB,eAAO,MAAM;AACX,cAAI/W,IAAIuG,MAAMwQ,KAAKA,MAAM,CAAC,MAAM,OAAO;AACrCJ,kBAAMnX,KAAK;cAACwK,MAAM;cAAe0N,UAAUX;aAAI;AACzCA,kBAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;UAC3B;AAEA,cAAIrF,MAAMqH,UAAU/Y,KAAK+W,KAAK,CAAC;AAC/B,cAAIrF,IAAIrR,SAAS;AAAgB,mBAAAqR;AACzBiF,kBAAAA,MAAMjX,OAAOgS,IAAIiF,KAAK;AAC9BI,gBAAMrF,IAAIgG;AACJX,gBAAA+B,OAAO9Y,KAAK+W,GAAG;AACjB,cAAA/W,IAAI+W,GAAG,MAAM;AAAK;AAChBA,gBAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;AACrB,cAAA/W,IAAI+W,GAAG,MAAM;AAAK;QACxB;MACF;AAEI,UAAA/W,IAAI+W,GAAG,MAAM,KAAK;AACpBA;AACAJ,cAAMnX,KAAK;UAACwK,MAAM;UAAa0N,UAAUX;SAAI;MAAA,OACxC;AACL,eAAO;UAAC1W,MAAM;UAASqX,UAAUX;QAAG;MACtC;AAEA;IACF,KAAK;IACL,KAAK,KAAK;AACJ,UAAApW,SAAS0Y,YAAYrZ,KAAK+W,GAAG;AACjC,UAAIpW,OAAON,SAAS;AAAgB,eAAAM;AACpCgW,cAAQhW,OAAOgW;AACfI,YAAMpW,OAAO+W;AACb;IACF;IACA,KAAK,KAAK;AACRX;AACAJ,cAAQ,CAAA;AACD,aAAA3W,IAAI+W,GAAG,MAAM,OAAO/W,IAAI+W,MAAM,CAAC,MAAM,KAAK;AAC/CJ,cAAMnX,KAAK;UAACwK,MAAM;UAAa0N,UAAUwB;SAAS;AAC3CnC,eAAA;MACT;AACAJ,YAAMnX,KAAK;QAACwK,MAAM;QAAU0N,UAAUwB;OAAS;AAC/C;IACF;IACA,KAAK;AACHvC,cAAQ,CAAC;QAAC3M,MAAM;QAAQ0N,UAAUwB;OAAS;AAC3CnC;AACA;IACF,KAAK;AACHJ,cAAQ,CAAC;QAAC3M,MAAM;QAAc0N,UAAUwB;OAAS;AACjDnC;AACA;IACF,KAAK,KAAK;AACR,UAAIuC,WAAWC,WAAWvZ,KAAK+W,MAAM,GAAGe,KAAK;AAC7C,UAAIwB,UAAU;AACZvC,eAAO,IAAIuC;AACH3C,gBAAA,CACN;UAAC3M,MAAM;UAAS0N,UAAUwB;QAAQ,GAClC;UAAClP,MAAM;UAAS0N,UAAUwB,WAAW;QAAC,GACtC;UAAClP,MAAM;UAAa0N,UAAUX;QAAG,CAAA;MAErC;AACA;IACF;IACA,SAAS;AACP,UAAIyC,SAASD,WAAWvZ,KAAK+W,KAAKc,GAAG;AACrC,UAAI2B,QAAQ;AACHzC,eAAAyC;AACP,YAAIxP,OAAO;AAEP,YAAAhK,IAAI+W,GAAG,MAAM,KAAK;AACpB,cAAI0C,UAAUF,WAAWvZ,KAAK+W,MAAM,GAAGc,GAAG;AAC1C,cAAI4B,SAAS;AACJzP,mBAAA;AACP+M,mBAAO,IAAI0C;UACb;QACF;AAEA,YAAIzZ,IAAI+W,GAAG,MAAM,OAAO/W,IAAI+W,GAAG,MAAM,KAAK;AACjC/M,iBAAA;AACP+M;AACA,cAAI/W,IAAI+W,GAAG,MAAM,OAAO/W,IAAI+W,GAAG,MAAM,KAAK;AACxCA;UACF;AACA,cAAI2C,SAASH,WAAWvZ,KAAK+W,KAAKc,GAAG;AACrC,cAAI,CAAC6B;AAAQ,mBAAO;cAACrZ,MAAM;cAASqX,UAAUX;YAAG;AAC1CA,iBAAA2C;QACT;AAEQ/C,gBAAA,CACN;UAAC3M;UAAM0N,UAAUwB;QAAQ,GACzB;UAAClP,MAAMA,OAAO;UAAQ0N,UAAUX;QAAG,CAAA;AAGrC;MACF;AAEA,UAAIuC,WAAWC,WAAWvZ,KAAK+W,KAAKe,KAAK;AACzC,UAAIwB,UAAU;AACLvC,eAAAuC;AACC,gBAAAtZ,IAAI+W,GAAG,GAAG;UAChB,KAAK;UACL,KAAK,KAAK;AACR,gBAAIpW,SAASgZ,cAAc3Z,KAAKkZ,UAAUnC,GAAG;AAC7C,gBAAIpW,OAAON,SAAS;AAAgB,qBAAAM;AACpCgW,oBAAQhW,OAAOgW;AACfI,kBAAMpW,OAAO+W;AACb;UACF;UACA,SAAS;AACCf,oBAAA,CACN;cAAC3M,MAAM;cAAa0N,UAAUwB;YAAQ,GACtC;cAAClP,MAAM;cAAS0N,UAAUwB;YAAQ,GAClC;cAAClP,MAAM;cAAa0N,UAAUX;YAAG,CAAA;UAErC;QAAA;AAGF;MACF;IACF;EAAA;AAGF,MAAI,CAACJ,OAAO;AACV,WAAO;MAACtW,MAAM;MAASqX,UAAUX;IAAG;EACtC;AAEA,MAAI6C,WAAW;AACX,MAAAC;AAEJC;AAAM,WAAO,MAAM;AACb,UAAAC,WAAWjB,OAAO9Y,KAAK+W,GAAG;AAC1B,UAAAgD,aAAa/Z,IAAIgB,QAAQ;AACrB+V,cAAAgD;AACN;MACF;AAEOF,aAAAG,eAAeha,KAAK+Z,QAAQ;AAC/B,UAAAF,KAAKxZ,SAAS,WAAW;AAC3BsW,cAAMsD,QAAQ;UAACjQ,MAAM;UAAY0N,UAAUwB;SAAS;AAC7C,eAAAW,KAAKxZ,SAAS,WAAW;AACtBsW,kBAAAA,MAAMjX,OAAOma,KAAKlD,KAAK;AAC/BI,gBAAM8C,KAAKnC;AACXmC,iBAAOG,eAAeha,KAAK8Y,OAAO9Y,KAAK+W,GAAG,CAAC;QAC7C;AACAJ,cAAMnX,KAAK;UAACwK,MAAM;UAAiB0N,UAAUX;SAAI;AACjD;MACF;AAEI3Q,UAAAA,SAAQpG,IAAI+Z,QAAQ;AACxB,cAAQ3T,QAAO;QACb,KAAK,KAAK;AACJ,cAAA8T,YAAYla,IAAI+Z,WAAW,CAAC;AAChC,kBAAQG,WAAW;YACjB,KAAK,KAAK;AAEJ,kBAAAjB,QAAQlB,aAAa6B,YAAY7B;AAAiB,sBAAA+B;AAClD,kBAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAGhC,SAAS;AAC7D,kBAAIoB,IAAI9Y,SAAS;AAAgB,uBAAA8Y;AACzBxC,sBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BA,oBAAMsD,QAAQ;gBAACjQ,MAAM;gBAAQ0N,UAAUwB;eAAS;AAChDnC,oBAAMoC,IAAIzB;AACCkC,yBAAA7B;AACX;YACF;YACA,KAAK,KAAK;AAEJ,kBAAAkB,QAAQf,aAAa0B,YAAY1B;AAAiB,sBAAA4B;AAClD,kBAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAG,CAAC;AACrD,kBAAIZ,IAAI9Y,SAAS;AAAgB,uBAAA8Y;AACjCxC,oBAAMsD,QAAQ;gBAACjQ,MAAM;gBAAQ0N,UAAUwB;eAAS;AAChDvC,oBAAMnX,KAAK;gBAACwK,MAAM;gBAAM0N,UAAUqC;cAAA,GAAW;gBAAC/P,MAAM;gBAAU0N,UAAUqC,WAAW;cAAE,CAAA;AAC7EpD,sBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BI,oBAAMoC,IAAIzB;AACCkC,yBAAA1B;AACX;YACF;YACA;AACQ,oBAAA4B;UAAA;AAEV;QACF;QACA,KAAK,KAAK;AACJ,cAAAb,QAAQb,YAAYwB,WAAWxB;AAAgB,kBAAA0B;AAC/C,cAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAG3B,WAAW,CAAC;AAChE,cAAIe,IAAI9Y,SAAS;AAAgB,mBAAA8Y;AACzBxC,kBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACjQ,MAAM;YAAO0N,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAAxB;AACX;QACF;QACA,KAAK,KAAK;AACJ,cAAAa,QAAQZ,YAAYuB,WAAWvB;AAAgB,kBAAAyB;AAC/C,cAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAG1B,WAAW,CAAC;AAChE,cAAIc,IAAI9Y,SAAS;AAAgB,mBAAA8Y;AACzBxC,kBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACjQ,MAAM;YAAO0N,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAAvB;AACX;QACF;QACA,KAAK,KAAK;AACR,cAAIrY,IAAI+Z,WAAW,CAAC,MAAM,KAAK;AAEzB,gBAAAd,QAAQR,YAAYmB,YAAYnB;AAAgB,oBAAAqB;AAChDX,gBAAAA,OAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAGtB,QAAQ;AAC5D,gBAAIU,KAAI9Y,SAAS;AAAgB8Y,qBAAAA;AACzBxC,oBAAAA,MAAMjX,OAAOyZ,KAAIxC,KAAK;AAC9BA,kBAAMsD,QAAQ;cAACjQ,MAAM;cAAO0N,UAAUwB;aAAS;AAC/CnC,kBAAMoC,KAAIzB;AACCkC,uBAAAnB;AACX;UACF;AAGI,cAAAQ,QAAQX,YAAYsB,WAAWtB;AAAgB,kBAAAwB;AAC/C,cAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAGzB,WAAW,CAAC;AAChE,cAAIa,IAAI9Y,SAAS;AAAgB,mBAAA8Y;AACzBxC,kBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACjQ,MAAM;YAAO0N,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAAtB;AACX;QACF;QACA,KAAK,KAAK;AACJ,cAAAW,QAAQV,YAAYqB,WAAWrB;AAAgB,kBAAAuB;AAC/C,cAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAGxB,WAAW,CAAC;AAChE,cAAIY,IAAI9Y,SAAS;AAAgB,mBAAA8Y;AACzBxC,kBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACjQ,MAAM;YAAO0N,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAArB;AACX;QACF;QACA,KAAK,KAAK;AACJ,cAAAU,QAAQT,YAAYoB,WAAWpB;AAAgB,kBAAAsB;AAC/C,cAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAGvB,WAAW,CAAC;AAChE,cAAIW,IAAI9Y,SAAS;AAAgB,mBAAA8Y;AACzBxC,kBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACjQ,MAAM;YAAO0N,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAApB;AACX;QACF;QACA,KAAK;QACL,KAAK,KAAK;AACJ,cAAAS,QAAQf,aAAa0B,YAAY1B;AAAiB,kBAAA4B;AACtD,cAAIK,UAAUJ,WAAW;AACrB,cAAA/Z,IAAIma,OAAO,MAAM,KAAK;AACxBA;UACF;AACI,cAAAhB,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAKma,OAAO,GAAGjC,YAAY,CAAC;AAC5D,cAAIiB,IAAI9Y,SAAS;AAAgB,mBAAA8Y;AACjCxC,gBAAMsD,QAAQ;YAACjQ,MAAM;YAAQ0N,UAAUwB;WAAS;AAChDvC,gBAAMnX,KAAK;YAACwK,MAAM;YAAM0N,UAAUqC;aAAW;YAAC/P,MAAM;YAAU0N,UAAUyC;UAAQ,CAAA;AACxExD,kBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BI,gBAAMoC,IAAIzB;AACCkC,qBAAA1B;AACX;QACF;QACA,KAAK,KAAK;AACR,cAAIlY,IAAI+Z,WAAW,CAAC,MAAM,KAAK;AAEzB,gBAAAd,QAAQjB,WAAW4B,WAAW5B;AAAe,oBAAA8B;AAC7C,gBAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAG/B,UAAU,CAAC;AAC/D,gBAAImB,IAAI9Y,SAAS;AAAgB,qBAAA8Y;AACzBxC,oBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BA,kBAAMsD,QAAQ;cAACjQ,MAAM;cAAM0N,UAAUwB;aAAS;AAC9CnC,kBAAMoC,IAAIzB;AACCkC,uBAAA5B;UAAA,OACN;AACD,gBAAAiB,QAAQ,MAAMW,WAAW;AAAU,oBAAAE;AAEvC,gBAAIM,WAAWtB,OAAO9Y,KAAK+Z,WAAW,CAAC;AACvC,gBAAIT,WAAWC,WAAWvZ,KAAKoa,UAAUtC,KAAK;AAC9C,gBAAI,CAACwB;AAAU,qBAAO;gBAACjZ,MAAM;gBAASqX,UAAU0C;cAAQ;AACxDrD,kBAAMqD,WAAWd;AACjB,gBAAItZ,IAAI+W,GAAG,MAAM,OAAO/W,IAAI+W,GAAG,MAAM,KAAK;AACxC,kBAAIpW,SAASgZ,cAAc3Z,KAAKoa,UAAUrD,GAAG;AAC7C,kBAAIpW,OAAON,SAAS;AAAgB,uBAAAM;AAC5BgW,sBAAAA,MAAMjX,OAAOiB,OAAOgW,KAAK;AACjCA,oBAAMsD,QAAQ;gBAACjQ,MAAM;gBAAY0N,UAAUwB;eAAS;AACpDnC,oBAAMpW,OAAO+W;AACFkC,yBAAA;YACb;UACF;AACA;QACF;QACA,KAAK,KAAK;AAEJ,cAAA5Z,IAAI+Z,WAAW,CAAC,KAAK;AAAW,kBAAAD;AAChC,cAAAb,QAAQhB,YAAY2B,WAAW3B;AAAgB,kBAAA6B;AAC/C,cAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAG9B,WAAW,CAAC;AAChE,cAAIkB,IAAI9Y,SAAS;AAAgB,mBAAA8Y;AACzBxC,kBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACjQ,MAAM;YAAO0N,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAA3B;AACX;QACF;QACA,KAAK,KAAK;AAEJ,cAAAjY,IAAI+Z,WAAW,CAAC,MAAM;AAAW,kBAAAD;AACjC,cAAAb,QAAQf,aAAa0B,WAAW1B;AAAiB,kBAAA4B;AACjD,cAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAG7B,YAAY,CAAC;AACjE,cAAIiB,IAAI9Y,SAAS;AAAgB,mBAAA8Y;AACjCxC,gBAAMsD,QAAQ;YAACjQ,MAAM;YAAQ0N,UAAUwB;WAAS;AAChDvC,gBAAMnX,KAAK;YAACwK,MAAM;YAAM0N,UAAUqC;UAAA,GAAW;YAAC/P,MAAM;YAAU0N,UAAUqC,WAAW;UAAE,CAAA;AAC7EpD,kBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BI,gBAAMoC,IAAIzB;AACCkC,qBAAA1B;AACX;QACF;QACA,KAAK,KAAK;AAER,cAAIlY,IAAIuG,MAAMwT,UAAUA,WAAW,CAAC,MAAM;AAAc,kBAAAD;AACpD,cAAAb,QAAQd,cAAcyB,WAAWzB;AAAkB,kBAAA2B;AACvDnD,gBAAMsD,QAAQ;YAACjQ,MAAM;YAAQ0N,UAAUwB;WAAS;AAChDnC,gBAAMgD,WAAW;AACNH,qBAAAzB;AACX;QACF;QACA,KAAK,KAAK;AAER,cAAInY,IAAIuG,MAAMwT,UAAUA,WAAW,CAAC,MAAM;AAAa,kBAAAD;AACnD,cAAAb,QAAQd,cAAcyB,WAAWzB;AAAkB,kBAAA2B;AACvDnD,gBAAMsD,QAAQ;YAACjQ,MAAM;YAAO0N,UAAUwB;WAAS;AAC/CnC,gBAAMgD,WAAW;AACNH,qBAAAzB;AACX;QACF;QACA,SAAS;AACP,cAAIkC,QAAQC,cAActa,KAAK+Z,UAAUjC,KAAK;AAC9C,kBAAQuC,OAAO;YACb,KAAK,MAAM;AACL,kBAAApB,QAAQf,aAAa0B,YAAY1B;AAAiB,sBAAA4B;AAEhD/C,oBAAA+B,OAAO9Y,KAAK+Z,WAAW,CAAC;AAE9B,kBAAIQ,UAAU;AAEV,kBAAAva,IAAI+W,GAAG,MAAM,KAAK;AACVwD,0BAAA;AACJxD,sBAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;cAC3B;AAEA,kBAAIyD,WAAWzD;AACf,kBAAIpW,SAASoY,UAAU/Y,KAAK+W,KAAKmB,YAAY,CAAC;AAC9C,kBAAIvX,OAAON,SAAS;AAAgB,uBAAAM;AAE9BoW,oBAAA+B,OAAO9Y,KAAKW,OAAO+W,QAAQ;AAE7B,kBAAA1X,IAAI+W,GAAG,MAAM,OAAO/W,IAAI+W,MAAM,CAAC,MAAM,KAAK;AAE5C,oBAAI1W,OAAO;AACX,oBAAIL,IAAI+W,MAAM,CAAC,MAAM,KAAK;AACjB1W,yBAAA;AACD0W,wBAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;gBAAA,OACpB;AACCA,wBAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;gBAC3B;AAEA,oBAAIoC,MAAMJ,UAAU/Y,KAAK+W,KAAKmB,YAAY,CAAC;AAC3C,oBAAIiB,IAAI9Y,SAAS;AAAgB,yBAAA8Y;AACjCxC,sBAAMsD,QAAQ;kBAACjQ,MAAM;kBAAY0N,UAAUwB;iBAAS;AAC5CvC,wBAAAA,MAAMjX,OAAO;kBAACsK,MAAM3J;kBAAMqX,UAAU8C;gBAAA,GAAW7Z,OAAOgW,OAAOwC,IAAIxC,KAAK;AAC9EI,sBAAMoC,IAAIzB;cAAA,OACL;AAELf,sBAAMsD,QAAQ;kBAACjQ,MAAM;kBAAQ0N,UAAUwB;iBAAS;AAChDvC,sBAAMnX,KAAK;kBAACwK,MAAM;kBAAM0N,UAAUqC;gBAAA,GAAW;kBAAC/P,MAAM;kBAAU0N,UAAUqC,WAAW;gBAAE,CAAA;AAC7EpD,wBAAAA,MAAMjX,OAAOiB,OAAOgW,KAAK;cACnC;AAEA,kBAAI4D,SAAS;AACLxD,sBAAA+B,OAAO9Y,KAAK+W,GAAG;AACjB,oBAAA/W,IAAI+W,GAAG,MAAM;AAAK,yBAAO;oBAAC1W,MAAM;oBAASqX,UAAUX;kBAAG;AAC1DA;cACF;AAEW6C,yBAAA1B;AACX;YACF;YACA,KAAK,SAAS;AAER,kBAAAe,QAAQf,aAAa0B,YAAY1B;AAAiB,sBAAA4B;AAClD,kBAAAX,MAAMJ,UAAU/Y,KAAK8Y,OAAO9Y,KAAK+Z,WAAW,CAAC,GAAG7B,YAAY,CAAC;AACjE,kBAAIiB,IAAI9Y,SAAS;AAAgB,uBAAA8Y;AACjCxC,oBAAMsD,QAAQ;gBAACjQ,MAAM;gBAAQ0N,UAAUwB;eAAS;AAChDvC,oBAAMnX,KAAK;gBAACwK,MAAM;gBAAM0N,UAAUqC;cAAA,GAAW;gBAAC/P,MAAM;gBAAU0N,UAAUqC,WAAW;cAAE,CAAA;AAC7EpD,sBAAAA,MAAMjX,OAAOyZ,IAAIxC,KAAK;AAC9BI,oBAAMoC,IAAIzB;AACCkC,yBAAA;AACX;YACF;YACA,SAAS;AACD,oBAAAE;YACR;UAAA;QAEJ;MAAA;IAEJ;AAEA,MAAId,gBAAea,QAAA,OAAA,SAAAA,KAAMxZ,UAAS,WAAWwZ,KAAKnC;AAElD,SAAO;IAACrX,MAAM;IAAWsW;IAAOe,UAAUX;IAAKiC;;AACjD;AAEA,SAASgB,eAAeha,KAAK+W,KAAK;AAChC,MAAImC,WAAWnC;AACP,UAAA/W,IAAI+W,GAAG,GAAG;IAChB,KAAK,KAAK;AACFA,YAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;AACzB,UAAI0D,aAAa1D;AACjB,UAAIuC,YAAWC,WAAWvZ,KAAK+W,KAAKe,KAAK;AACzC,UAAI,CAACwB;AAAU,eAAO;UAACjZ,MAAM;UAASqX,UAAUX;QAAG;AAC5CuC,aAAAA;AAEA,aAAA;QACLjZ,MAAM;QACNsW,OAAO,CACL;UAAC3M,MAAM;UAAe0N,UAAUwB;QAAQ,GACxC;UAAClP,MAAM;UAAS0N,UAAU+C;QAAU,GACpC;UAACzQ,MAAM;UAAa0N,UAAUX;QAAG,CAAA;QAEnCW,UAAUX;MAAA;IAEd;IACA,KAAK;AACC,UAAA/W,IAAI+W,MAAM,CAAC,MAAM;AAAK,eAAO;UAAC1W,MAAM;UAASqX,UAAUX;QAAG;AAG9D,UAAIJ,QAAQ,CAAC;QAAC3M,MAAM;QAAS0N,UAAUwB;OAAS;AACzCnC,aAAA;AAEH,UAAAqD,WAAWtB,OAAO9Y,KAAK+W,GAAG;AAC9B,UAAIuC,WAAWC,WAAWvZ,KAAKoa,UAAUtC,KAAK;AAC9C,UAAIwB,UAAU;AACZvC,cAAMqD,WAAWd;AACX3C,cAAAnX,KACJ;UAACwK,MAAM;UAAc0N,UAAU0C;QAAQ,GACvC;UAACpQ,MAAM;UAAS0N,UAAU0C;QAAQ,GAClC;UAACpQ,MAAM;UAAa0N,UAAUX;QAAG,CAAA;MAErC;AAEO,aAAA;QACL1W,MAAM;QACNsW;QACAe,UAAUX;MAAA;IAEd,KAAK,KAAK;AACFA,YAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;AAErB,UAAA/W,IAAI+W,GAAG,MAAM,KAAK;AACb,eAAA;UACL1W,MAAM;UACNsW,OAAO,CAAC;YAAC3M,MAAM;YAAiB0N,UAAUwB;WAAS;UACnDxB,UAAUX,MAAM;QAAA;MAEpB;AAEA,UAAIyD,WAAWzD;AACf,UAAIpW,SAASoY,UAAU/Y,KAAK+W,KAAK,CAAC;AAClC,UAAIpW,OAAON,SAAS;AAAgB,eAAAM;AAE9BoW,YAAA+B,OAAO9Y,KAAKW,OAAO+W,QAAQ;AAE7B,UAAA1X,IAAI+W,GAAG,MAAM,OAAO/W,IAAI+W,MAAM,CAAC,MAAM,KAAK;AAC5C,YAAI1W,OAAO;AACX,YAAIL,IAAI+W,MAAM,CAAC,MAAM,KAAK;AACjB1W,iBAAA;AACA0W,iBAAA;QAAA,OACF;AACEA,iBAAA;QACT;AAEMA,cAAA+B,OAAO9Y,KAAK+W,GAAG;AACrB,YAAIoC,MAAMJ,UAAU/Y,KAAK+W,KAAK,CAAC;AAC/B,YAAIoC,IAAI9Y,SAAS;AAAgB,iBAAA8Y;AAC3BpC,cAAA+B,OAAO9Y,KAAKmZ,IAAIzB,QAAQ;AAC1B,YAAA1X,IAAI+W,GAAG,MAAM;AAAK,iBAAO;YAAC1W,MAAM;YAASqX,UAAUX;UAAG;AAEnD,eAAA;UACL1W,MAAM;UACNsW,OAAO,CACL;YAAC3M,MAAM;YAAS0N,UAAUwB;UAAQ,GAClC;YAAClP,MAAM3J;YAAMqX,UAAU8C;UAAQ,CAAA,EAC/B9a,OAAOiB,OAAOgW,OAAOwC,IAAIxC,KAAK;UAChCe,UAAUX,MAAM;QAAA;MAEpB;AAEI,UAAA/W,IAAI+W,GAAG,MAAM;AAAK,eAAO;UAAC1W,MAAM;UAASqX,UAAUX;QAAG;AAEnD,aAAA;QACL1W,MAAM;QACNsW,OAAO,CAAC;UAAC3M,MAAM;UAAkB0N,UAAUwB;QAAA,CAAS,EAAExZ,OAAOiB,OAAOgW,KAAK;QACzEe,UAAUX,MAAM;MAAA;IAEpB;IACA,KAAK,KAAK;AACFA,YAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;AACrB,UAAA/W,IAAI+W,GAAG,MAAM,KAAK;AAChB,YAAApW,SAASyY,YAAYpZ,KAAK+W,GAAG;AACjC,YAAIpW,OAAON,SAAS;AAAgB,iBAAAM;AACpCA,eAAOgW,MAAMsD,QAAQ;UAACjQ,MAAM;UAAc0N,UAAUwB;SAAS;AACtD,eAAAvY;MACT;AACA;IACF;IACA,KAAK,KAAK;AACJ,UAAAA,SAASyY,YAAYpZ,KAAK+W,GAAG;AACjC,UAAIpW,OAAON,SAAS;AAAgB,eAAAM;AACpCA,aAAOgW,MAAMsD,QAAQ;QAACjQ,MAAM;QAAc0N,UAAUwB;OAAS;AACtD,aAAAvY;IACT;EAAA;AAGF,SAAO;IAACN,MAAM;IAASqX,UAAUX;EAAG;AACtC;AAEA,SAAS4C,cAAc3Z,KAAKkZ,UAAUnC,KAAK;AACzC,MAAIJ,QAAQ,CAAA;AAEZA,QAAMnX,KAAK;IAACwK,MAAM;IAAa0N,UAAUwB;GAAS;AAE9C,MAAAlZ,IAAI+W,GAAG,MAAM,OAAO/W,IAAI+W,MAAM,CAAC,MAAM,KAAK;AAC5CJ,UAAMnX,KAAK;MAACwK,MAAM;MAAa0N,UAAUwB;KAAS;AAClDvC,UAAMnX,KAAK;MAACwK,MAAM;MAAS0N,UAAUwB;OAAW;MAAClP,MAAM;MAAa0N,UAAUX;IAAI,CAAA;AAC5EA,UAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;AACzB,QAAI2D,UAAUnB,WAAWvZ,KAAK+W,KAAKe,KAAK;AACxC,QAAI,CAAC4C;AAAS,aAAO;QAACra,MAAM;QAASqX,UAAUX;MAAG;AAClDJ,UAAMnX,KAAK;MAACwK,MAAM;MAAS0N,UAAUX;IAAA,GAAM;MAAC/M,MAAM;MAAa0N,UAAUX,MAAM2D;IAAQ,CAAA;AACjF3D,UAAA+B,OAAO9Y,KAAK+W,MAAM2D,OAAO;AAC3B,QAAA1a,IAAI+W,GAAG,MAAM;AAAK,aAAO;QAAC1W,MAAM;QAASqX,UAAUX;MAAG;AAC1DA;AAEMA,UAAA+B,OAAO9Y,KAAK+W,GAAG;EAAA,OAChB;AACLJ,UAAMnX,KAAK;MAACwK,MAAM;MAAS0N,UAAUwB;OAAW;MAAClP,MAAM;MAAa0N,UAAUX;IAAI,CAAA;AAC5EA,UAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;EAC3B;AAEA,MAAI4D,UAAU5D;AAEV,MAAA/W,IAAI+W,GAAG,MAAM,KAAK;AACpB,WAAO,MAAM;AACX,UAAIpW,SAASoY,UAAU/Y,KAAK+W,KAAK,CAAC;AAClC,UAAIpW,OAAON,SAAS;AAAgB,eAAAM;AAC5BgW,cAAAA,MAAMjX,OAAOiB,OAAOgW,KAAK;AACjCgE,gBAAUha,OAAO+W;AACXX,YAAA+B,OAAO9Y,KAAKW,OAAO+W,QAAQ;AAC7B,UAAA1X,IAAI+W,GAAG,MAAM;AAAK;AAChBA,YAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;AAErB,UAAA/W,IAAI+W,GAAG,MAAM;AAAK;IACxB;EACF;AAEI,MAAA/W,IAAI+W,GAAG,MAAM,KAAK;AACpB,WAAO;MAAC1W,MAAM;MAASqX,UAAUX;IAAG;EACtC;AAGAJ,QAAMnX,KAAK;IAACwK,MAAM;IAAiB0N,UAAUiD;GAAQ;AAE9C,SAAA;IACLta,MAAM;IACNsW;IACAe,UAAUX,MAAM;EAAA;AAEpB;AAEA,SAASqC,YAAYpZ,KAAK+W,KAAK;AAC7B,MAAIJ,QAAQ,CAAC;IAAC3M,MAAM;IAAU0N,UAAUX;GAAI;AACtCA,QAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;AAEZ,SAAA/W,IAAI+W,GAAG,MAAM,KAAK;AAC7B,QAAI6D,UAAU7D;AAEd,QAAI/W,IAAIuG,MAAMwQ,KAAKA,MAAM,CAAC,MAAM,OAAO;AAC/BA,YAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;AACzB,UAAI/W,IAAI+W,GAAG,MAAM,OAAO/W,IAAI+W,GAAG,MAAM,KAAK;AACxC,YAAInL,OAAOmN,UAAU/Y,KAAK+W,KAAK,CAAC;AAChC,YAAInL,KAAKvL,SAAS;AAAgB,iBAAAuL;AAClC+K,cAAMnX,KAAK;UAACwK,MAAM;UAAgB0N,UAAUkD;SAAQ;AAC5CjE,gBAAAA,MAAMjX,OAAOkM,KAAK+K,KAAK;AAC/BI,cAAMnL,KAAK8L;MAAA,OACN;AACLf,cAAMnX,KAAK;UAACwK,MAAM;UAAqB0N,UAAUkD;SAAQ;MAC3D;IAAA,OACK;AACL,UAAIhP,OAAOmN,UAAU/Y,KAAK+W,KAAK,CAAC;AAChC,UAAInL,KAAKvL,SAAS;AAAgB,eAAAuL;AAClC,UAAIuO,UAAUrB,OAAO9Y,KAAK4L,KAAK8L,QAAQ;AACnC,UAAA9L,KAAK+K,MAAM,CAAC,EAAE3M,SAAS,SAAShK,IAAIma,OAAO,MAAM,KAAK;AACpD,YAAAvZ,QAAQmY,UAAU/Y,KAAK8Y,OAAO9Y,KAAKma,UAAU,CAAC,GAAG,CAAC;AACtD,YAAIvZ,MAAMP,SAAS;AAAgB,iBAAAO;AACnC+V,cAAMnX,KAAK;UAACwK,MAAM;UAAe0N,UAAUkD;SAAQ;AACnDjE,gBAAQA,MAAMjX,OAAOkM,KAAK+K,OAAO/V,MAAM+V,KAAK;AAC5CI,cAAMnW,MAAM8W;MAAA,OACP;AACGf,gBAAAA,MAAMjX,OAAO;UAACsK,MAAM;UAAe0N,UAAUX;QAAM,GAAAnL,KAAK+K,KAAK;AACrEI,cAAMnL,KAAK8L;MACb;IACF;AACMX,UAAA+B,OAAO9Y,KAAK+W,GAAG;AACjB,QAAA/W,IAAI+W,GAAG,MAAM;AAAK;AAChBA,UAAA+B,OAAO9Y,KAAK+W,MAAM,CAAC;EAC3B;AAEI,MAAA/W,IAAI+W,GAAG,MAAM,KAAK;AACpB,WAAO;MAAC1W,MAAM;MAASqX,UAAUX;IAAG;EACtC;AAEAA;AACAJ,QAAMnX,KAAK;IAACwK,MAAM;IAAc0N,UAAUX;GAAI;AAC9C,SAAO;IAAC1W,MAAM;IAAWsW;IAAOe,UAAUX;EAAG;AAC/C;AAEA,SAASsC,YAAYrZ,KAAK+W,KAAK;AACzB,MAAA3Q,QAAQpG,IAAI+W,GAAG;AACnBA,QAAMA,MAAM;AACZ,QAAMJ,QAAQ,CAAC;IAAC3M,MAAM;IAAO0N,UAAUX;GAAI;AAC3C/W;AAAK,aAAS+W,OAAO;AACnB,UAAIA,MAAM/W,IAAIgB;AAAQ,eAAO;UAACX,MAAM;UAASqX,UAAUX;QAAG;AAElD,cAAA/W,IAAI+W,GAAG,GAAG;QAChB,KAAK3Q,OAAO;AACVuQ,gBAAMnX,KAAK;YAACwK,MAAM;YAAW0N,UAAUX;WAAI;AAC3CA;AACM,gBAAA/W;QACR;QACA,KAAK,MAAM;AACT2W,gBAAMnX,KAAK;YAACwK,MAAM;YAAa0N,UAAUX;WAAI;AAC7C,cAAI/W,IAAI+W,MAAM,CAAC,MAAM,KAAK;AACxB,gBAAI/W,IAAI+W,MAAM,CAAC,MAAM,KAAK;AACxBJ,oBAAMnX,KAAK;gBAACwK,MAAM;gBAAe0N,UAAUX,MAAM;eAAE;AACnDA,oBAAM/W,IAAI6a,QAAQ,KAAK9D,MAAM,CAAC;AAC9BJ,oBAAMnX,KAAK;gBAACwK,MAAM;gBAAmB0N,UAAUX;eAAI;YAAA,OAC9C;AACLJ,oBAAMnX,KAAK;gBAACwK,MAAM;gBAAe0N,UAAUX,MAAM;eAAE;AACnDJ,oBAAMnX,KAAK;gBAACwK,MAAM;gBAAmB0N,UAAUX,MAAM;eAAE;AAChDA,qBAAA;YACT;UAAA,OACK;AACLJ,kBAAMnX,KAAK;cAACwK,MAAM;cAAiB0N,UAAUX,MAAM;aAAE;AAC9CA,mBAAA;UACT;AACAJ,gBAAMnX,KAAK;YAACwK,MAAM;YAAa0N,UAAUX,MAAM;WAAE;QACnD;MAAA;IAEJ;AAEA,SAAO;IAAC1W,MAAM;IAAWsW;IAAOe,UAAUX;EAAG;AAC/C;AAEA,SAAS+B,OAAO9Y,KAAK+W,KAAK;AACxB,SAAOA,MAAMwC,WAAWvZ,KAAK+W,KAAKa,EAAE;AACtC;AAKA,SAAS2B,WAAWvZ,KAAK+W,KAAK1X,IAAI;AAChC,MAAIyb,IAAIzb,GAAG0b,KAAK/a,IAAIuG,MAAMwQ,GAAG,CAAC;AAC9B,SAAO+D,IAAIA,EAAE,CAAC,EAAE9Z,SAAS;AAC3B;AAKA,SAASsZ,cAActa,KAAK+W,KAAK1X,IAAI;AACnC,MAAIyb,IAAIzb,GAAG0b,KAAK/a,IAAIuG,MAAMwQ,GAAG,CAAC;AACvB,SAAA+D,IAAIA,EAAE,CAAC,IAAI;AACpB;AC3xBA,SAASnb,KAAKuF,GAAcC,GAAyB;AACnD,SAAQkG,UAAmBlG,EAAED,EAAEmG,IAAI,CAAC;AACtC;AAKA,SAASnF,IAAI0J,OAA6B;AACxC,SAAQvE,WAAoB;IAAChL,MAAM;IAAOgL;IAAMO,MAAMgE,MAAM;MAACvP,MAAM;IAAO,CAAA;EAAC;AAC7E;AAEA,SAAS2a,QAAQpL,OAA6B;AAC5C,SAAQvE,WAAoB;IAAChL,MAAM;IAAWgL;IAAMO,MAAMgE,MAAM;MAACvP,MAAM;IAAO,CAAA;EAAC;AACjF;AAOgB,SAAA4a,cAAcC,OAAkB1T,OAAgD;AAC9F,MAAI,CAACA,OAAO;AACH,WAAA;MACLnH,MAAM;MACN6a;IAAA;EAEJ;AAEA,UAAQ1T,MAAMnH,MAAM;IAClB,KAAK;AACI,aAAA;QACLA,MAAM;QACN6a,OAAOvb,KAAKub,OAAO1T,MAAM0T,KAAK;MAAA;IAGlC,KAAK;AACI,aAAA;QACL7a,MAAM;QACN6a,OAAOvb,KAAKub,OAAO1T,MAAM0T,KAAK;MAAA;IAGlC,KAAK;AACI,aAAA;QACL7a,MAAM;QACN6a,OAAOvb,KAAKub,OAAOhV,IAAIsB,MAAM0T,KAAK,CAAC;MAAA;IAGvC,KAAK;AACI,aAAA;QACL7a,MAAM;QACN6a,OAAOvb,KAAKub,OAAOF,QAAQxT,MAAM0T,KAAK,CAAC;MAAA;IAG3C;AACE,YAAM,IAAI9X,MAAA,iBAAA1D,OAAuB8H,MAAMnH,IAAM,CAAA;EAAA;AAEnD;AAEgB,SAAA8a,cAAcrG,QAAmBtN,OAAgD;AAC/F,MAAI,CAACA,OAAO;AACH,WAAA;MACLnH,MAAM;MACN6a,OAAOpG;IAAA;EAEX;AAEA,UAAQtN,MAAMnH,MAAM;IAClB,KAAK;IACL,KAAK;AACI,aAAA;QACLA,MAAM;QACN6a,OAAOvb,KAAKmV,QAAQtN,MAAM0T,KAAK;MAAA;IAGnC,KAAK;IACL,KAAK;AACI,aAAA;QACL7a,MAAM;QACN6a,OAAOvb,KAAKmV,QAAQtN,MAAM0T,KAAK;MAAA;IAGnC;AACE,YAAM,IAAI9X,MAAA,iBAAA1D,OAAuB8H,MAAMnH,IAAM,CAAA;EAAA;AAEnD;AAEgB,SAAA+a,gBAAgBtG,QAAmBtN,OAAgD;AACjG,MAAI,CAACA,OAAO;AACH,WAAA;MACLnH,MAAM;MACN6a,OAAOpG;IAAA;EAEX;AAEA,UAAQtN,MAAMnH,MAAM;IAClB,KAAK;IACL,KAAK;AACI,aAAA;QACLA,MAAM;QACN6a,OAAOvb,KAAKmV,QAAQtN,MAAM0T,KAAK;MAAA;IAGnC,KAAK;IACL,KAAK;AACI,aAAA;QACL7a,MAAM;QACN6a,OAAOvb,KAAKmV,QAAQtN,MAAM0T,KAAK;MAAA;IAGnC;AACE,YAAM,IAAI9X,MAAA,iBAAA1D,OAAuB8H,MAAMnH,IAAM,CAAA;EAAA;AAEnD;AAEgB,SAAAgb,mBACdvG,QACAtN,OACiB;AACjB,MAAI,CAACA,OAAO;AACH,WAAA;MACLnH,MAAM;MACN6a,OAAOpG;IAAA;EAEX;AAEA,UAAQtN,MAAMnH,MAAM;IAClB,KAAK;AACI,aAAA;QACLA,MAAM;QACN6a,OAAOvb,KAAKuG,IAAI4O,MAAM,GAAGtN,MAAM0T,KAAK;MAAA;IAExC,KAAK;AACI,aAAA;QACL7a,MAAM;QACN6a,OAAOvb,KAAKuG,IAAI4O,MAAM,GAAGtN,MAAM0T,KAAK;MAAA;IAExC,KAAK;AACI,aAAA;QACL7a,MAAM;QACN6a,OAAOvb,KAAKmV,QAAQtN,MAAM0T,KAAK;MAAA;IAEnC,KAAK;AACI,aAAA;QACL7a,MAAM;QACN6a,OAAOvb,KAAKmV,QAAQtN,MAAM0T,KAAK;MAAA;IAEnC;AACE,YAAM,IAAI9X,MAAA,iBAAA1D,OAAuB8H,MAAMnH,IAAM,CAAA;EAAA;AAEnD;ACpIA,IAAMib,kBAAsD;EAC1D,KAAK;EACL,KAAK;EACL,MAAM;EACN,KAAK;EACLnW,GAAG;EACHoW,GAAG;EACHjR,GAAG;EACHkR,GAAG;EACHC,GAAG;AACL;AAEA,SAASC,UAAU1b,KAAqB;AAChC,QAAA2b,WAAWC,SAAS5b,KAAK,EAAE;AAC1B,SAAA6b,OAAOC,aAAaH,QAAQ;AACrC;AAEA,IAAMI,iBAAN,cAA6B3Y,MAAM;EAAnCvD,cAAA;AAAA,UAAA,GAAAuJ,SAAA;AACE,SAAOY,OAAO;EAAA;AAChB;AAEA,IAAMgS,eAAsC;EAC1CC,MAAMC,GAAG;AACD,UAAAtM,QAAQsM,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNgL,MAAMuE;IAAA;EAEV;EAEAuM,aAAa;AACJ,WAAA;MAAC9b,MAAM;;EAChB;EAEA+b,OAAO;AACE,WAAA;MAAC/b,MAAM;;EAChB;EAEAuI,SAAS;AACA,WAAA;MACLvI,MAAM;MACNiK,GAAG;IAAA;EAEP;EAEA+R,UAAUH,GAAG;AACL,UAAApX,OAAOoX,EAAEhF,QAAQ8E,YAAY;AAC5B,WAAA;MACL3b,MAAM;MACNiK,GAAGxF,KAAKwF,IAAI;IAAA;EAEhB;EAEAgS,SAASJ,GAAG;AACJ,UAAA7Q,OAAO6Q,EAAEhF,QAAQ8E,YAAY;AACnC,UAAMO,gBAA2E,CAAA;AACjF,WAAOL,EAAElF,QAAA,EAAUhN,SAAS,iBAAiB;AAC3CuS,oBAAc/c,KAAK0c,EAAEhF,QAAQsF,gBAAgB,CAAC;IAChD;AACAN,MAAEjF,MAAM;AACR,QAAIwF,YAAoC;AACxC,aAAS1b,IAAIwb,cAAcvb,SAAS,GAAGD,KAAK,GAAGA,KAAK;AACtC0b,kBAAAF,cAAcxb,CAAC,EAAE0b,SAAS;IACxC;AACI,QAAApR,KAAKhL,SAAS,gBAAgBgL,KAAKhL,SAAS,WAAWgL,KAAKhL,SAAS,gBAAgB;AACvFoc,kBAAYxB,cAAelW,SAAQA,KAAK0X,SAAS;IACnD;AACA,QAAIA,cAAc;AAAY,YAAA,IAAIrZ,MAAM,iCAAiC;AAClE,WAAAqZ,UAAUvB,MAAM7P,IAAI;EAC7B;EAEAqR,UAAUR,GAAG;AACL,UAAAlS,OAAOkS,EAAE5E,cAAc;AAE7B,QAAItN,SAAS,QAAQ;AACnB,aAAO;QAAC3J,MAAM;QAASO,OAAO;MAAI;IACpC;AACA,QAAIoJ,SAAS,QAAQ;AACnB,aAAO;QAAC3J,MAAM;QAASO,OAAO;MAAI;IACpC;AACA,QAAIoJ,SAAS,SAAS;AACpB,aAAO;QAAC3J,MAAM;QAASO,OAAO;MAAK;IACrC;AAEO,WAAA;MACLP,MAAM;MACN2J;IAAA;EAEJ;EAEA2S,IAAIT,GAAG;AACC,UAAA7Q,OAAO6Q,EAAEhF,QAAQ8E,YAAY;AAE5B,WAAA;MACL3b,MAAM;MACNgL;IAAA;EAEJ;EAEA0L,IAAImF,GAAG;AACC,UAAA7Q,OAAO6Q,EAAEhF,QAAQ8E,YAAY;AAE5B,WAAA;MACL3b,MAAM;MACNgL;IAAA;EAEJ;EAEAvH,IAAIoY,GAAG;AACC,UAAA3U,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAxU,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNoK,IAAI;MACJlD;MACAC;IAAA;EAEJ;EAEAoV,IAAIV,GAAG;AACC,UAAA3U,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAxU,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNoK,IAAI;MACJlD;MACAC;IAAA;EAEJ;EAEAqV,IAAIX,GAAG;AACC,UAAA3U,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAxU,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNoK,IAAI;MACJlD;MACAC;IAAA;EAEJ;EAEAsV,IAAIZ,GAAG;AACC,UAAA3U,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAxU,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNoK,IAAI;MACJlD;MACAC;IAAA;EAEJ;EAEAuV,IAAIb,GAAG;AACC,UAAA3U,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAxU,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNoK,IAAI;MACJlD;MACAC;IAAA;EAEJ;EAEAc,IAAI4T,GAAG;AACC,UAAA3U,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAxU,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNoK,IAAI;MACJlD;MACAC;IAAA;EAEJ;EAEAwV,KAAKd,GAAG;AACA,UAAA3U,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAvR,KAAKyR,EAAE5E,cAAc;AACrB,UAAA9P,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNoK;MACAlD;MACAC;IAAA;EAEJ;EAEAyV,SAASf,GAAG;AACJ,UAAA7Q,OAAO6Q,EAAEhF,QAAQ8E,YAAY;AACnC,UAAM1Q,cAAc4Q,EAAElF,QAAQ,EAAEhN,SAAS;AACzCkS,MAAEjF,MAAM;AACF,UAAA1P,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAxU,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNgL;MACA9D;MACAC;MACA8D;IAAA;EAEJ;EAEAtL,IAAIkc,GAAG;AACL,QAAItb,QAAQ;AAEZkZ;AAAa,aAAAoC,EAAEpF,QAAAA,GAAW;AAClB,cAAAM,OAAO8E,EAAElF,QAAQ;AACvB,gBAAQI,KAAKpN,MAAM;UACjB,KAAK;AACHpJ,qBAASsb,EAAE3E,iBAAiB;AAEtB,kBAAAuC;UACR,KAAK;AACHlZ,qBAASsb,EAAE3E,iBAAiB;AAC5B;UACF,KAAK;AACH2E,cAAEjF,MAAM;AACR;UACF,KAAK,iBAAiB;AACd,kBAAAiG,OAAOhB,EAAE3V,MAAM,CAAC;AACtB2V,cAAEjF,MAAM;AACRrW,qBAAS0a,gBAAgB4B,IAAuB;AAChD;UACF;UACA,KAAK;AACHhB,cAAEjF,MAAM;AACCrW,qBAAA8a,UAAUQ,EAAE3E,iBAAA,CAAkB;AACvC;UACF;AACE,kBAAM,IAAInU,MAAA,oBAAA1D,OAA0B0X,KAAKpN,IAAM,CAAA;QAAA;MAErD;AACO,WAAA;MAAC3J,MAAM;MAASO;;EACzB;EAEAuc,QAAQjB,GAAG;AACH,UAAAkB,WAAWlB,EAAE3E,iBAAiB;AAC7B,WAAA;MACLlX,MAAM;MACNO,OAAOyD,OAAO+Y,QAAQ;IAAA;EAE1B;EAEAC,MAAMnB,GAAG;AACD,UAAAkB,WAAWlB,EAAE3E,iBAAiB;AAC7B,WAAA;MACLlX,MAAM;MACNO,OAAOyD,OAAO+Y,QAAQ;IAAA;EAE1B;EAEAE,IAAIpB,GAAG;AACC,UAAAkB,WAAWlB,EAAE3E,iBAAiB;AAC7B,WAAA;MACLlX,MAAM;MACNO,OAAOyD,OAAO+Y,QAAQ;IAAA;EAE1B;EAEAG,OAAOrB,GAAG;AACR,UAAMnO,aAAoC,CAAA;AAC1C,WAAOmO,EAAElF,QAAA,EAAUhN,SAAS,cAAc;AACxC+D,iBAAWvO,KAAK0c,EAAEhF,QAAQsG,cAAc,CAAC;IAC3C;AACAtB,MAAEjF,MAAM;AAED,WAAA;MACL5W,MAAM;MACN0N;IAAA;EAEJ;EAEAd,MAAMiP,GAAG;AACP,UAAM7N,WAA+B,CAAA;AACrC,WAAO6N,EAAElF,QAAA,EAAUhN,SAAS,aAAa;AACvC,UAAIsE,UAAU;AACd,UAAI4N,EAAElF,QAAA,EAAUhN,SAAS,eAAe;AAC5BsE,kBAAA;AACV4N,UAAEjF,MAAM;MACV;AACM,YAAArW,QAAQsb,EAAEhF,QAAQ8E,YAAY;AACpC3N,eAAS7O,KAAK;QACZa,MAAM;QACNO;QACA0N;MAAA,CACD;IACH;AACA4N,MAAEjF,MAAM;AACD,WAAA;MACL5W,MAAM;MACNgO;IAAA;EAEJ;EAEA6G,MAAMgH,GAAG;AACP,UAAMuB,UAAsB,CAAA;AAC5B,WAAOvB,EAAElF,QAAA,EAAUhN,SAAS,aAAa;AACvCyT,cAAQje,KAAK0c,EAAEhF,QAAQ8E,YAAY,CAAC;IACtC;AACAE,MAAEjF,MAAM;AACD,WAAA;MACL5W,MAAM;MACNod;IAAA;EAEJ;EAEAC,UAAUxB,GAAG;AACX,QAAIyB,YAAY;AAChB,QAAIzB,EAAElF,QAAA,EAAUhN,SAAS,aAAa;AACpCkS,QAAEjF,MAAM;AACR0G,kBAAYzB,EAAE5E,cAAc;IAC9B;AAEM,UAAAtN,OAAOkS,EAAE5E,cAAc;AACzB,QAAAqG,cAAc,YAAY3T,SAAS,UAAU;AAC/C,YAAMrJ,SAAqB;QACzBN,MAAM;QACN0K,cAAc,CAAA;MAAC;AAGjB,aAAOmR,EAAElF,QAAA,EAAUhN,SAAS,iBAAiB;AAC3C,YAAIkS,EAAElF,QAAA,EAAUhN,SAAS,QAAQ;AAC/B,cAAIrJ,OAAOqK;AAAgB,kBAAA,IAAI+Q,eAAAA,iCAAAA;AAC/BG,YAAEjF,MAAM;AACF,gBAAA9L,YAAY+Q,EAAEhF,QAAQ8E,YAAY;AAClC,gBAAApb,QAAQsb,EAAEhF,QAAQ8E,YAAY;AACpCrb,iBAAOoK,aAAavL,KAAK;YACvBa,MAAM;YACN8K;YACAvK;UAAA,CACD;QAAA,OACI;AACL,cAAID,OAAOqK;AAAgB,kBAAA,IAAI+Q,eAAAA,iCAAAA;AACzB,gBAAAnb,QAAQsb,EAAEhF,QAAQ8E,YAAY;AACpCrb,iBAAOqK,WAAWpK;QACpB;MACF;AACAsb,QAAEjF,MAAM;AACD,aAAAtW;IACT;AAEA,UAAMyL,OAAmB,CAAA;AAEzB,WAAO8P,EAAElF,QAAA,EAAUhN,SAAS,iBAAiB;AAC3C,UAAI4T,yBAAyBD,WAAW3T,MAAMoC,KAAKpL,MAAM,GAAG;AAG1Dkb,UAAEhF,QAAQ2G,gBAAgB;AAC1BzR,aAAK5M,KAAK;UAACa,MAAM;QAAW,CAAA;MAAA,OACvB;AACL+L,aAAK5M,KAAK0c,EAAEhF,QAAQ8E,YAAY,CAAC;MACnC;IACF;AAEAE,MAAEjF,MAAM;AAER,QAAI0G,cAAc,aAAa3T,SAAS,YAAYA,SAAS,UAAU;AACjE,UAAAkS,EAAEtF,aAAaZ,SAAS,SAAS;AAC5B,eAAA;UACL3V,MAAM;UACN8J,KAAKH;QAAA;MAET;IACF;AAEA,QAAI2T,cAAc,YAAY3T,SAAS,WAAW,CAACkS,EAAErF;AAC7C,YAAA,IAAIkF,eAAe,kBAAkB;AAEvC,UAAA+B,QAAQtH,WAAWmH,SAAS;AAClC,QAAI,CAACG,OAAO;AACJ,YAAA,IAAI/B,eAAe,wBAAArc,OAAwBie,SAAW,CAAA;IAC9D;AAEM,UAAArU,OAAOwU,MAAM9T,IAAI;AACvB,QAAI,CAACV,MAAM;AACH,YAAA,IAAIyS,eAAe,uBAAArc,OAAuBsK,IAAM,CAAA;IACxD;AACI,QAAAV,KAAKmJ,UAAU,QAAW;AAC5BsL,oBAAc/T,MAAMV,KAAKmJ,OAAOrG,KAAKpL,MAAM;IAC7C;AAEA,QAAIsI,KAAK0M,SAAS,UAAa1M,KAAK0M,SAASkG,EAAEtF,aAAaZ,MAAM;AAC1D,YAAA,IAAI+F,eAAe,uBAAArc,OAAuBsK,IAAM,CAAA;IACxD;AAEO,WAAA;MACL3J,MAAM;MACNiJ;MACAU;MACAoC;IAAA;EAEJ;EAEA4R,SAAS9B,GAAG;AACJ,UAAA7Q,OAAO6Q,EAAEhF,QAAQ8E,YAAY;AACnCE,MAAEjF,MAAM;AAER,QAAI0G,YAAY;AAChB,QAAIzB,EAAElF,QAAA,EAAUhN,SAAS,aAAa;AACpCkS,QAAEjF,MAAM;AACR0G,kBAAYzB,EAAE5E,cAAc;IAC9B;AACA,QAAIqG,cAAc,UAAU;AACpB,YAAA,IAAI5B,eAAe,wBAAArc,OAAwBie,SAAW,CAAA;IAC9D;AAEM,UAAA3T,OAAOkS,EAAE5E,cAAc;AAC7B,UAAMlL,OAAmB,CAAA;AAEzB,UAAM6R,gBAAgB/B,EAAErF;AACxB,QAAI7M,SAAS,SAAS;AAEpBkS,QAAErF,aAAa;IACjB;AAES,eAAA;AACD,YAAAqH,WAAWhC,EAAElF,QAAA,EAAUhN;AAC7B,UAAIkU,aAAa,iBAAiB;AAChC;MACF;AAEA,UAAIlU,SAAS,SAAS;AACpB,YAAIkU,aAAa,OAAO;AACtBhC,YAAEjF,MAAM;AACH7K,eAAA5M,KAAK;YAACa,MAAM;YAAOgL,MAAM6Q,EAAEhF,QAAQ8E,YAAY;UAAA,CAAE;AACtD;QAAA,WACSkC,aAAa,QAAQ;AAC9BhC,YAAEjF,MAAM;AACH7K,eAAA5M,KAAK;YAACa,MAAM;YAAQgL,MAAM6Q,EAAEhF,QAAQ8E,YAAY;UAAA,CAAE;AACvD;QACF;MACF;AAEA5P,WAAK5M,KAAK0c,EAAEhF,QAAQ8E,YAAY,CAAC;IACnC;AACAE,MAAEjF,MAAM;AAERiF,MAAErF,aAAaoH;AAET,UAAA3U,OAAOoL,cAAc1K,IAAI;AAC/B,QAAI,CAACV,MAAM;AACH,YAAA,IAAIyS,eAAe,4BAAArc,OAA4BsK,IAAM,CAAA;IAC7D;AACA,QAAIV,KAAKmJ,OAAO;AACdsL,oBAAc/T,MAAMV,KAAKmJ,OAAOrG,KAAKpL,MAAM;IAC7C;AAEO,WAAA;MACLX,MAAM;MACNiJ;MACA+B;MACArB;MACAoC;IAAA;EAEJ;EAEA+R,KAAKjC,GAAG;AACA,UAAA,IAAIH,eAAAA,eAAAA;EACZ;EAEAqC,IAAIlC,GAAG;AACC,UAAA3U,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAxU,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNkH;MACAC;IAAA;EAEJ;EAEA6W,GAAGnC,GAAG;AACE,UAAA3U,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAxU,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACNkH;MACAC;IAAA;EAEJ;EAEA8W,IAAIpC,GAAG;AACC,UAAA7Q,OAAO6Q,EAAEhF,QAAQ8E,YAAY;AAC5B,WAAA;MACL3b,MAAM;MACNgL;IAAA;EAEJ;EAEAkT,IAAIrC,GAAG;AACC,UAAA,IAAIH,eAAe,gBAAgB;EAC3C;EAEAyC,KAAKtC,GAAG;AACA,UAAA,IAAIH,eAAe,iBAAiB;EAC5C;EAEA0C,MAAMvC,GAAG;AACD,UAAAlS,OAAOkS,EAAE5E,cAAc;AAEzB,QAAA4E,EAAEtF,aAAanO,UAAUyT,EAAEtF,aAAanO,OAAOiE,eAAe1C,IAAI,GAAG;AAChE,aAAA;QACL3J,MAAM;QACNO,OAAOsb,EAAEtF,aAAanO,OAAOuB,IAAI;MAAA;IAErC;AAEO,WAAA;MACL3J,MAAM;MACN2J;IAAA;EAEJ;AACF;AAEA,IAAMwT,iBAAmD;EACvDkB,YAAYxC,GAAG;AACb,QAAIA,EAAElF,QAAA,EAAUhN,SAAS,QAAQ;AAC/BkS,QAAEjF,MAAM;AACF,YAAA9L,YAAY+Q,EAAEhF,QAAQ8E,YAAY;AAClCpb,YAAAA,SAAQsb,EAAEhF,QAAQ8E,YAAY;AAE7B,aAAA;QACL3b,MAAM;QACN8K;QACAvK,OAAAA;MAAA;IAEJ;AAEM,UAAAA,QAAQsb,EAAEhF,QAAQ8E,YAAY;AAE7B,WAAA;MACL3b,MAAM;MACN2J,MAAM2U,mBAAmB/d,KAAK;MAC9BA;IAAA;EAEJ;EAEAge,YAAY1C,GAAG;AACP,UAAAlS,OAAOkS,EAAEhF,QAAQ8E,YAAY;AACnC,QAAIhS,KAAK3J,SAAS;AAAe,YAAA,IAAI+C,MAAM,qBAAqB;AAE1D,UAAAxC,QAAQsb,EAAEhF,QAAQ8E,YAAY;AAC7B,WAAA;MACL3b,MAAM;MACN2J,MAAMA,KAAKpJ;MACXA;IAAA;EAEJ;EAEAie,aAAa3C,GAAoB;AACzB,UAAAtb,QAAQsb,EAAEhF,QAAQ8E,YAAY;AAE7B,WAAA;MACL3b,MAAM;MACNO;IAAA;EAEJ;EAEAke,oBAAqC;AAC5B,WAAA;MACLze,MAAM;MACNO,OAAO;QAACP,MAAM;MAAM;IAAA;EAExB;AACF;AAEA,IAAMmc,mBAAkF;EACtFuC,eAAe7C,GAAG;AACV,UAAAtQ,OAAOsQ,EAAEhF,QAAQ8E,YAAY;AAE7B,UAAApb,QAAQ6P,oBAAoB7E,IAAI;AAClC,QAAAhL,SAASA,MAAMP,SAAS,UAAU;AACpC,aAAQmH,WACN4T,gBAAiB/P,WAAU;QAAChL,MAAM;QAAiBgL;QAAMwB,OAAOjM,MAAMJ;MAAA,IAAQgH,KAAK;IACvF;AAEI,QAAA5G,SAASA,MAAMP,SAAS,UAAU;AACpC,aAAQmH,WACN2T,cAAe9P,WAAU;QAAChL,MAAM;QAAmBgL;QAAMrB,MAAMpJ,MAAMJ;MAAA,IAAQgH,KAAK;IACtF;AAEA,WAAQA,WACNyT,cACG5P,WAAU;MACThL,MAAM;MACNgL;MACAO;IAAA,IAEFpE,KAAA;EAEN;EAEAjB,MAAM2V,GAAG;AACP,UAAM5Q,cAAc4Q,EAAElF,QAAQ,EAAEhN,SAAS;AACzCkS,MAAEjF,MAAM;AAEF,UAAA1P,OAAO2U,EAAEhF,QAAQ8E,YAAY;AAC7B,UAAAxU,QAAQ0U,EAAEhF,QAAQ8E,YAAY;AAE9B,UAAArR,YAAY8F,oBAAoBlJ,IAAI;AACpC,UAAAqD,aAAa6F,oBAAoBjJ,KAAK;AAExC,QAAA,CAACmD,aAAa,CAACC,cAAcD,UAAUtK,SAAS,YAAYuK,WAAWvK,SAAS,UAAU;AACtF,YAAA,IAAI0b,eAAe,mCAAmC;IAC9D;AAEA,WAAQ5C,SACN8B,cACG5P,WAAU;MACThL,MAAM;MACNgL;MACA9D,MAAMoD,UAAUnK;MAChBgH,OAAOoD,WAAWpK;MAClB8K;IAAA,IAEF6N,GAAA;EAEN;EAEA6F,WAAW9C,GAAG;AACN,UAAArX,MAAMqX,EAAEhF,QAAQ8E,YAAY;AAClC,WAAQxU,WACN6T,mBAAoBhQ,WAAU;MAAChL,MAAM;MAAcgL;MAAYO,MAAM/G;QAAO2C,KAAK;EACrF;EAEAyX,YAAY/C,GAAG;AACP,UAAAlS,OAAOkS,EAAE5E,cAAc;AAEtB,WAAC9P,WAAU2T,cAAe9P,WAAU;MAAChL,MAAM;MAAmBgL;MAAMrB;QAAQxC,KAAK;EAC1F;EAEA0X,MAAMhD,GAAG;AACP,QAAIlO,OAAsB;AAE1B,QAAIkO,EAAElF,QAAA,EAAUhN,SAAS,cAAc;AACrCkS,QAAEjF,MAAM;AACRjJ,aAAOkO,EAAE5E,cAAc;IACzB;AAEM,UAAA6H,OAAQ9T,UACZ2C,OAAO;MAAC3N,MAAM;MAAmBgL;MAAMrB,MAAMgE;IAAA,IAAQ3C;AAEvD,WAAQ7D,WACN2T,cACG9P,UACC8T,KAAK;MACH9e,MAAM;MACNgL;IAAA,CACD,GACH7D,KAAA;EAEN;EAEA4X,cAAclD,GAAG;AACR,WAAC1U,WAAUyT,cAAe5P,WAAU;MAAChL,MAAM;MAAegL;IAAI,IAAI7D,KAAK;EAChF;AACF;AAEA,IAAMqW,mBAAsC;EAC1C5B,MAAMC,GAAG;AACPA,MAAEhF,QAAQ2G,gBAAgB;AACnB,WAAA;EACT;EAEA1B,aAAa;AACL,UAAA,IAAI/Y,MAAM,yBAAyB;EAC3C;EAEAgZ,OAAO;AACC,UAAA,IAAIhZ,MAAM,yBAAyB;EAC3C;EAEAwF,SAAS;AACD,UAAA,IAAIxF,MAAM,yBAAyB;EAC3C;EAEAiZ,UAAUH,GAAG;AACL,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAkZ,SAASJ,GAAG;AACVA,MAAEhF,QAAQ2G,gBAAgB;AAC1B,WAAO3B,EAAElF,QAAA,EAAUhN,SAAS,iBAAiB;AAC3CkS,QAAEhF,QAAQsF,gBAAgB;IAC5B;AAEAN,MAAEjF,MAAM;AACD,WAAA;EACT;EAEAyF,UAAUR,GAAG;AACXA,MAAE5E,cAAc;AACT,WAAA;EACT;EAEAqF,IAAIT,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEA2T,IAAImF,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAU,IAAIoY,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAwZ,IAAIV,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAyZ,IAAIX,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEA0Z,IAAIZ,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEA2Z,IAAIb,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAkF,IAAI4T,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEA4Z,KAAKd,GAAG;AACA,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEA6Z,SAASf,GAAG;AACJ,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEApD,IAAIkc,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEA+Z,QAAQjB,GAAG;AACH,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAia,MAAMnB,GAAG;AACD,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAka,IAAIpB,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAma,OAAOrB,GAAG;AACF,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEA6J,MAAMiP,GAAG;AACD,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEA8R,MAAMgH,GAAG;AAED,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAsa,UAAUxB,GAAG9E,MAAM;AACjB,UAAM9N,OAAO0S,aAAa0B,UAAUxB,GAAG9E,IAAI;AAC3C,QAAI9N,KAAKU,SAAS,cAAcV,KAAK8C,KAAKpL,WAAW;AAAU,aAAA;AAEzD,UAAA,IAAIoC,MAAM,yBAAyB;EAC3C;EAEA4a,SAAS9B,GAAG;AACJ,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEA+a,KAAKjC,GAAG;AACA,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAgb,IAAIlC,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAib,GAAGnC,GAAG;AACE,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAkb,IAAIpC,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAmb,IAAIrC,GAAG;AACC,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAob,KAAKtC,GAAG;AACA,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;EAEAqb,MAAMvC,GAAG;AACD,UAAA,IAAI9Y,MAAM,yBAAyB;EAC3C;AACF;AAEA,SAASub,mBAAmB1V,MAAwB;AAClD,MAAIA,KAAK5I,SAAS,qBAAqB,CAAC4I,KAAKoC,MAAM;AACjD,WAAOpC,KAAKe;EACd;AAGE,MAAAf,KAAK5I,SAAS,WACd4I,KAAK5I,SAAS,SACd4I,KAAK5I,SAAS,gBACd4I,KAAK5I,SAAS,WACd4I,KAAK5I,SAAS,YACd4I,KAAK5I,SAAS,mBACd4I,KAAK5I,SAAS,eACd;AACO,WAAAse,mBAAmB1V,KAAKoC,IAAI;EACrC;AAEA,QAAM,IAAI0Q,eAAA,2CAAArc,OAA0DuJ,KAAK5I,IAAM,CAAA;AACjF;AAEA,SAAS0d,cAAc/T,MAAcyI,OAA0BL,QAAe;AACxE,MAAA,OAAOK,UAAU,UAAU;AAC7B,QAAIL,WAAUK,OAAO;AACnB,YAAM,IAAIsJ,eAAA,6CAAArc,OACqCsK,MAAAA,eAAAA,EAAAA,OAAoByI,OAAc,QAAA,EAAA/S,OAAA0S,QAAA,GAAA,CAAA;IAEnF;aACSK,OAAO;AACZ,QAAA,CAACA,MAAML,MAAK,GAAG;AACX,YAAA,IAAI2J,eAAe,6CAAArc,OAA6CsK,MAAS,KAAA,CAAA;IACjF;EACF;AACF;AAEA,SAAS4T,yBAAyBD,WAAmB0B,cAAsBC,UAAkB;AACrF,QAAAC,8BAA8B,CAAC,cAAc,aAAa;AAEhE,SAAO5B,aAAa,UAAU2B,YAAY,KAAKC,4BAA4BC,SAASH,YAAY;AAClG;AAEA,IAAMI,kBAAN,cAA8Brc,MAAM;EAIlCvD,YAAY6X,UAAkB;AAC5B,UAAA,0CAAAhY,OAAgDgY,QAAU,CAAA;AAH5D,SAAO1N,OAAO;AAIZ,SAAK0N,WAAWA;EAClB;AACF;AAKO,SAASmB,MAAM6G,OAAqD;AAAA,MAAtC3P,UAAwB3G,UAAApI,SAAA,KAAAoI,UAAA,CAAA,MAAAC,SAAAD,UAAA,CAAA,IAAA,CAAA;AACrD,QAAAzI,SAASgf,QAASD,KAAK;AACzB,MAAA/e,OAAON,SAAS,SAAS;AACrB,UAAA,IAAIof,gBAAgB9e,OAAO+W,QAAQ;EAC3C;AACA,QAAMkI,YAAY,IAAIlJ,cAAcgJ,OAAO/e,OAAOgW,OAAiB5G,OAAO;AACnE,SAAA6P,UAAU1I,QAAQ8E,YAAY;AACvC;;;;;;;;;;ACt2BA,IAAM6D,6BACJC,iBAEA,OAAOC,WAAW,eAClBD,YAAYE,qBAAqBD,OAAOE,YAAYC,UAAUF;AAEhE,IAAMG,wBACJL,iBAEA,CAACD,2BAA2BC,WAAW;AAEzC,IAAMM,yBAAyBA,CAC7BN,aACAO,MACAC,aACS;AACL,MAAAH,sBAAsBL,WAAW,GAAG;AAE1BA,gBAAAE,iBAAiBK,MAAMC,QAAe;EAAA,OAC7C;AACOR,gBAAAE,iBAAiBK,MAAMC,UAAU,KAAK;EACpD;AACF;AAEgB,SAAAC,OACdC,iBACAC,QACAC,UAKc;AACd,QAAM;IAACC;IAAWC;IAASC;EAAA,IAASJ;AACpC,QAAMK,UAAUD,QAAQ;IAACE,eAAe,UAAAC,OAAUH,KAAAA;MAAW;AACvD,QAAAI,MAAA,WAAAD,OAAiBL,WAA0C,gCAAA,EAAAK,OAAAJ,SAAA,+BAAA;AAC3D,QAAAM,KAAK,IAAIV,gBAAgBS,KAAK;IAACE,iBAAiB;IAAML;GAAQ;AAE7CV,yBAAAc,IAAI,WAAWR,SAASU,IAAI;AAEnDhB,yBAAuBc,IAAI,YAAYG,kBAAkBX,SAASY,IAAI,CAAC;AAEhDlB,yBAAAc,IAAI,gBAAiBK,SAAa;AACvDL,OAAGM,MAAM;AAEL,QAAAC;AACA,QAAA;AACKA,aAAAC,KAAKC,MAAMJ,IAAIE,IAAI;aACnBG;AACPlB,eAASmB,MAAM,IAAIC,MAAM,wCAAwC,CAAC;AAClE;IACF;AAESpB,aAAAmB,MACP,IAAIC,MAAML,KAAKM,WAAWN,KAAKI,SAAS,0BAAAb,OAA0BS,KAAKO,UAAY,CAAA,CAAA;EACrF,CACD;AAEsB5B,yBAAAc,IAAI,SAAUU,SAAe;AAClD,UAAMK,SAAS,OAAOlC,WAAW,eAAeA,OAAOmC,SAASD;AAC1D,UAAAE,aAAaF,SAAS,+BAAAjB,OAA+BiB,QAAuB,cAAA,IAAA;AAClF,UAAMG,eAAeC,YAAYT,GAAG,IAAI,KAAAZ,OAAKY,IAAIG,SAAa,GAAA,IAAA;AACrDrB,aAAAmB,MACP,IAAIC,MAAA,kFAAAd,OACgFmB,UAAa,EAAAnB,OAAAoB,YAAA,CAAA,CACjG;EACF,CACD;AAEM,SAAA;IACLE,aAAaA,MAAqBC,QAAQC,QAAQtB,GAAGM,MAAAA,CAAO;EAAA;AAEhE;AAEA,SAASH,kBAAkBoB,IAAwD;AACjF,SAAQlB,SAAa;AACf,QAAAE;AACA,QAAA;AACKA,aAAAC,KAAKC,MAAMJ,IAAIE,IAAI;aACnBG;AAEP;IACF;AAEAa,OAAGhB,IAAI;EAAA;AAEX;AAEA,SAASY,YAAYT,KAAwC;AAC3D,SAAO,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,aAAaA;AACjE;AC1GO,SAASc,QAAQC,KAA8B;AAC7C,SAAAA,IAAIC,IAAIC,WAAW,SAAS;AACrC;AAEO,SAASC,eAAeC,UAAkC;AACxD,SAAAL,QAAQK,QAAQ,IAAIA,SAASH,IAAII,MAAM,CAAC,IAAID,SAASH;AAC9D;ACLgB,SAAAK,qBACdN,KACAO,OACuB;AACjB,QAAAC,WAAW;IAAC,GAAGR;;AACrB,SAAOQ,SAASC;AACT,SAAAC,WAAWF,UAAUD,KAAK;AACnC;ACJA,IAAMI,cAAc;AAEpB,SAASC,OAAO;AACd,SAAOhB,QAAQC,QAAQ;AACzB;AAEO,SAASgB,kBACd/C,QACAgD,gBAAAC,MAEwC;AAAA,MADxC;IAACC,cAAAA;IAAc1D;MACyByD;AAClC,QAAA;IACJ/C;IACAC;IACAL,QAAQqD;IACRC;IACAC;IACAjD;IACAkD;EACE,IAAAtD;AAMA,MAAAuD;AACA,MAAAC;AACA,MAAAC;AAEE,QAAAC,WAAYC,UAA2B;AAC9BJ,iBAAA;AACEE,mBAAA;AACDD,kBAAA;AACdR,mBAAeI,gBAAgBQ,QAAQD,IAAI,IAAIA,IAAI;EAAA;AAGrD,MAAI,CAACR,aAAa;AAChB,UAAMU,UAASX,cAAa;MAAChD;MAAWC;MAASkD;MAAejD;MAAOkD;IAAa,CAAA,EACjFQ,KAAKJ,QAAQ,EACbI,KAAKhB,IAAI;AACZ,WAAO;MAACjB,aAAaiB;MAAMe,QAAAA;IAAM;EACnC;AAEM,QAAAE,mBAAA,oBAAuBC,IAA4B;AAGrD,MAAAC;AAGJ,QAAMC,SAA0B,CAAA;AAG5B,MAAAC;AACA,MAAAC;AACJ,QAAMP,SAAS,IAAI/B,QAAc,CAACC,SAASsC,WAAW;AACpCF,oBAAApC;AACFqC,kBAAAC;EAAA,CACf;AAED,QAAMC,SAAS,YAAY;AACnB,UAAAC,UAAU,MAAMrB,cAAa;MAAChD;MAAWC;MAASkD;MAAejD;MAAOkD;IAAA,CAAa;AAC/EW,gBAAAO,uBAAuBD,SAASL,MAAM;AACxCD,cAAAQ,QAASvC,SAAQ6B,iBAAiBW,IAAIxC,IAAIC,KAAKD,GAAG,CAAC;AAC7DwB,aAASO,SAAS;AACJE,kBAAA;EAAA;AAGV,QAAAQ,qBAAsB7D,SAAuB;AACjD,QAAImD,WAAW;AACbW,oBAAc9D,GAAG;AACjB+D,qBAAeZ,WAAWnD,GAAG;IAAA,OACxB;AACLoD,aAAOY,KAAKhE,GAAG;IACjB;EAAA;AAGI,QAAAjB,WAAWC,OAAON,aAAaQ,QAAQ;IAC3Ca,MAAM8D;IACNhE,MAAM2D;IACNlD,OAAQA,WAAiBgD,YAAYhD,KAAK;EAAA,CAC3C;AAEK,QAAAyD,iBAAiBA,CAAClB,MAAwB7C,QAAuB;AACrEiE,iBAAatB,YAAY;AAErB,QAAAD,gBAAgB1C,IAAIkE,iBAAiBzB,YAAY;AAGnDG,eAASH,UAAU;AACLC,oBAAA;IAAA,OACT;AACLA,oBAAc1C,IAAIkE;AAClBzB,mBAAaI,KAAKpB,MAAM;IAC1B;AAEAkB,mBAAewB,WAAWvB,UAAUb,aAAac,KAAKpB,MAAAA,CAAO;EAAA;AAGzD,QAAAqC,gBAAiB9D,SAAuB;AAC5C,QAAI,CAACA,IAAIoE,WAAWpE,IAAIqE,WAAW/C,WAAW,IAAI,GAAG;AACnD;IACF;AAEA,UAAME,WAAWyB,iBAAiBqB,IAAItE,IAAIqE,UAAU,KAAK;AACzDE,oBAAgBvE,IAAIqE,YAAY3C,qBAAqBF,UAAUxB,IAAIoE,QAAQI,KAAK,CAAC;EAAA;AAG7E,QAAAD,kBAAkBA,CAACE,IAAYjD,aAAoC;AACjE,UAAAkD,UAAUzB,iBAAiBqB,IAAIG,EAAE;AACjC,UAAA5B,OAAOM,aAAa,CAAA;AAC1B,UAAMwB,WAAWD,UAAU7B,KAAK+B,QAAQF,OAAO,IAAI;AAE/C,QAAAC,aAAa,MAAMnD,UAAU;AAE/BqB,WAAKmB,KAAKxC,QAAQ;AACDyB,uBAAAW,IAAIa,IAAIjD,QAAQ;eACxBA,UAAU;AAEdqB,WAAAgC,OAAOF,UAAU,GAAGnD,QAAQ;AAChByB,uBAAAW,IAAIa,IAAIjD,QAAQ;IAAA,OAC5B;AAEAqB,WAAAgC,OAAOF,UAAU,CAAC;AACvB1B,uBAAiB6B,OAAOL,EAAE;IAC5B;EAAA;AAGF,SAAO;IAAC1D,aAAahC,SAASgC;IAAagC;EAAM;AACnD;AAEA,SAASW,uBACPP,WACA4B,WACkB;AAEZ,QAAAC,SAAA,oBAAa9B,IAA6B;AACtC6B,YAAApB,QAASsB,cAAa;AAC9B,UAAMC,QAAQF,OAAOV,IAAIW,SAASZ,UAAU,KAAK,CAAA;AACjDa,UAAMlB,KAAKiB,QAAQ;AACZD,WAAApB,IAAIqB,SAASZ,YAAYa,KAAK;EAAA,CACtC;AAGMF,SAAArB,QAAQ,CAACuB,OAAOT,OAAO;AAC5B,UAAMjD,WAAW2B,UAAUgC,KAAM/D,SAAQA,IAAIC,QAAQoD,EAAE;AACvD,QAAI,CAACjD,UAAU;AAGL4D,cAAAC,KAAK,6CAA6CZ,EAAE;AAC5D;IACF;AAIA,QAAIa,mBAAmB;AACvB,QAAIZ,UAAiClD;AAC/B0D,UAAAvB,QAASsB,cAAa;AACPK,yBAAAA,oBAAoBL,SAASM,gBAAgB/D,SAASK;AACzE,UAAI,CAACyD,kBAAkB;AACrB;MACF;AAEA,UAAIL,SAASb,SAAS;AACpBM,kBAAUhD,qBAAqBgD,SAASO,SAASb,QAAQI,KAAK;MAChE;IAAA,CACD;AAGDrB,cAAU0B,OAAO1B,UAAUyB,QAAQpD,QAAQ,GAAG,GAAGkD,OAAO;EAAA,CACzD;AAEM,SAAAvB;AACT;AAEA,SAASL,QAAQK,WAA+C;AACxD,QAAAqC,YAAA,oBAAgBtC,IAA4B;AAExCC,YAAAQ,QAASvC,SAAQ;AACzB,UAAMqE,WAAWD,UAAUlB,IAAI/C,eAAeH,GAAG,CAAC;AAClD,QAAIA,IAAIC,IAAIC,WAAW,SAAS,GAAG;AAEjCkE,gBAAU5B,IAAIrC,eAAeH,GAAG,GAAGsE,wBAAwBtE,GAAG,CAAC;IAAA,WACtD,CAACqE,UAAU;AAEVD,gBAAA5B,IAAIxC,IAAIC,KAAKD,GAAG;IAC5B;EAAA,CACD;AAED,SAAOuE,MAAMC,KAAKJ,UAAUK,OAAA,CAAQ;AACtC;AAIA,SAASH,wBAAwBtE,KAAqC;AACpE,SAAO;IAAC,GAAGA;IAAKC,KAAKE,eAAeH,GAAG;EAAC;AAC1C;ACjMgB,SAAA0E,YAAU5G,QAAgB6G,oBAAmD;AAC3F,MAAI5C,YAA8B,CAAA;AAClC,QAAM6C,mBAAmBC,SAAS/G,OAAOgH,0BAA0B,IAAIC,uBAAuB;AAC9F,QAAMC,sBAA0C,CAAA;AAE5C,MAAA/G;AAEJ,iBAAegH,cAAc;AAC3B,QAAI,CAAChH,SAAS;AACFA,gBAAA4C,kBACR/C,QACC2D,UAAS;AACIM,oBAAAN;AACKmD,yBAAA;MACnB,GACAD,kBAAA;IAEJ;AAEA,UAAM1G,QAAQ0D;EAChB;AAEe,iBAAAuD,MAAeC,WAAmBC,QAA8C;AAC7F,UAAMH,YAAY;AAClB,UAAMI,OAAOrG,MAAMmG,WAAW;MAACC;IAAO,CAAA;AAChC,UAAAE,SAAS,MAAMC,cAASF,MAAa;MAACpH,SAAS8D;MAAWqD;KAAO;AACvE,WAAOE,OAAOpC,IAAI;EACpB;AAEA,iBAAesC,YAAYvC,YAAoD;AAC7E,UAAMgC,YAAY;AAClB,WAAOC,MAAMO,KAAAC,oBAAAA,kBAAAC,uBAAA,CAAA,kBAAA,CAAA,EAAA,GAAwB;MAACtC,IAAIJ;KAAW;EACvD;AAEA,iBAAejC,cAAa4E,aAA2D;AACrF,UAAMX,YAAY;AACZ,UAAAY,aAAaD,YAAYE,IAAKzC,QAAAA,aAAAA,OAAoBA,IAAA,OAAA,CAAS,EAAE0C,KAAK,KAAK;AACtE,WAAAb,MAAA,IAAA7G,OAAUwH,YAAa,GAAA,CAAA;EAChC;AAES,WAAAG,UACPb,WACAC,QACAa,UACc;AACV,QAAA,CAACnI,OAAOF,QAAQ;AACZ,YAAA,IAAIuB,MAAM,iDAAiD;IACnE;AAKA,UAAM+G,eAAe;MAAChB,OAAOC;MAAWC;MAAQa;IAAQ;AACxDjB,wBAAoBpC,KAAKsD,YAAY;AAErC,QAAIC,eAAe;AACnB,UAAMxG,cAAcA,MAAM;AACxB,UAAIwG,cAAc;AAChB,eAAOvG,QAAQC,QAAQ;MACzB;AAEesG,qBAAA;AACfnB,0BAAoBvB,OAAOuB,oBAAoBxB,QAAQ0C,YAAY,GAAG,CAAC;AACvE,aAAOtG,QAAQC,QAAQ;IAAA;AAGzBuG,6BAAyBF,YAAY;AACrC,WAAO;MAACvG;IAAW;EACrB;AAEA,WAASyG,yBAAyBF,cAAgC;AACzD,WAAAhB,MAAMgB,aAAahB,OAAOgB,aAAad,MAAM,EACjDxD,KAAMyE,SAAQ;AACb,UAAI,oBAAoBH,oBAAgBI,uBAAAA,SAAUJ,aAAaK,gBAAgBF,GAAG,GAAG;AACnF;MACF;AAEAH,mBAAaK,iBAAiBF;AACjBH,mBAAAD,SAAS,QAAWI,GAAG;IAAA,CACrC,EACAG,MAAOvH,SAAQ;AACdiH,mBAAaD,SAAShH,GAAG;IAAA,CAC1B;EACL;AAEA,WAAS8F,0BAA0B;AACjCC,wBAAoBzC,QAAQ6D,wBAAwB;EACtD;AAEA,WAASvH,QAAQ;AACf+F,qBAAiB6B,OAAO;AACxB,WAAOxI,UAAUA,QAAQ0B,YAAY,IAAIC,QAAQC,QAAQ;EAC3D;AAEA,SAAO;IAACqF;IAAOM;IAAaxE,cAAAA;IAAcgF;IAAWnH;EAAK;AAC5D;ACjGa,IAAAmC,eAAmD,eAAeA,cAAa0F,OAY9D;AAAA,MAZ8D;IAC1F1I;IACAC;IACAC;IACAiD;IACAC,eAAe,CAAA;EACjB,IAM8BsF;AACtB,QAAAC,UAAA,WAAAtI,OAAqBL,WAA0C,gCAAA,EAAAK,OAAAJ,OAAA;AACrE,QAAMmH,SACJhE,aAAawF,SAAS,IAAI,IAAIC,gBAAgB;IAACC,OAAO1F,gBAAc,OAAA,SAAAA,aAAA2E,KAAK,GAAI;EAAA,CAAC,IAAI;AAC9E,QAAAzH,MAAA,GAAAD,OAASsI,SAAW,GAAA,EAAAtI,OAAA+G,MAAA;AAC1B,QAAMjH,UAAUD,QAAQ;IAACE,eAAe,UAAAC,OAAUH,KAAAA;MAAW;AACvD,QAAA6I,WAAW,MAAMC,MAAM1I,KAAK;IAAC2I,aAAa;IAAW9I;GAAQ;AAE/D,MAAA4I,SAASG,WAAW,KAAK;AACrB,UAAA,IAAI/H,MAAAA,4BAAAA,OAAkCgI,SAAS,MAAMJ,SAASK,KAAA,CAAM,CAAG,CAAA;EAC/E;AAEM,QAAAC,SAASC,kBAAkBP,SAASQ,IAAI;AACxC,QAAAC,SAASH,OAAOI,UAAU;AAEhC,QAAM1F,YAA8B,CAAA;AAChC,MAAAuD;AACA,MAAAlF;AACD,KAAA;AACQkF,aAAA,MAAMkC,OAAOE,KAAK;AAC3BtH,eAAWkF,OAAOqC;AAEd,QAAAC,cAAcxH,QAAQ,GAAG;AAC3B,YAAM,IAAIjB,MAAA,4BAAAd,OAAkC+B,SAASlB,KAAO,CAAA;IACnD,WAAAkB,YAAYyH,mBAAmBzH,QAAQ,GAAG;AACnD2B,gBAAUa,KAAKxC,QAAQ;IACzB;AAEI,QAAAe,iBAAiBY,UAAU6E,SAASzF,eAAe;AACrDqG,aAAOf,OAAO,wBAAwB;AACtC,YAAM,IAAItH,MAAA,6CAAAd,OACqC8C,eAAA,yGAAA,CAAA;IAEjD;EAAA,SACO,CAACmE,OAAOwC;AAEV,SAAA/F;AACT;AAEA,SAASuF,kBAAkBC,MAAsD;AAC/E,MAAI,CAACA,MAAM;AACH,UAAA,IAAIpI,MAAM,mCAAmC;EACrD;AAEI,MAAAqI;AACJ,MAAIO,YAAY;AAEhB,WAAStB,SAAS;AACJsB,gBAAA;AACZ,QAAIP,QAAQ;AACVA,aAAOf,OAAO;IAChB;EACF;AAEA,SAAO,IAAIuB,eAA+B;IACxCC,MAAMC,YAAsC;AAC1CV,eAASD,KAAKE,UAAU;AAClB,YAAAU,UAAU,IAAIC,YAAY;AAChC,UAAIpG,SAAS;AAGVwF,aAAAE,KAAA,EACA9F,KAAKyG,aAAa,EAClB7B,MAAOvH,SAAQiJ,WAAWhJ,MAAMD,GAAG,CAAC;AAEvC,qBAAeoJ,cAAc/C,QAA6D;AACxF,YAAIA,OAAOwC,MAAM;AACf,cAAIC,WAAW;AACb;UACF;AAEA/F,mBAASA,OAAOsG,KAAK;AACjB,cAAAtG,OAAO4E,WAAW,GAAG;AACvBsB,uBAAWrJ,MAAM;AACjB;UACF;AAEAqJ,qBAAWK,QAAQxJ,KAAKC,MAAMgD,MAAM,CAAC;AACrCkG,qBAAWrJ,MAAM;AACjB;QACF;AAEAmD,kBAAUmG,QAAQK,OAAOlD,OAAOqC,OAAO;UAACN,QAAQ;SAAK;AAC/C,cAAAoB,QAAQzG,OAAO0G,MAAM,IAAI;AAE/B,iBAASC,IAAI,GAAGA,IAAIF,MAAM7B,SAAS,GAAG,EAAE+B,GAAG;AACzC,gBAAMC,OAAOH,MAAME,CAAC,EAAEL,KAAK;AACvB,cAAAM,KAAKhC,WAAW,GAAG;AACrB;UACF;AAEI,cAAA;AACFsB,uBAAWK,QAAQxJ,KAAKC,MAAM4J,IAAI,CAAC;mBAC5B3J;AACPiJ,uBAAWhJ,MAAMD,GAAG;AACbwH,mBAAA;AACP;UACF;QACF;AAESzE,iBAAAyG,MAAMA,MAAM7B,SAAS,CAAC;AAE/B,YAAI,CAACY,QAAQ;AACX;QACF;AAEI,YAAA;AACYa,wBAAA,MAAMb,OAAOE,KAAA,CAAM;iBAC1BzI;AACPiJ,qBAAWhJ,MAAMD,GAAG;QACtB;MACF;IACF;IAEAwH;EAAA,CACD;AACH;AAEA,SAASmB,cAActC,QAAyD;AAC9E,MAAI,CAACA,QAAQ;AACJ,WAAA;EACT;AAEI,MAAA,EAAE,WAAWA,WAAW,OAAOA,OAAOpG,UAAU,YAAYoG,OAAOpG,UAAU,MAAM;AAC9E,WAAA;EACT;AAGE,SAAA,iBAAiBoG,OAAOpG,SACxB,OAAQoG,OAAuBpG,MAAM2J,gBAAgB,YACrD,EAAE,SAASvD;AAEf;AAEA,SAAS6B,SAASI,MAAmB;AACnC,MAAI,OAAOA,SAAS,YAAY,WAAWA,QAAQ,aAAaA,MAAM;AAC7D,WAAAA,KAAKnI,WAAWmI,KAAKrI;EAC9B;AAEO,SAAA;AACT;AAEA,SAAS2I,mBAAmB7H,KAA8B;AACxD,SAAO,CAACA,IAAIC,IAAIC,WAAW,IAAI;AACjC;AClKO,SAAS4I,mBAAyB;AACvC,QAAMC,WAAW,CAAC,eAAe,kBAAkB,OAAO;AAC1D,QAAMC,cAAcD,SAASE,OAAQC,SAAQ,EAAEA,OAAO9L,OAAO;AAEzD,MAAA4L,YAAYpC,SAAS,GAAG;AAC1B,UAAM,IAAIzH,MAAM,gDAAAd,OAAgD2K,YAAYjD,KAAK,IAAI,CAAG,CAAA;EAC1F;AACF;ACDO,SAASrB,UAAU5G,QAA2B;AANrD,MAAAqL;AAOmBL,mBAAA;AAEjB,QAAMxL,eAAc6L,KAAArL,OAAOR,gBAAP,OAAA6L,KAAsB/L,OAAOE;AAEjD,MAAIQ,OAAOI,OAAO;AACZ,QAAA,CAACJ,OAAOR,aAAa;AACvB,YAAM,IAAI6B,MACR,iFAAA;IAEJ;AACI,QAAArB,OAAOR,gBAAgBF,OAAOE;AAChC,YAAM,IAAI6B,MACR,qKAAA;EAGN;AAEA,SAAOiK,YAAatL,QAAQ;IAC1BR;IACA0D;EAAA,CACD;AACH;",
  "names": ["length", "delay", "callback", "options", "noTrailing", "noLeading", "debounceMode", "undefined", "timeoutID", "cancelled", "lastExec", "clearExistingTimeout", "clearTimeout", "cancel", "upcomingOnly", "wrapper", "arguments_", "self", "elapsed", "Date", "now", "exec", "apply", "clear", "setTimeout", "escapeRegExp", "string", "replace", "pathRegExp", "pattern", "re", "part", "split", "push", "RegExp", "concat", "join", "Path", "constructor", "patternRe", "matches", "str", "test", "toJSON", "StreamValue", "generator", "type", "ticker", "isDone", "data", "isArray", "get", "result", "value", "Symbol", "asyncIterator", "i", "length", "_nextTick", "currentResolver", "setupTicker", "Promise", "resolve", "tick", "fetch", "RFC3339_REGEX", "parseRFC3339", "Date", "formatRFC3339", "d", "year", "addLeadingZero", "getUTCFullYear", "month", "getUTCMonth", "day", "getUTCDate", "hour", "getUTCHours", "minute", "getUTCMinutes", "second", "getUTCSeconds", "fractionalSecond", "millis", "getMilliseconds", "num", "targetLength", "toString", "StaticValue", "Array", "element", "fromJS", "Error", "NULL_VALUE", "TRUE_VALUE", "FALSE_VALUE", "DateTime", "date", "parseToValue", "equals", "other", "getTime", "add", "secs", "copy", "setTime", "difference", "compareTo", "fromNumber", "Number", "isFinite", "fromString", "fromDateTime", "dt", "fromPath", "path", "isIterator", "obj", "next", "val", "getType", "isEqual", "a", "b", "CHARS", "CHARS_WITH_WILDCARD", "EDGE_CHARS", "MAX_TERM_LENGTH", "matchText", "tokens", "patterns", "every", "matchTokenize", "text", "match", "matchAnalyzePattern", "termsRe", "matchPatternRegex", "map", "some", "token", "terms", "term", "slice", "gatherText", "cb", "success", "TYPE_ORDER", "datetime", "number", "boolean", "partialCompare", "aType", "bType", "totalCompare", "aTypeOrder", "bTypeOrder", "operators", "eq", "left", "right", "neq", "gt", "gte", "lt", "lte", "in", "inop", "didSucceed", "matched", "plus", "minus", "numericOperator", "Math", "pow", "impl", "Scope", "params", "source", "context", "parent", "isHidden", "createNested", "createHidden", "evaluate", "node", "scope", "execute", "arguments", "undefined", "func", "EXECUTORS", "promiselessApply", "then", "This", "_", "Selector", "Everything", "Parameter", "_ref", "name", "Context", "_ref2", "key", "Parent", "_ref3", "n", "current", "OpCall", "op", "_ref4", "leftValue", "rightValue", "Select", "_ref5", "alternatives", "fallback", "alt", "altCond", "condition", "InRange", "base", "isInclusive", "_ref6", "leftCmp", "rightCmp", "Filter", "_ref7", "expr", "baseValue", "elem", "newScope", "exprValue", "Projection", "_ref8", "FuncCall", "args", "_ref9", "PipeFuncCall", "_ref10", "AccessAttribute", "_ref11", "hasOwnProperty", "AccessElement", "_ref12", "index", "finalIndex", "Slice", "_ref13", "array", "leftIdx", "rightIdx", "Deref", "_ref14", "id", "doc", "_id", "Value", "_ref15", "Group", "_ref16", "Object", "_ref17", "attributes", "attr", "attrType", "cond", "assign", "_ref18", "elements", "isSplat", "v", "Tuple", "Or", "_ref19", "And", "_ref20", "Not", "_ref21", "Neg", "_ref22", "Pos", "_ref23", "Asc", "Desc", "ArrayCoerce", "_ref24", "Map", "_ref25", "FlatMap", "_ref26", "innerValue", "inner", "evaluateQuery", "tree", "options", "root", "dataset", "timestamp", "identity", "sanity", "after", "before", "canConstantEvaluate", "DUMMY_SCOPE", "tryConstantEvaluate", "constantEvaluate", "portableTextContent", "blockText", "texts", "arrayText", "block", "_type", "children", "child", "BM25k", "evaluateScore", "evaluateMatchScore", "innerScore", "boost", "leftScore", "rightScore", "res", "score", "freq", "reduce", "c", "hasReference", "pathSet", "has", "values", "countUTF8", "count", "code", "charCodeAt", "_global", "anywhere", "arity", "coalesce", "arg", "dateTime", "defined", "references", "Set", "size", "scopeValue", "round", "prec", "precValue", "isInteger", "toFixed", "now", "toISOString", "lower", "toLowerCase", "upper", "toUpperCase", "sep", "from", "startsWith", "prefix", "arr", "buf", "needSep", "compact", "unique", "added", "iter", "pt", "projectId", "pipeFunctions", "order", "mappers", "directions", "mapper", "direction", "aux", "idx", "tuple", "sort", "aTuple", "bTuple", "unknown", "scored", "valueScore", "_score", "newObject", "delta", "operation", "hasBefore", "hasAfter", "changedAny", "mode", "changedOnly", "diff", "math", "min", "max", "sum", "avg", "namespaces", "global", "MarkProcessor", "marks", "parseOptions", "allowBoost", "hasMark", "pos", "getMark", "shift", "process", "visitor", "mark", "call", "processString", "processStringEnd", "prev", "curr", "position", "len", "WS", "NUM", "IDENT", "PREC_PAIR", "PREC_OR", "PREC_AND", "PREC_COMP", "PREC_ORDER", "PREC_ADD", "PREC_SUB", "PREC_MUL", "PREC_DIV", "PREC_MOD", "PREC_POW", "PREC_POS", "PREC_NOT", "PREC_NEG", "parse", "skipWS", "parseExpr", "failPosition", "level", "startPos", "rhs", "parseObject", "parseString", "identLen", "parseRegex", "numLen", "fracLen", "expLen", "parseFuncCall", "lhsLevel", "trav", "loop", "innerPos", "parseTraversal", "unshift", "nextToken", "nextPos", "identPos", "ident", "parseRegexStr", "isGroup", "rangePos", "identStart", "nameLen", "lastPos", "pairPos", "indexOf", "m", "exec", "flatMap", "traverseArray", "build", "traversePlain", "traverseElement", "traverseProjection", "ESCAPE_SEQUENCE", "f", "r", "t", "expandHex", "charCode", "parseInt", "String", "fromCharCode", "GroqQueryError", "EXPR_BUILDER", "group", "p", "everything", "this", "dblparent", "traverse", "traversalList", "TRAVERSE_BUILDER", "traversal", "this_attr", "neg", "sub", "mul", "div", "mod", "comp", "in_range", "char", "integer", "strValue", "float", "sci", "object", "OBJECT_BUILDER", "members", "func_call", "namespace", "argumentShouldBeSelector", "SELECTOR_BUILDER", "funcs", "validateArity", "pipecall", "oldAllowBoost", "markName", "pair", "and", "or", "not", "asc", "desc", "param", "object_expr", "extractPropertyKey", "object_pair", "object_splat", "object_splat_this", "square_bracket", "projection", "attr_access", "deref", "wrap", "array_postfix", "functionName", "argCount", "functionsRequiringSelectors", "includes", "GroqSyntaxError", "input", "rawParse", "processor", "isNativeBrowserEventSource", "eventSource", "window", "addEventListener", "EventSource", "prototype", "isPolyfillEventSource", "addEventSourceListener", "type", "listener", "listen", "EventSourceImpl", "config", "handlers", "projectId", "dataset", "token", "headers", "Authorization", "concat", "url", "es", "withCredentials", "open", "getMutationParser", "next", "msg", "close", "data", "JSON", "parse", "err", "error", "Error", "message", "statusCode", "origin", "location", "hintSuffix", "errorMessage", "isErrorLike", "unsubscribe", "Promise", "resolve", "cb", "isDraft", "doc", "_id", "startsWith", "getPublishedId", "document", "slice", "applyPatchWithoutRev", "patch", "patchDoc", "_rev", "applyPatch", "DEBOUNCE_MS", "noop", "getSyncingDataset", "onNotifyUpdate", "_ref", "getDocuments", "useListener", "overlayDrafts", "documentLimit", "includeTypes", "stagedDocs", "previousTrx", "flushTimeout", "onUpdate", "docs", "overlay", "loaded", "then", "indexedDocuments", "Map", "documents", "buffer", "onDoneLoading", "onLoadError", "reject", "onOpen", "initial", "applyBufferedMutations", "forEach", "set", "onMutationReceived", "applyMutation", "scheduleUpdate", "push", "clearTimeout", "transactionId", "setTimeout", "effects", "documentId", "get", "replaceDocument", "apply", "id", "current", "position", "indexOf", "splice", "delete", "mutations", "groups", "mutation", "group", "find", "console", "warn", "hasFoundRevision", "previousRev", "overlayed", "existing", "pretendThatItsPublished", "Array", "from", "values", "groqStore", "envImplementations", "executeThrottled", "throttle", "subscriptionThrottleMs", "executeAllSubscriptions", "activeSubscriptions", "loadDataset", "query", "groqQuery", "params", "tree", "result", "evaluate", "getDocument", "groq", "_templateObject", "_taggedTemplateLiteral", "documentIds", "subQueries", "map", "join", "subscribe", "callback", "subscription", "unsubscribed", "executeQuerySubscription", "res", "deepEqual", "previousResult", "catch", "cancel", "_ref2", "baseUrl", "length", "URLSearchParams", "types", "response", "fetch", "credentials", "status", "getError", "json", "stream", "getDocumentStream", "body", "reader", "getReader", "read", "value", "isStreamError", "isRelevantDocument", "done", "cancelled", "ReadableStream", "start", "controller", "decoder", "TextDecoder", "processResult", "trim", "enqueue", "decode", "lines", "split", "i", "line", "description", "assertEnvSupport", "required", "unsupported", "filter", "api", "_a", "groqStoreApi"]
}
